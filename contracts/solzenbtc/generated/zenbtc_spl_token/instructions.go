// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package zenbtc_spl_token

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "add_fee_discount" instruction.
func NewAddFeeDiscountInstruction(
	// Params:
	argsParam AddFeeDiscountArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	feeDiscountAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddFeeDiscount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, false, false))
		// Account 2 "fee_discount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeDiscountAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "add_mint_authority" instruction.
func NewAddMintAuthorityInstruction(
	// Params:
	argsParam AddMintAuthorityArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_AddMintAuthority[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
func NewInitializeInstruction(
	// Params:
	argsParam InitializeArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	wrappedMetadataAccountAccount solanago.PublicKey,
	tokenMetadataProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "wrapped_metadata_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(wrappedMetadataAccountAccount, true, false))
		// Account 6 "token_metadata_program": Read-only, Non-signer, Required, Address: metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
		accounts__.Append(solanago.NewAccountMeta(tokenMetadataProgramAccount, false, false))
		// Account 7 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_fee_discount" instruction.
func NewRemoveFeeDiscountInstruction(
	// Params:
	argsParam RemoveFeeDiscountArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	feeDiscountAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveFeeDiscount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, false, false))
		// Account 2 "fee_discount": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeDiscountAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "remove_mint_authority" instruction.
func NewRemoveMintAuthorityInstruction(
	// Params:
	argsParam RemoveMintAuthorityArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_RemoveMintAuthority[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "unwrap" instruction.
func NewUnwrapInstruction(
	// Params:
	argsParam UnwrapArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	splMultisigAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	signerAtaAccount solanago.PublicKey,
	feeWalletAccount solanago.PublicKey,
	feeWalletAtaAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	eventStoreProgramAccount solanago.PublicKey,
	eventStoreGlobalConfigAccount solanago.PublicKey,
	callingProgramAccount solanago.PublicKey,
	unwrapShardAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Unwrap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "spl_multisig": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(splMultisigAccount, true, false))
		// Account 3 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "signer_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAtaAccount, true, false))
		// Account 5 "fee_wallet": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeWalletAccount, true, false))
		// Account 6 "fee_wallet_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeWalletAtaAccount, true, false))
		// Account 7 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 10 "event_store_program": Read-only, Non-signer, Required
		// EventStore program for CPI calls
		accounts__.Append(solanago.NewAccountMeta(eventStoreProgramAccount, false, false))
		// Account 11 "event_store_global_config": Read-only, Non-signer, Required
		// EventStore global config PDA
		accounts__.Append(solanago.NewAccountMeta(eventStoreGlobalConfigAccount, false, false))
		// Account 12 "calling_program": Read-only, Non-signer, Required
		// This program (zenbtc) as the calling program for EventStore CPI
		accounts__.Append(solanago.NewAccountMeta(callingProgramAccount, false, false))
		// Account 13 "unwrap_shard": Writable, Non-signer, Required
		// Unwrap shard account (determined by event ID and program type)
		accounts__.Append(solanago.NewAccountMeta(unwrapShardAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_burn_fee_bps" instruction.
func NewUpdateBurnFeeBpsInstruction(
	// Params:
	argsParam UpdateBurnFeeBpsArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateBurnFeeBps[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_fee_wallet" instruction.
func NewUpdateFeeWalletInstruction(
	// Params:
	argsParam UpdateFeeWalletArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateFeeWallet[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_global_authority" instruction.
func NewUpdateGlobalAuthorityInstruction(
	// Params:
	argsParam UpdateGlobalAuthorityArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateGlobalAuthority[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		// Signer must be the global authority
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		// Global configuration account storing authorities
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "wrap" instruction.
func NewWrapInstruction(
	// Params:
	argsParam WrapArgs,

	// Accounts:
	signerAccount solanago.PublicKey,
	globalConfigAccount solanago.PublicKey,
	splMultisigAccount solanago.PublicKey,
	mintAccount solanago.PublicKey,
	feeWalletAccount solanago.PublicKey,
	feeWalletAtaAccount solanago.PublicKey,
	receiverAccount solanago.PublicKey,
	receiverAtaAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	eventStoreProgramAccount solanago.PublicKey,
	eventStoreGlobalConfigAccount solanago.PublicKey,
	callingProgramAccount solanago.PublicKey,
	wrapShardAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Wrap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `argsParam`:
		err = enc__.Encode(argsParam)
		if err != nil {
			return nil, errors.NewField("argsParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "signer": Writable, Signer, Required
		accounts__.Append(solanago.NewAccountMeta(signerAccount, true, true))
		// Account 1 "global_config": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(globalConfigAccount, true, false))
		// Account 2 "spl_multisig": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(splMultisigAccount, true, false))
		// Account 3 "mint": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(mintAccount, true, false))
		// Account 4 "fee_wallet": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeWalletAccount, true, false))
		// Account 5 "fee_wallet_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(feeWalletAtaAccount, true, false))
		// Account 6 "receiver": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverAccount, false, false))
		// Account 7 "receiver_ata": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(receiverAtaAccount, true, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 11 "event_store_program": Read-only, Non-signer, Required
		// EventStore program for CPI calls
		accounts__.Append(solanago.NewAccountMeta(eventStoreProgramAccount, false, false))
		// Account 12 "event_store_global_config": Read-only, Non-signer, Required
		// EventStore global config PDA
		accounts__.Append(solanago.NewAccountMeta(eventStoreGlobalConfigAccount, false, false))
		// Account 13 "calling_program": Read-only, Non-signer, Required
		// This program (zenbtc) as the calling program for EventStore CPI
		accounts__.Append(solanago.NewAccountMeta(callingProgramAccount, false, false))
		// Account 14 "wrap_shard": Writable, Non-signer, Required
		// Wrap shard account (determined by event ID and program type)
		accounts__.Append(solanago.NewAccountMeta(wrapShardAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
