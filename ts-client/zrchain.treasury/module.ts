// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MetadataSolana } from "./types/zrchain/treasury/tx";
import { MsgUpdateParams } from "./types/zrchain/treasury/tx";
import { QueryKeyRequestByIDRequest } from "./types/zrchain/treasury/query";
import { QueryKeyRequestByIDResponse } from "./types/zrchain/treasury/query";
import { ICATransactionRequest } from "./types/zrchain/treasury/mpcsign";
import { Params } from "./types/zrchain/treasury/params";
import { MsgFulfilSignatureRequestResponse } from "./types/zrchain/treasury/tx";
import { MetadataEthereum } from "./types/zrchain/treasury/tx";
import { MsgNewICATransactionRequest } from "./types/zrchain/treasury/tx";
import { KeyAndWalletResponse } from "./types/zrchain/treasury/query";
import { QuerySignatureRequestByIDResponse } from "./types/zrchain/treasury/query";
import { SignedDataWithID } from "./types/zrchain/treasury/mpcsign";
import { MsgNewSignatureRequestResponse } from "./types/zrchain/treasury/tx";
import { MsgNewSignTransactionRequestResponse } from "./types/zrchain/treasury/tx";
import { MsgTransferFromKeyring } from "./types/zrchain/treasury/tx";
import { QuerySignTransactionRequestByIDResponse } from "./types/zrchain/treasury/query";
import { KeyRequest } from "./types/zrchain/treasury/key";
import { PartySignature } from "./types/zrchain/treasury/key";
import { SignRequest } from "./types/zrchain/treasury/mpcsign";
import { MsgFulfilKeyRequest } from "./types/zrchain/treasury/tx";
import { MsgNewSignatureRequest } from "./types/zrchain/treasury/tx";
import { QueryKeyRequestsResponse } from "./types/zrchain/treasury/query";
import { QueryKeyByIDRequest } from "./types/zrchain/treasury/query";
import { QueryKeyByIDResponse } from "./types/zrchain/treasury/query";
import { QueryZenbtcWalletsRequest } from "./types/zrchain/treasury/query";
import { MsgUpdateParamsResponse } from "./types/zrchain/treasury/tx";
import { QuerySignatureRequestsResponse } from "./types/zrchain/treasury/query";
import { QueryZrSignKeysResponse } from "./types/zrchain/treasury/query";
import { GenesisState } from "./types/zrchain/treasury/genesis";
import { Key } from "./types/zrchain/treasury/key";
import { KeyReqResponse } from "./types/zrchain/treasury/key";
import { KeyResponse } from "./types/zrchain/treasury/key";
import { NoData } from "./types/zrchain/treasury/packet";
import { SignReqResponse } from "./types/zrchain/treasury/mpcsign";
import { MsgFulfilSignatureRequest } from "./types/zrchain/treasury/tx";
import { MsgNewZrSignSignatureRequest } from "./types/zrchain/treasury/tx";
import { QueryKeyRequestsRequest } from "./types/zrchain/treasury/query";
import { QuerySignatureRequestsRequest } from "./types/zrchain/treasury/query";
import { QuerySignatureRequestByIDRequest } from "./types/zrchain/treasury/query";
import { QuerySignTransactionRequestsResponse } from "./types/zrchain/treasury/query";
import { MsgNewKeyRequest } from "./types/zrchain/treasury/tx";
import { MsgFulfilKeyRequestResponse } from "./types/zrchain/treasury/tx";
import { MsgTransferFromKeyringResponse } from "./types/zrchain/treasury/tx";
import { QueryKeysRequest } from "./types/zrchain/treasury/query";
import { SignTransactionRequestsResponse } from "./types/zrchain/treasury/query";
import { QueryZenbtcWalletsResponse } from "./types/zrchain/treasury/query";
import { MsgNewICATransactionRequestResponse } from "./types/zrchain/treasury/tx";
import { QueryKeysResponse } from "./types/zrchain/treasury/query";
import { QuerySignTransactionRequestsRequest } from "./types/zrchain/treasury/query";
import { QueryKeyByAddressRequest } from "./types/zrchain/treasury/query";
import { QueryKeyByAddressResponse } from "./types/zrchain/treasury/query";
import { MsgNewKey } from "./types/zrchain/treasury/tx";
import { MsgUpdateKeyPolicy } from "./types/zrchain/treasury/tx";
import { QueryParamsResponse } from "./types/zrchain/treasury/query";
import { QuerySignTransactionRequestByIDRequest } from "./types/zrchain/treasury/query";
import { QueryZrSignKeysRequest } from "./types/zrchain/treasury/query";
import { MsgNewKeyRequestResponse } from "./types/zrchain/treasury/tx";
import { MsgFulfilICATransactionRequest } from "./types/zrchain/treasury/tx";
import { SignTransactionRequest } from "./types/zrchain/treasury/mpcsign";
import { SignTxReqResponse } from "./types/zrchain/treasury/mpcsign";
import { WalletResponse } from "./types/zrchain/treasury/query";
import { TreasuryPacketData } from "./types/zrchain/treasury/packet";
import { MsgNewSignTransactionRequest } from "./types/zrchain/treasury/tx";
import { MsgFulfilICATransactionRequestResponse } from "./types/zrchain/treasury/tx";
import { MsgUpdateKeyPolicyResponse } from "./types/zrchain/treasury/tx";
import { QueryParamsRequest } from "./types/zrchain/treasury/query";
import { ZrSignKeyEntry } from "./types/zrchain/treasury/query";
import { ZenBTCMetadata } from "./types/zrchain/treasury/key";
import { MsgNewZrSignSignatureRequestResponse } from "./types/zrchain/treasury/tx";

import { PartySignature as typePartySignature} from "./types"
import { KeyRequest as typeKeyRequest} from "./types"
import { KeyReqResponse as typeKeyReqResponse} from "./types"
import { Key as typeKey} from "./types"
import { KeyResponse as typeKeyResponse} from "./types"
import { ZenBTCMetadata as typeZenBTCMetadata} from "./types"
import { SignRequest as typeSignRequest} from "./types"
import { SignedDataWithID as typeSignedDataWithID} from "./types"
import { SignTransactionRequest as typeSignTransactionRequest} from "./types"
import { SignReqResponse as typeSignReqResponse} from "./types"
import { SignTxReqResponse as typeSignTxReqResponse} from "./types"
import { ICATransactionRequest as typeICATransactionRequest} from "./types"
import { TreasuryPacketData as typeTreasuryPacketData} from "./types"
import { NoData as typeNoData} from "./types"
import { Params as typeParams} from "./types"
import { KeyAndWalletResponse as typeKeyAndWalletResponse} from "./types"
import { WalletResponse as typeWalletResponse} from "./types"
import { SignTransactionRequestsResponse as typeSignTransactionRequestsResponse} from "./types"
import { ZrSignKeyEntry as typeZrSignKeyEntry} from "./types"
import { MsgNewKey as typeMsgNewKey} from "./types"
import { MetadataEthereum as typeMetadataEthereum} from "./types"
import { MetadataSolana as typeMetadataSolana} from "./types"

export { MetadataSolana, MsgUpdateParams, QueryKeyRequestByIDRequest, QueryKeyRequestByIDResponse, ICATransactionRequest, Params, MsgFulfilSignatureRequestResponse, MetadataEthereum, MsgNewICATransactionRequest, KeyAndWalletResponse, QuerySignatureRequestByIDResponse, SignedDataWithID, MsgNewSignatureRequestResponse, MsgNewSignTransactionRequestResponse, MsgTransferFromKeyring, QuerySignTransactionRequestByIDResponse, KeyRequest, PartySignature, SignRequest, MsgFulfilKeyRequest, MsgNewSignatureRequest, QueryKeyRequestsResponse, QueryKeyByIDRequest, QueryKeyByIDResponse, QueryZenbtcWalletsRequest, MsgUpdateParamsResponse, QuerySignatureRequestsResponse, QueryZrSignKeysResponse, GenesisState, Key, KeyReqResponse, KeyResponse, NoData, SignReqResponse, MsgFulfilSignatureRequest, MsgNewZrSignSignatureRequest, QueryKeyRequestsRequest, QuerySignatureRequestsRequest, QuerySignatureRequestByIDRequest, QuerySignTransactionRequestsResponse, MsgNewKeyRequest, MsgFulfilKeyRequestResponse, MsgTransferFromKeyringResponse, QueryKeysRequest, SignTransactionRequestsResponse, QueryZenbtcWalletsResponse, MsgNewICATransactionRequestResponse, QueryKeysResponse, QuerySignTransactionRequestsRequest, QueryKeyByAddressRequest, QueryKeyByAddressResponse, MsgNewKey, MsgUpdateKeyPolicy, QueryParamsResponse, QuerySignTransactionRequestByIDRequest, QueryZrSignKeysRequest, MsgNewKeyRequestResponse, MsgFulfilICATransactionRequest, SignTransactionRequest, SignTxReqResponse, WalletResponse, TreasuryPacketData, MsgNewSignTransactionRequest, MsgFulfilICATransactionRequestResponse, MsgUpdateKeyPolicyResponse, QueryParamsRequest, ZrSignKeyEntry, ZenBTCMetadata, MsgNewZrSignSignatureRequestResponse };

type sendMetadataSolanaParams = {
  value: MetadataSolana,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyRequestByIDRequestParams = {
  value: QueryKeyRequestByIDRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyRequestByIDResponseParams = {
  value: QueryKeyRequestByIDResponse,
  fee?: StdFee,
  memo?: string
};

type sendICATransactionRequestParams = {
  value: ICATransactionRequest,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendMsgFulfilSignatureRequestResponseParams = {
  value: MsgFulfilSignatureRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendMetadataEthereumParams = {
  value: MetadataEthereum,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewICATransactionRequestParams = {
  value: MsgNewICATransactionRequest,
  fee?: StdFee,
  memo?: string
};

type sendKeyAndWalletResponseParams = {
  value: KeyAndWalletResponse,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignatureRequestByIDResponseParams = {
  value: QuerySignatureRequestByIDResponse,
  fee?: StdFee,
  memo?: string
};

type sendSignedDataWithIDParams = {
  value: SignedDataWithID,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewSignatureRequestResponseParams = {
  value: MsgNewSignatureRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewSignTransactionRequestResponseParams = {
  value: MsgNewSignTransactionRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgTransferFromKeyringParams = {
  value: MsgTransferFromKeyring,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignTransactionRequestByIDResponseParams = {
  value: QuerySignTransactionRequestByIDResponse,
  fee?: StdFee,
  memo?: string
};

type sendKeyRequestParams = {
  value: KeyRequest,
  fee?: StdFee,
  memo?: string
};

type sendPartySignatureParams = {
  value: PartySignature,
  fee?: StdFee,
  memo?: string
};

type sendSignRequestParams = {
  value: SignRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgFulfilKeyRequestParams = {
  value: MsgFulfilKeyRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewSignatureRequestParams = {
  value: MsgNewSignatureRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyRequestsResponseParams = {
  value: QueryKeyRequestsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyByIDRequestParams = {
  value: QueryKeyByIDRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyByIDResponseParams = {
  value: QueryKeyByIDResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryZenbtcWalletsRequestParams = {
  value: QueryZenbtcWalletsRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignatureRequestsResponseParams = {
  value: QuerySignatureRequestsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryZrSignKeysResponseParams = {
  value: QueryZrSignKeysResponse,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendKeyParams = {
  value: Key,
  fee?: StdFee,
  memo?: string
};

type sendKeyReqResponseParams = {
  value: KeyReqResponse,
  fee?: StdFee,
  memo?: string
};

type sendKeyResponseParams = {
  value: KeyResponse,
  fee?: StdFee,
  memo?: string
};

type sendNoDataParams = {
  value: NoData,
  fee?: StdFee,
  memo?: string
};

type sendSignReqResponseParams = {
  value: SignReqResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgFulfilSignatureRequestParams = {
  value: MsgFulfilSignatureRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewZrSignSignatureRequestParams = {
  value: MsgNewZrSignSignatureRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyRequestsRequestParams = {
  value: QueryKeyRequestsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignatureRequestsRequestParams = {
  value: QuerySignatureRequestsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignatureRequestByIDRequestParams = {
  value: QuerySignatureRequestByIDRequest,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignTransactionRequestsResponseParams = {
  value: QuerySignTransactionRequestsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewKeyRequestParams = {
  value: MsgNewKeyRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgFulfilKeyRequestResponseParams = {
  value: MsgFulfilKeyRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgTransferFromKeyringResponseParams = {
  value: MsgTransferFromKeyringResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeysRequestParams = {
  value: QueryKeysRequest,
  fee?: StdFee,
  memo?: string
};

type sendSignTransactionRequestsResponseParams = {
  value: SignTransactionRequestsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryZenbtcWalletsResponseParams = {
  value: QueryZenbtcWalletsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewICATransactionRequestResponseParams = {
  value: MsgNewICATransactionRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeysResponseParams = {
  value: QueryKeysResponse,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignTransactionRequestsRequestParams = {
  value: QuerySignTransactionRequestsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyByAddressRequestParams = {
  value: QueryKeyByAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryKeyByAddressResponseParams = {
  value: QueryKeyByAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewKeyParams = {
  value: MsgNewKey,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateKeyPolicyParams = {
  value: MsgUpdateKeyPolicy,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignTransactionRequestByIDRequestParams = {
  value: QuerySignTransactionRequestByIDRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryZrSignKeysRequestParams = {
  value: QueryZrSignKeysRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewKeyRequestResponseParams = {
  value: MsgNewKeyRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgFulfilICATransactionRequestParams = {
  value: MsgFulfilICATransactionRequest,
  fee?: StdFee,
  memo?: string
};

type sendSignTransactionRequestParams = {
  value: SignTransactionRequest,
  fee?: StdFee,
  memo?: string
};

type sendSignTxReqResponseParams = {
  value: SignTxReqResponse,
  fee?: StdFee,
  memo?: string
};

type sendWalletResponseParams = {
  value: WalletResponse,
  fee?: StdFee,
  memo?: string
};

type sendTreasuryPacketDataParams = {
  value: TreasuryPacketData,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewSignTransactionRequestParams = {
  value: MsgNewSignTransactionRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgFulfilICATransactionRequestResponseParams = {
  value: MsgFulfilICATransactionRequestResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateKeyPolicyResponseParams = {
  value: MsgUpdateKeyPolicyResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendZrSignKeyEntryParams = {
  value: ZrSignKeyEntry,
  fee?: StdFee,
  memo?: string
};

type sendZenBTCMetadataParams = {
  value: ZenBTCMetadata,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewZrSignSignatureRequestResponseParams = {
  value: MsgNewZrSignSignatureRequestResponse,
  fee?: StdFee,
  memo?: string
};


type metadataSolanaParams = {
  value: MetadataSolana,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type queryKeyRequestByIdrequestParams = {
  value: QueryKeyRequestByIDRequest,
};

type queryKeyRequestByIdresponseParams = {
  value: QueryKeyRequestByIDResponse,
};

type icatransactionRequestParams = {
  value: ICATransactionRequest,
};

type paramsParams = {
  value: Params,
};

type msgFulfilSignatureRequestResponseParams = {
  value: MsgFulfilSignatureRequestResponse,
};

type metadataEthereumParams = {
  value: MetadataEthereum,
};

type msgNewIcatransactionRequestParams = {
  value: MsgNewICATransactionRequest,
};

type keyAndWalletResponseParams = {
  value: KeyAndWalletResponse,
};

type querySignatureRequestByIdresponseParams = {
  value: QuerySignatureRequestByIDResponse,
};

type signedDataWithIdParams = {
  value: SignedDataWithID,
};

type msgNewSignatureRequestResponseParams = {
  value: MsgNewSignatureRequestResponse,
};

type msgNewSignTransactionRequestResponseParams = {
  value: MsgNewSignTransactionRequestResponse,
};

type msgTransferFromKeyringParams = {
  value: MsgTransferFromKeyring,
};

type querySignTransactionRequestByIdresponseParams = {
  value: QuerySignTransactionRequestByIDResponse,
};

type keyRequestParams = {
  value: KeyRequest,
};

type partySignatureParams = {
  value: PartySignature,
};

type signRequestParams = {
  value: SignRequest,
};

type msgFulfilKeyRequestParams = {
  value: MsgFulfilKeyRequest,
};

type msgNewSignatureRequestParams = {
  value: MsgNewSignatureRequest,
};

type queryKeyRequestsResponseParams = {
  value: QueryKeyRequestsResponse,
};

type queryKeyByIdrequestParams = {
  value: QueryKeyByIDRequest,
};

type queryKeyByIdresponseParams = {
  value: QueryKeyByIDResponse,
};

type queryZenbtcWalletsRequestParams = {
  value: QueryZenbtcWalletsRequest,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type querySignatureRequestsResponseParams = {
  value: QuerySignatureRequestsResponse,
};

type queryZrSignKeysResponseParams = {
  value: QueryZrSignKeysResponse,
};

type genesisStateParams = {
  value: GenesisState,
};

type keyParams = {
  value: Key,
};

type keyReqResponseParams = {
  value: KeyReqResponse,
};

type keyResponseParams = {
  value: KeyResponse,
};

type noDataParams = {
  value: NoData,
};

type signReqResponseParams = {
  value: SignReqResponse,
};

type msgFulfilSignatureRequestParams = {
  value: MsgFulfilSignatureRequest,
};

type msgNewZrSignSignatureRequestParams = {
  value: MsgNewZrSignSignatureRequest,
};

type queryKeyRequestsRequestParams = {
  value: QueryKeyRequestsRequest,
};

type querySignatureRequestsRequestParams = {
  value: QuerySignatureRequestsRequest,
};

type querySignatureRequestByIdrequestParams = {
  value: QuerySignatureRequestByIDRequest,
};

type querySignTransactionRequestsResponseParams = {
  value: QuerySignTransactionRequestsResponse,
};

type msgNewKeyRequestParams = {
  value: MsgNewKeyRequest,
};

type msgFulfilKeyRequestResponseParams = {
  value: MsgFulfilKeyRequestResponse,
};

type msgTransferFromKeyringResponseParams = {
  value: MsgTransferFromKeyringResponse,
};

type queryKeysRequestParams = {
  value: QueryKeysRequest,
};

type signTransactionRequestsResponseParams = {
  value: SignTransactionRequestsResponse,
};

type queryZenbtcWalletsResponseParams = {
  value: QueryZenbtcWalletsResponse,
};

type msgNewIcatransactionRequestResponseParams = {
  value: MsgNewICATransactionRequestResponse,
};

type queryKeysResponseParams = {
  value: QueryKeysResponse,
};

type querySignTransactionRequestsRequestParams = {
  value: QuerySignTransactionRequestsRequest,
};

type queryKeyByAddressRequestParams = {
  value: QueryKeyByAddressRequest,
};

type queryKeyByAddressResponseParams = {
  value: QueryKeyByAddressResponse,
};

type msgNewKeyParams = {
  value: MsgNewKey,
};

type msgUpdateKeyPolicyParams = {
  value: MsgUpdateKeyPolicy,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type querySignTransactionRequestByIdrequestParams = {
  value: QuerySignTransactionRequestByIDRequest,
};

type queryZrSignKeysRequestParams = {
  value: QueryZrSignKeysRequest,
};

type msgNewKeyRequestResponseParams = {
  value: MsgNewKeyRequestResponse,
};

type msgFulfilIcatransactionRequestParams = {
  value: MsgFulfilICATransactionRequest,
};

type signTransactionRequestParams = {
  value: SignTransactionRequest,
};

type signTxReqResponseParams = {
  value: SignTxReqResponse,
};

type walletResponseParams = {
  value: WalletResponse,
};

type treasuryPacketDataParams = {
  value: TreasuryPacketData,
};

type msgNewSignTransactionRequestParams = {
  value: MsgNewSignTransactionRequest,
};

type msgFulfilIcatransactionRequestResponseParams = {
  value: MsgFulfilICATransactionRequestResponse,
};

type msgUpdateKeyPolicyResponseParams = {
  value: MsgUpdateKeyPolicyResponse,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type zrSignKeyEntryParams = {
  value: ZrSignKeyEntry,
};

type zenBtcmetadataParams = {
  value: ZenBTCMetadata,
};

type msgNewZrSignSignatureRequestResponseParams = {
  value: MsgNewZrSignSignatureRequestResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMetadataSolana({ value, fee, memo }: sendMetadataSolanaParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMetadataSolana: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.metadataSolana({ value: MetadataSolana.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMetadataSolana: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyRequestByIDRequest({ value, fee, memo }: sendQueryKeyRequestByIDRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyRequestByIDRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyRequestByIdrequest({ value: QueryKeyRequestByIDRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyRequestByIDRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyRequestByIDResponse({ value, fee, memo }: sendQueryKeyRequestByIDResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyRequestByIDResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyRequestByIdresponse({ value: QueryKeyRequestByIDResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyRequestByIDResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendICATransactionRequest({ value, fee, memo }: sendICATransactionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendICATransactionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.icatransactionRequest({ value: ICATransactionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendICATransactionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFulfilSignatureRequestResponse({ value, fee, memo }: sendMsgFulfilSignatureRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFulfilSignatureRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFulfilSignatureRequestResponse({ value: MsgFulfilSignatureRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFulfilSignatureRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMetadataEthereum({ value, fee, memo }: sendMetadataEthereumParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMetadataEthereum: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.metadataEthereum({ value: MetadataEthereum.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMetadataEthereum: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewICATransactionRequest({ value, fee, memo }: sendMsgNewICATransactionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewICATransactionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewIcatransactionRequest({ value: MsgNewICATransactionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewICATransactionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendKeyAndWalletResponse({ value, fee, memo }: sendKeyAndWalletResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendKeyAndWalletResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.keyAndWalletResponse({ value: KeyAndWalletResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendKeyAndWalletResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignatureRequestByIDResponse({ value, fee, memo }: sendQuerySignatureRequestByIDResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignatureRequestByIDResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignatureRequestByIdresponse({ value: QuerySignatureRequestByIDResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignatureRequestByIDResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignedDataWithID({ value, fee, memo }: sendSignedDataWithIDParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignedDataWithID: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signedDataWithId({ value: SignedDataWithID.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignedDataWithID: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewSignatureRequestResponse({ value, fee, memo }: sendMsgNewSignatureRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewSignatureRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewSignatureRequestResponse({ value: MsgNewSignatureRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewSignatureRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewSignTransactionRequestResponse({ value, fee, memo }: sendMsgNewSignTransactionRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewSignTransactionRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewSignTransactionRequestResponse({ value: MsgNewSignTransactionRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewSignTransactionRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgTransferFromKeyring({ value, fee, memo }: sendMsgTransferFromKeyringParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgTransferFromKeyring: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgTransferFromKeyring({ value: MsgTransferFromKeyring.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgTransferFromKeyring: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignTransactionRequestByIDResponse({ value, fee, memo }: sendQuerySignTransactionRequestByIDResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignTransactionRequestByIDResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignTransactionRequestByIdresponse({ value: QuerySignTransactionRequestByIDResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignTransactionRequestByIDResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendKeyRequest({ value, fee, memo }: sendKeyRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendKeyRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.keyRequest({ value: KeyRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendKeyRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPartySignature({ value, fee, memo }: sendPartySignatureParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPartySignature: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.partySignature({ value: PartySignature.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPartySignature: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignRequest({ value, fee, memo }: sendSignRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signRequest({ value: SignRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFulfilKeyRequest({ value, fee, memo }: sendMsgFulfilKeyRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFulfilKeyRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFulfilKeyRequest({ value: MsgFulfilKeyRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFulfilKeyRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewSignatureRequest({ value, fee, memo }: sendMsgNewSignatureRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewSignatureRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewSignatureRequest({ value: MsgNewSignatureRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewSignatureRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyRequestsResponse({ value, fee, memo }: sendQueryKeyRequestsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyRequestsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyRequestsResponse({ value: QueryKeyRequestsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyRequestsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyByIDRequest({ value, fee, memo }: sendQueryKeyByIDRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyByIDRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyByIdrequest({ value: QueryKeyByIDRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyByIDRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyByIDResponse({ value, fee, memo }: sendQueryKeyByIDResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyByIDResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyByIdresponse({ value: QueryKeyByIDResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyByIDResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryZenbtcWalletsRequest({ value, fee, memo }: sendQueryZenbtcWalletsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryZenbtcWalletsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryZenbtcWalletsRequest({ value: QueryZenbtcWalletsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryZenbtcWalletsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignatureRequestsResponse({ value, fee, memo }: sendQuerySignatureRequestsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignatureRequestsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignatureRequestsResponse({ value: QuerySignatureRequestsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignatureRequestsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryZrSignKeysResponse({ value, fee, memo }: sendQueryZrSignKeysResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryZrSignKeysResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryZrSignKeysResponse({ value: QueryZrSignKeysResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryZrSignKeysResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendKey({ value, fee, memo }: sendKeyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendKey: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.key({ value: Key.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendKey: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendKeyReqResponse({ value, fee, memo }: sendKeyReqResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendKeyReqResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.keyReqResponse({ value: KeyReqResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendKeyReqResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendKeyResponse({ value, fee, memo }: sendKeyResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendKeyResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.keyResponse({ value: KeyResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendKeyResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendNoData({ value, fee, memo }: sendNoDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendNoData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.noData({ value: NoData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendNoData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignReqResponse({ value, fee, memo }: sendSignReqResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignReqResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signReqResponse({ value: SignReqResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignReqResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFulfilSignatureRequest({ value, fee, memo }: sendMsgFulfilSignatureRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFulfilSignatureRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFulfilSignatureRequest({ value: MsgFulfilSignatureRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFulfilSignatureRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewZrSignSignatureRequest({ value, fee, memo }: sendMsgNewZrSignSignatureRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewZrSignSignatureRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewZrSignSignatureRequest({ value: MsgNewZrSignSignatureRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewZrSignSignatureRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyRequestsRequest({ value, fee, memo }: sendQueryKeyRequestsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyRequestsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyRequestsRequest({ value: QueryKeyRequestsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyRequestsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignatureRequestsRequest({ value, fee, memo }: sendQuerySignatureRequestsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignatureRequestsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignatureRequestsRequest({ value: QuerySignatureRequestsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignatureRequestsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignatureRequestByIDRequest({ value, fee, memo }: sendQuerySignatureRequestByIDRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignatureRequestByIDRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignatureRequestByIdrequest({ value: QuerySignatureRequestByIDRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignatureRequestByIDRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignTransactionRequestsResponse({ value, fee, memo }: sendQuerySignTransactionRequestsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignTransactionRequestsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignTransactionRequestsResponse({ value: QuerySignTransactionRequestsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignTransactionRequestsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewKeyRequest({ value, fee, memo }: sendMsgNewKeyRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewKeyRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewKeyRequest({ value: MsgNewKeyRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewKeyRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFulfilKeyRequestResponse({ value, fee, memo }: sendMsgFulfilKeyRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFulfilKeyRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFulfilKeyRequestResponse({ value: MsgFulfilKeyRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFulfilKeyRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgTransferFromKeyringResponse({ value, fee, memo }: sendMsgTransferFromKeyringResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgTransferFromKeyringResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgTransferFromKeyringResponse({ value: MsgTransferFromKeyringResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgTransferFromKeyringResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeysRequest({ value, fee, memo }: sendQueryKeysRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeysRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeysRequest({ value: QueryKeysRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeysRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignTransactionRequestsResponse({ value, fee, memo }: sendSignTransactionRequestsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignTransactionRequestsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signTransactionRequestsResponse({ value: SignTransactionRequestsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignTransactionRequestsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryZenbtcWalletsResponse({ value, fee, memo }: sendQueryZenbtcWalletsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryZenbtcWalletsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryZenbtcWalletsResponse({ value: QueryZenbtcWalletsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryZenbtcWalletsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewICATransactionRequestResponse({ value, fee, memo }: sendMsgNewICATransactionRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewICATransactionRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewIcatransactionRequestResponse({ value: MsgNewICATransactionRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewICATransactionRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeysResponse({ value, fee, memo }: sendQueryKeysResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeysResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeysResponse({ value: QueryKeysResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeysResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignTransactionRequestsRequest({ value, fee, memo }: sendQuerySignTransactionRequestsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignTransactionRequestsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignTransactionRequestsRequest({ value: QuerySignTransactionRequestsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignTransactionRequestsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyByAddressRequest({ value, fee, memo }: sendQueryKeyByAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyByAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyByAddressRequest({ value: QueryKeyByAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyByAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryKeyByAddressResponse({ value, fee, memo }: sendQueryKeyByAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryKeyByAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryKeyByAddressResponse({ value: QueryKeyByAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryKeyByAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewKey({ value, fee, memo }: sendMsgNewKeyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewKey: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewKey({ value: MsgNewKey.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewKey: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateKeyPolicy({ value, fee, memo }: sendMsgUpdateKeyPolicyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateKeyPolicy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateKeyPolicy({ value: MsgUpdateKeyPolicy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateKeyPolicy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignTransactionRequestByIDRequest({ value, fee, memo }: sendQuerySignTransactionRequestByIDRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignTransactionRequestByIDRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignTransactionRequestByIdrequest({ value: QuerySignTransactionRequestByIDRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignTransactionRequestByIDRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryZrSignKeysRequest({ value, fee, memo }: sendQueryZrSignKeysRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryZrSignKeysRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryZrSignKeysRequest({ value: QueryZrSignKeysRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryZrSignKeysRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewKeyRequestResponse({ value, fee, memo }: sendMsgNewKeyRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewKeyRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewKeyRequestResponse({ value: MsgNewKeyRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewKeyRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFulfilICATransactionRequest({ value, fee, memo }: sendMsgFulfilICATransactionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFulfilICATransactionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFulfilIcatransactionRequest({ value: MsgFulfilICATransactionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFulfilICATransactionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignTransactionRequest({ value, fee, memo }: sendSignTransactionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignTransactionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signTransactionRequest({ value: SignTransactionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignTransactionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignTxReqResponse({ value, fee, memo }: sendSignTxReqResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignTxReqResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signTxReqResponse({ value: SignTxReqResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignTxReqResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendWalletResponse({ value, fee, memo }: sendWalletResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendWalletResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.walletResponse({ value: WalletResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendWalletResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendTreasuryPacketData({ value, fee, memo }: sendTreasuryPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendTreasuryPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.treasuryPacketData({ value: TreasuryPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendTreasuryPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewSignTransactionRequest({ value, fee, memo }: sendMsgNewSignTransactionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewSignTransactionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewSignTransactionRequest({ value: MsgNewSignTransactionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewSignTransactionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFulfilICATransactionRequestResponse({ value, fee, memo }: sendMsgFulfilICATransactionRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFulfilICATransactionRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFulfilIcatransactionRequestResponse({ value: MsgFulfilICATransactionRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFulfilICATransactionRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateKeyPolicyResponse({ value, fee, memo }: sendMsgUpdateKeyPolicyResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateKeyPolicyResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateKeyPolicyResponse({ value: MsgUpdateKeyPolicyResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateKeyPolicyResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendZrSignKeyEntry({ value, fee, memo }: sendZrSignKeyEntryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendZrSignKeyEntry: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.zrSignKeyEntry({ value: ZrSignKeyEntry.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendZrSignKeyEntry: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendZenBTCMetadata({ value, fee, memo }: sendZenBTCMetadataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendZenBTCMetadata: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.zenBtcmetadata({ value: ZenBTCMetadata.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendZenBTCMetadata: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewZrSignSignatureRequestResponse({ value, fee, memo }: sendMsgNewZrSignSignatureRequestResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewZrSignSignatureRequestResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewZrSignSignatureRequestResponse({ value: MsgNewZrSignSignatureRequestResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewZrSignSignatureRequestResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		metadataSolana({ value }: metadataSolanaParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MetadataSolana", value: MetadataSolana.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MetadataSolana: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		queryKeyRequestByIdrequest({ value }: queryKeyRequestByIdrequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyRequestByIDRequest", value: QueryKeyRequestByIDRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyRequestByIDRequest: Could not create message: ' + e.message)
			}
		},
		
		queryKeyRequestByIdresponse({ value }: queryKeyRequestByIdresponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyRequestByIDResponse", value: QueryKeyRequestByIDResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyRequestByIDResponse: Could not create message: ' + e.message)
			}
		},
		
		icatransactionRequest({ value }: icatransactionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.ICATransactionRequest", value: ICATransactionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ICATransactionRequest: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		msgFulfilSignatureRequestResponse({ value }: msgFulfilSignatureRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgFulfilSignatureRequestResponse", value: MsgFulfilSignatureRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFulfilSignatureRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		metadataEthereum({ value }: metadataEthereumParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MetadataEthereum", value: MetadataEthereum.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MetadataEthereum: Could not create message: ' + e.message)
			}
		},
		
		msgNewIcatransactionRequest({ value }: msgNewIcatransactionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewICATransactionRequest", value: MsgNewICATransactionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewICATransactionRequest: Could not create message: ' + e.message)
			}
		},
		
		keyAndWalletResponse({ value }: keyAndWalletResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.KeyAndWalletResponse", value: KeyAndWalletResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:KeyAndWalletResponse: Could not create message: ' + e.message)
			}
		},
		
		querySignatureRequestByIdresponse({ value }: querySignatureRequestByIdresponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignatureRequestByIDResponse", value: QuerySignatureRequestByIDResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignatureRequestByIDResponse: Could not create message: ' + e.message)
			}
		},
		
		signedDataWithId({ value }: signedDataWithIdParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.SignedDataWithID", value: SignedDataWithID.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignedDataWithID: Could not create message: ' + e.message)
			}
		},
		
		msgNewSignatureRequestResponse({ value }: msgNewSignatureRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewSignatureRequestResponse", value: MsgNewSignatureRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewSignatureRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		msgNewSignTransactionRequestResponse({ value }: msgNewSignTransactionRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewSignTransactionRequestResponse", value: MsgNewSignTransactionRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewSignTransactionRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		msgTransferFromKeyring({ value }: msgTransferFromKeyringParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgTransferFromKeyring", value: MsgTransferFromKeyring.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgTransferFromKeyring: Could not create message: ' + e.message)
			}
		},
		
		querySignTransactionRequestByIdresponse({ value }: querySignTransactionRequestByIdresponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignTransactionRequestByIDResponse", value: QuerySignTransactionRequestByIDResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignTransactionRequestByIDResponse: Could not create message: ' + e.message)
			}
		},
		
		keyRequest({ value }: keyRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.KeyRequest", value: KeyRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:KeyRequest: Could not create message: ' + e.message)
			}
		},
		
		partySignature({ value }: partySignatureParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.PartySignature", value: PartySignature.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PartySignature: Could not create message: ' + e.message)
			}
		},
		
		signRequest({ value }: signRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.SignRequest", value: SignRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignRequest: Could not create message: ' + e.message)
			}
		},
		
		msgFulfilKeyRequest({ value }: msgFulfilKeyRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgFulfilKeyRequest", value: MsgFulfilKeyRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFulfilKeyRequest: Could not create message: ' + e.message)
			}
		},
		
		msgNewSignatureRequest({ value }: msgNewSignatureRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewSignatureRequest", value: MsgNewSignatureRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewSignatureRequest: Could not create message: ' + e.message)
			}
		},
		
		queryKeyRequestsResponse({ value }: queryKeyRequestsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyRequestsResponse", value: QueryKeyRequestsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyRequestsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryKeyByIdrequest({ value }: queryKeyByIdrequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyByIDRequest", value: QueryKeyByIDRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyByIDRequest: Could not create message: ' + e.message)
			}
		},
		
		queryKeyByIdresponse({ value }: queryKeyByIdresponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyByIDResponse", value: QueryKeyByIDResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyByIDResponse: Could not create message: ' + e.message)
			}
		},
		
		queryZenbtcWalletsRequest({ value }: queryZenbtcWalletsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryZenbtcWalletsRequest", value: QueryZenbtcWalletsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryZenbtcWalletsRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		querySignatureRequestsResponse({ value }: querySignatureRequestsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignatureRequestsResponse", value: QuerySignatureRequestsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignatureRequestsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryZrSignKeysResponse({ value }: queryZrSignKeysResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryZrSignKeysResponse", value: QueryZrSignKeysResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryZrSignKeysResponse: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		key({ value }: keyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.Key", value: Key.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Key: Could not create message: ' + e.message)
			}
		},
		
		keyReqResponse({ value }: keyReqResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.KeyReqResponse", value: KeyReqResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:KeyReqResponse: Could not create message: ' + e.message)
			}
		},
		
		keyResponse({ value }: keyResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.KeyResponse", value: KeyResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:KeyResponse: Could not create message: ' + e.message)
			}
		},
		
		noData({ value }: noDataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.NoData", value: NoData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:NoData: Could not create message: ' + e.message)
			}
		},
		
		signReqResponse({ value }: signReqResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.SignReqResponse", value: SignReqResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignReqResponse: Could not create message: ' + e.message)
			}
		},
		
		msgFulfilSignatureRequest({ value }: msgFulfilSignatureRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgFulfilSignatureRequest", value: MsgFulfilSignatureRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFulfilSignatureRequest: Could not create message: ' + e.message)
			}
		},
		
		msgNewZrSignSignatureRequest({ value }: msgNewZrSignSignatureRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewZrSignSignatureRequest", value: MsgNewZrSignSignatureRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewZrSignSignatureRequest: Could not create message: ' + e.message)
			}
		},
		
		queryKeyRequestsRequest({ value }: queryKeyRequestsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyRequestsRequest", value: QueryKeyRequestsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyRequestsRequest: Could not create message: ' + e.message)
			}
		},
		
		querySignatureRequestsRequest({ value }: querySignatureRequestsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignatureRequestsRequest", value: QuerySignatureRequestsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignatureRequestsRequest: Could not create message: ' + e.message)
			}
		},
		
		querySignatureRequestByIdrequest({ value }: querySignatureRequestByIdrequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignatureRequestByIDRequest", value: QuerySignatureRequestByIDRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignatureRequestByIDRequest: Could not create message: ' + e.message)
			}
		},
		
		querySignTransactionRequestsResponse({ value }: querySignTransactionRequestsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignTransactionRequestsResponse", value: QuerySignTransactionRequestsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignTransactionRequestsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgNewKeyRequest({ value }: msgNewKeyRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewKeyRequest", value: MsgNewKeyRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewKeyRequest: Could not create message: ' + e.message)
			}
		},
		
		msgFulfilKeyRequestResponse({ value }: msgFulfilKeyRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgFulfilKeyRequestResponse", value: MsgFulfilKeyRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFulfilKeyRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		msgTransferFromKeyringResponse({ value }: msgTransferFromKeyringResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgTransferFromKeyringResponse", value: MsgTransferFromKeyringResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgTransferFromKeyringResponse: Could not create message: ' + e.message)
			}
		},
		
		queryKeysRequest({ value }: queryKeysRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeysRequest", value: QueryKeysRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeysRequest: Could not create message: ' + e.message)
			}
		},
		
		signTransactionRequestsResponse({ value }: signTransactionRequestsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.SignTransactionRequestsResponse", value: SignTransactionRequestsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignTransactionRequestsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryZenbtcWalletsResponse({ value }: queryZenbtcWalletsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryZenbtcWalletsResponse", value: QueryZenbtcWalletsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryZenbtcWalletsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgNewIcatransactionRequestResponse({ value }: msgNewIcatransactionRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewICATransactionRequestResponse", value: MsgNewICATransactionRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewICATransactionRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		queryKeysResponse({ value }: queryKeysResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeysResponse", value: QueryKeysResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeysResponse: Could not create message: ' + e.message)
			}
		},
		
		querySignTransactionRequestsRequest({ value }: querySignTransactionRequestsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignTransactionRequestsRequest", value: QuerySignTransactionRequestsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignTransactionRequestsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryKeyByAddressRequest({ value }: queryKeyByAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyByAddressRequest", value: QueryKeyByAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyByAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryKeyByAddressResponse({ value }: queryKeyByAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryKeyByAddressResponse", value: QueryKeyByAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryKeyByAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		msgNewKey({ value }: msgNewKeyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewKey", value: MsgNewKey.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewKey: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateKeyPolicy({ value }: msgUpdateKeyPolicyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgUpdateKeyPolicy", value: MsgUpdateKeyPolicy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateKeyPolicy: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		querySignTransactionRequestByIdrequest({ value }: querySignTransactionRequestByIdrequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QuerySignTransactionRequestByIDRequest", value: QuerySignTransactionRequestByIDRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignTransactionRequestByIDRequest: Could not create message: ' + e.message)
			}
		},
		
		queryZrSignKeysRequest({ value }: queryZrSignKeysRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryZrSignKeysRequest", value: QueryZrSignKeysRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryZrSignKeysRequest: Could not create message: ' + e.message)
			}
		},
		
		msgNewKeyRequestResponse({ value }: msgNewKeyRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewKeyRequestResponse", value: MsgNewKeyRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewKeyRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		msgFulfilIcatransactionRequest({ value }: msgFulfilIcatransactionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgFulfilICATransactionRequest", value: MsgFulfilICATransactionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFulfilICATransactionRequest: Could not create message: ' + e.message)
			}
		},
		
		signTransactionRequest({ value }: signTransactionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.SignTransactionRequest", value: SignTransactionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignTransactionRequest: Could not create message: ' + e.message)
			}
		},
		
		signTxReqResponse({ value }: signTxReqResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.SignTxReqResponse", value: SignTxReqResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignTxReqResponse: Could not create message: ' + e.message)
			}
		},
		
		walletResponse({ value }: walletResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.WalletResponse", value: WalletResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:WalletResponse: Could not create message: ' + e.message)
			}
		},
		
		treasuryPacketData({ value }: treasuryPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.TreasuryPacketData", value: TreasuryPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:TreasuryPacketData: Could not create message: ' + e.message)
			}
		},
		
		msgNewSignTransactionRequest({ value }: msgNewSignTransactionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewSignTransactionRequest", value: MsgNewSignTransactionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewSignTransactionRequest: Could not create message: ' + e.message)
			}
		},
		
		msgFulfilIcatransactionRequestResponse({ value }: msgFulfilIcatransactionRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgFulfilICATransactionRequestResponse", value: MsgFulfilICATransactionRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFulfilICATransactionRequestResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateKeyPolicyResponse({ value }: msgUpdateKeyPolicyResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgUpdateKeyPolicyResponse", value: MsgUpdateKeyPolicyResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateKeyPolicyResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		zrSignKeyEntry({ value }: zrSignKeyEntryParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.ZrSignKeyEntry", value: ZrSignKeyEntry.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ZrSignKeyEntry: Could not create message: ' + e.message)
			}
		},
		
		zenBtcmetadata({ value }: zenBtcmetadataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.ZenBTCMetadata", value: ZenBTCMetadata.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ZenBTCMetadata: Could not create message: ' + e.message)
			}
		},
		
		msgNewZrSignSignatureRequestResponse({ value }: msgNewZrSignSignatureRequestResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.treasury.MsgNewZrSignSignatureRequestResponse", value: MsgNewZrSignSignatureRequestResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewZrSignSignatureRequestResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						PartySignature: getStructure(typePartySignature.fromPartial({})),
						KeyRequest: getStructure(typeKeyRequest.fromPartial({})),
						KeyReqResponse: getStructure(typeKeyReqResponse.fromPartial({})),
						Key: getStructure(typeKey.fromPartial({})),
						KeyResponse: getStructure(typeKeyResponse.fromPartial({})),
						ZenBTCMetadata: getStructure(typeZenBTCMetadata.fromPartial({})),
						SignRequest: getStructure(typeSignRequest.fromPartial({})),
						SignedDataWithID: getStructure(typeSignedDataWithID.fromPartial({})),
						SignTransactionRequest: getStructure(typeSignTransactionRequest.fromPartial({})),
						SignReqResponse: getStructure(typeSignReqResponse.fromPartial({})),
						SignTxReqResponse: getStructure(typeSignTxReqResponse.fromPartial({})),
						ICATransactionRequest: getStructure(typeICATransactionRequest.fromPartial({})),
						TreasuryPacketData: getStructure(typeTreasuryPacketData.fromPartial({})),
						NoData: getStructure(typeNoData.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						KeyAndWalletResponse: getStructure(typeKeyAndWalletResponse.fromPartial({})),
						WalletResponse: getStructure(typeWalletResponse.fromPartial({})),
						SignTransactionRequestsResponse: getStructure(typeSignTransactionRequestsResponse.fromPartial({})),
						ZrSignKeyEntry: getStructure(typeZrSignKeyEntry.fromPartial({})),
						MsgNewKey: getStructure(typeMsgNewKey.fromPartial({})),
						MetadataEthereum: getStructure(typeMetadataEthereum.fromPartial({})),
						MetadataSolana: getStructure(typeMetadataSolana.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			ZrchainTreasury: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;