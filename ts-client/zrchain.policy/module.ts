// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { BoolparserPolicy } from "./types/zrchain/policy/policy";
import { Action } from "./types/zrchain/policy/action";
import { MsgRemoveSignMethod } from "./types/zrchain/policy/tx";
import { NoData } from "./types/zrchain/policy/packet";
import { MsgRemoveMultiGrant } from "./types/zrchain/policy/tx";
import { QueryActionsRequest } from "./types/zrchain/policy/query";
import { QueryPoliciesRequest } from "./types/zrchain/policy/query";
import { QueryPoliciesResponse } from "./types/zrchain/policy/query";
import { MsgApproveAction } from "./types/zrchain/policy/tx";
import { KeyValue } from "./types/zrchain/policy/action";
import { ActionResponse } from "./types/zrchain/policy/action";
import { QueryParamsRequest } from "./types/zrchain/policy/query";
import { QuerySignMethodsByAddressResponse } from "./types/zrchain/policy/query";
import { QueryPoliciesByCreatorRequest } from "./types/zrchain/policy/query";
import { QueryPoliciesByCreatorResponse } from "./types/zrchain/policy/query";
import { GenesisState } from "./types/zrchain/policy/genesis";
import { MsgNewPolicy } from "./types/zrchain/policy/tx";
import { MsgUpdateParams } from "./types/zrchain/policy/tx";
import { QueryPolicyByIdRequest } from "./types/zrchain/policy/query";
import { QueryPolicyByIdResponse } from "./types/zrchain/policy/query";
import { QuerySignMethodsByAddressRequest } from "./types/zrchain/policy/query";
import { MsgRemoveSignMethodResponse } from "./types/zrchain/policy/tx";
import { MsgAddMultiGrantResponse } from "./types/zrchain/policy/tx";
import { MsgUpdateParamsResponse } from "./types/zrchain/policy/tx";
import { MsgNewPolicyResponse } from "./types/zrchain/policy/tx";
import { MsgRevokeActionResponse } from "./types/zrchain/policy/tx";
import { QueryActionDetailsByIdResponse } from "./types/zrchain/policy/query";
import { MsgRevokeAction } from "./types/zrchain/policy/tx";
import { MsgApproveActionResponse } from "./types/zrchain/policy/tx";
import { MsgAddSignMethodResponse } from "./types/zrchain/policy/tx";
import { PolicyResponse } from "./types/zrchain/policy/query";
import { QueryActionDetailsByIdRequest } from "./types/zrchain/policy/query";
import { PolicyPacketData } from "./types/zrchain/policy/packet";
import { MsgRemoveMultiGrantResponse } from "./types/zrchain/policy/tx";
import { SignMethodPasskey } from "./types/zrchain/policy/sign_method_passkey";
import { MsgAddMultiGrant } from "./types/zrchain/policy/tx";
import { QueryParamsResponse } from "./types/zrchain/policy/query";
import { AdditionalSignaturePasskey } from "./types/zrchain/policy/additional_signature_passkey";
import { MsgAddSignMethod } from "./types/zrchain/policy/tx";
import { Policy } from "./types/zrchain/policy/policy";
import { PolicyParticipant } from "./types/zrchain/policy/policy";
import { Params } from "./types/zrchain/policy/params";
import { GenesisSignMethod } from "./types/zrchain/policy/genesis";
import { QueryActionsResponse } from "./types/zrchain/policy/query";

import { Action as typeAction} from "./types"
import { KeyValue as typeKeyValue} from "./types"
import { ActionResponse as typeActionResponse} from "./types"
import { AdditionalSignaturePasskey as typeAdditionalSignaturePasskey} from "./types"
import { GenesisSignMethod as typeGenesisSignMethod} from "./types"
import { PolicyPacketData as typePolicyPacketData} from "./types"
import { NoData as typeNoData} from "./types"
import { Params as typeParams} from "./types"
import { Policy as typePolicy} from "./types"
import { BoolparserPolicy as typeBoolparserPolicy} from "./types"
import { PolicyParticipant as typePolicyParticipant} from "./types"
import { PolicyResponse as typePolicyResponse} from "./types"
import { SignMethodPasskey as typeSignMethodPasskey} from "./types"

export { BoolparserPolicy, Action, MsgRemoveSignMethod, NoData, MsgRemoveMultiGrant, QueryActionsRequest, QueryPoliciesRequest, QueryPoliciesResponse, MsgApproveAction, KeyValue, ActionResponse, QueryParamsRequest, QuerySignMethodsByAddressResponse, QueryPoliciesByCreatorRequest, QueryPoliciesByCreatorResponse, GenesisState, MsgNewPolicy, MsgUpdateParams, QueryPolicyByIdRequest, QueryPolicyByIdResponse, QuerySignMethodsByAddressRequest, MsgRemoveSignMethodResponse, MsgAddMultiGrantResponse, MsgUpdateParamsResponse, MsgNewPolicyResponse, MsgRevokeActionResponse, QueryActionDetailsByIdResponse, MsgRevokeAction, MsgApproveActionResponse, MsgAddSignMethodResponse, PolicyResponse, QueryActionDetailsByIdRequest, PolicyPacketData, MsgRemoveMultiGrantResponse, SignMethodPasskey, MsgAddMultiGrant, QueryParamsResponse, AdditionalSignaturePasskey, MsgAddSignMethod, Policy, PolicyParticipant, Params, GenesisSignMethod, QueryActionsResponse };

type sendBoolparserPolicyParams = {
  value: BoolparserPolicy,
  fee?: StdFee,
  memo?: string
};

type sendActionParams = {
  value: Action,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveSignMethodParams = {
  value: MsgRemoveSignMethod,
  fee?: StdFee,
  memo?: string
};

type sendNoDataParams = {
  value: NoData,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveMultiGrantParams = {
  value: MsgRemoveMultiGrant,
  fee?: StdFee,
  memo?: string
};

type sendQueryActionsRequestParams = {
  value: QueryActionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoliciesRequestParams = {
  value: QueryPoliciesRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoliciesResponseParams = {
  value: QueryPoliciesResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgApproveActionParams = {
  value: MsgApproveAction,
  fee?: StdFee,
  memo?: string
};

type sendKeyValueParams = {
  value: KeyValue,
  fee?: StdFee,
  memo?: string
};

type sendActionResponseParams = {
  value: ActionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignMethodsByAddressResponseParams = {
  value: QuerySignMethodsByAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoliciesByCreatorRequestParams = {
  value: QueryPoliciesByCreatorRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPoliciesByCreatorResponseParams = {
  value: QueryPoliciesByCreatorResponse,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewPolicyParams = {
  value: MsgNewPolicy,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendQueryPolicyByIdRequestParams = {
  value: QueryPolicyByIdRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPolicyByIdResponseParams = {
  value: QueryPolicyByIdResponse,
  fee?: StdFee,
  memo?: string
};

type sendQuerySignMethodsByAddressRequestParams = {
  value: QuerySignMethodsByAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveSignMethodResponseParams = {
  value: MsgRemoveSignMethodResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddMultiGrantResponseParams = {
  value: MsgAddMultiGrantResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgNewPolicyResponseParams = {
  value: MsgNewPolicyResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgRevokeActionResponseParams = {
  value: MsgRevokeActionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryActionDetailsByIdResponseParams = {
  value: QueryActionDetailsByIdResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgRevokeActionParams = {
  value: MsgRevokeAction,
  fee?: StdFee,
  memo?: string
};

type sendMsgApproveActionResponseParams = {
  value: MsgApproveActionResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddSignMethodResponseParams = {
  value: MsgAddSignMethodResponse,
  fee?: StdFee,
  memo?: string
};

type sendPolicyResponseParams = {
  value: PolicyResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryActionDetailsByIdRequestParams = {
  value: QueryActionDetailsByIdRequest,
  fee?: StdFee,
  memo?: string
};

type sendPolicyPacketDataParams = {
  value: PolicyPacketData,
  fee?: StdFee,
  memo?: string
};

type sendMsgRemoveMultiGrantResponseParams = {
  value: MsgRemoveMultiGrantResponse,
  fee?: StdFee,
  memo?: string
};

type sendSignMethodPasskeyParams = {
  value: SignMethodPasskey,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddMultiGrantParams = {
  value: MsgAddMultiGrant,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendAdditionalSignaturePasskeyParams = {
  value: AdditionalSignaturePasskey,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddSignMethodParams = {
  value: MsgAddSignMethod,
  fee?: StdFee,
  memo?: string
};

type sendPolicyParams = {
  value: Policy,
  fee?: StdFee,
  memo?: string
};

type sendPolicyParticipantParams = {
  value: PolicyParticipant,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendGenesisSignMethodParams = {
  value: GenesisSignMethod,
  fee?: StdFee,
  memo?: string
};

type sendQueryActionsResponseParams = {
  value: QueryActionsResponse,
  fee?: StdFee,
  memo?: string
};


type boolparserPolicyParams = {
  value: BoolparserPolicy,
};

type actionParams = {
  value: Action,
};

type msgRemoveSignMethodParams = {
  value: MsgRemoveSignMethod,
};

type noDataParams = {
  value: NoData,
};

type msgRemoveMultiGrantParams = {
  value: MsgRemoveMultiGrant,
};

type queryActionsRequestParams = {
  value: QueryActionsRequest,
};

type queryPoliciesRequestParams = {
  value: QueryPoliciesRequest,
};

type queryPoliciesResponseParams = {
  value: QueryPoliciesResponse,
};

type msgApproveActionParams = {
  value: MsgApproveAction,
};

type keyValueParams = {
  value: KeyValue,
};

type actionResponseParams = {
  value: ActionResponse,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type querySignMethodsByAddressResponseParams = {
  value: QuerySignMethodsByAddressResponse,
};

type queryPoliciesByCreatorRequestParams = {
  value: QueryPoliciesByCreatorRequest,
};

type queryPoliciesByCreatorResponseParams = {
  value: QueryPoliciesByCreatorResponse,
};

type genesisStateParams = {
  value: GenesisState,
};

type msgNewPolicyParams = {
  value: MsgNewPolicy,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type queryPolicyByIdRequestParams = {
  value: QueryPolicyByIdRequest,
};

type queryPolicyByIdResponseParams = {
  value: QueryPolicyByIdResponse,
};

type querySignMethodsByAddressRequestParams = {
  value: QuerySignMethodsByAddressRequest,
};

type msgRemoveSignMethodResponseParams = {
  value: MsgRemoveSignMethodResponse,
};

type msgAddMultiGrantResponseParams = {
  value: MsgAddMultiGrantResponse,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgNewPolicyResponseParams = {
  value: MsgNewPolicyResponse,
};

type msgRevokeActionResponseParams = {
  value: MsgRevokeActionResponse,
};

type queryActionDetailsByIdResponseParams = {
  value: QueryActionDetailsByIdResponse,
};

type msgRevokeActionParams = {
  value: MsgRevokeAction,
};

type msgApproveActionResponseParams = {
  value: MsgApproveActionResponse,
};

type msgAddSignMethodResponseParams = {
  value: MsgAddSignMethodResponse,
};

type policyResponseParams = {
  value: PolicyResponse,
};

type queryActionDetailsByIdRequestParams = {
  value: QueryActionDetailsByIdRequest,
};

type policyPacketDataParams = {
  value: PolicyPacketData,
};

type msgRemoveMultiGrantResponseParams = {
  value: MsgRemoveMultiGrantResponse,
};

type signMethodPasskeyParams = {
  value: SignMethodPasskey,
};

type msgAddMultiGrantParams = {
  value: MsgAddMultiGrant,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type additionalSignaturePasskeyParams = {
  value: AdditionalSignaturePasskey,
};

type msgAddSignMethodParams = {
  value: MsgAddSignMethod,
};

type policyParams = {
  value: Policy,
};

type policyParticipantParams = {
  value: PolicyParticipant,
};

type paramsParams = {
  value: Params,
};

type genesisSignMethodParams = {
  value: GenesisSignMethod,
};

type queryActionsResponseParams = {
  value: QueryActionsResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendBoolparserPolicy({ value, fee, memo }: sendBoolparserPolicyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendBoolparserPolicy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.boolparserPolicy({ value: BoolparserPolicy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendBoolparserPolicy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAction({ value, fee, memo }: sendActionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAction: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.action({ value: Action.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAction: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveSignMethod({ value, fee, memo }: sendMsgRemoveSignMethodParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveSignMethod: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgRemoveSignMethod({ value: MsgRemoveSignMethod.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveSignMethod: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendNoData({ value, fee, memo }: sendNoDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendNoData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.noData({ value: NoData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendNoData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveMultiGrant({ value, fee, memo }: sendMsgRemoveMultiGrantParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveMultiGrant: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgRemoveMultiGrant({ value: MsgRemoveMultiGrant.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveMultiGrant: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryActionsRequest({ value, fee, memo }: sendQueryActionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryActionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryActionsRequest({ value: QueryActionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryActionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoliciesRequest({ value, fee, memo }: sendQueryPoliciesRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoliciesRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoliciesRequest({ value: QueryPoliciesRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoliciesRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoliciesResponse({ value, fee, memo }: sendQueryPoliciesResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoliciesResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoliciesResponse({ value: QueryPoliciesResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoliciesResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgApproveAction({ value, fee, memo }: sendMsgApproveActionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgApproveAction: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgApproveAction({ value: MsgApproveAction.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgApproveAction: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendKeyValue({ value, fee, memo }: sendKeyValueParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendKeyValue: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.keyValue({ value: KeyValue.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendKeyValue: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendActionResponse({ value, fee, memo }: sendActionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendActionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.actionResponse({ value: ActionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendActionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignMethodsByAddressResponse({ value, fee, memo }: sendQuerySignMethodsByAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignMethodsByAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignMethodsByAddressResponse({ value: QuerySignMethodsByAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignMethodsByAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoliciesByCreatorRequest({ value, fee, memo }: sendQueryPoliciesByCreatorRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoliciesByCreatorRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoliciesByCreatorRequest({ value: QueryPoliciesByCreatorRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoliciesByCreatorRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPoliciesByCreatorResponse({ value, fee, memo }: sendQueryPoliciesByCreatorResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPoliciesByCreatorResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPoliciesByCreatorResponse({ value: QueryPoliciesByCreatorResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPoliciesByCreatorResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewPolicy({ value, fee, memo }: sendMsgNewPolicyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewPolicy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewPolicy({ value: MsgNewPolicy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewPolicy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPolicyByIdRequest({ value, fee, memo }: sendQueryPolicyByIdRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPolicyByIdRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPolicyByIdRequest({ value: QueryPolicyByIdRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPolicyByIdRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPolicyByIdResponse({ value, fee, memo }: sendQueryPolicyByIdResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPolicyByIdResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPolicyByIdResponse({ value: QueryPolicyByIdResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPolicyByIdResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySignMethodsByAddressRequest({ value, fee, memo }: sendQuerySignMethodsByAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySignMethodsByAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySignMethodsByAddressRequest({ value: QuerySignMethodsByAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySignMethodsByAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveSignMethodResponse({ value, fee, memo }: sendMsgRemoveSignMethodResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveSignMethodResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgRemoveSignMethodResponse({ value: MsgRemoveSignMethodResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveSignMethodResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddMultiGrantResponse({ value, fee, memo }: sendMsgAddMultiGrantResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddMultiGrantResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddMultiGrantResponse({ value: MsgAddMultiGrantResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddMultiGrantResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgNewPolicyResponse({ value, fee, memo }: sendMsgNewPolicyResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgNewPolicyResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgNewPolicyResponse({ value: MsgNewPolicyResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgNewPolicyResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRevokeActionResponse({ value, fee, memo }: sendMsgRevokeActionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRevokeActionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgRevokeActionResponse({ value: MsgRevokeActionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRevokeActionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryActionDetailsByIdResponse({ value, fee, memo }: sendQueryActionDetailsByIdResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryActionDetailsByIdResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryActionDetailsByIdResponse({ value: QueryActionDetailsByIdResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryActionDetailsByIdResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRevokeAction({ value, fee, memo }: sendMsgRevokeActionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRevokeAction: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgRevokeAction({ value: MsgRevokeAction.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRevokeAction: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgApproveActionResponse({ value, fee, memo }: sendMsgApproveActionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgApproveActionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgApproveActionResponse({ value: MsgApproveActionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgApproveActionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddSignMethodResponse({ value, fee, memo }: sendMsgAddSignMethodResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddSignMethodResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddSignMethodResponse({ value: MsgAddSignMethodResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddSignMethodResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPolicyResponse({ value, fee, memo }: sendPolicyResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPolicyResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.policyResponse({ value: PolicyResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPolicyResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryActionDetailsByIdRequest({ value, fee, memo }: sendQueryActionDetailsByIdRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryActionDetailsByIdRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryActionDetailsByIdRequest({ value: QueryActionDetailsByIdRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryActionDetailsByIdRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPolicyPacketData({ value, fee, memo }: sendPolicyPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPolicyPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.policyPacketData({ value: PolicyPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPolicyPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgRemoveMultiGrantResponse({ value, fee, memo }: sendMsgRemoveMultiGrantResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgRemoveMultiGrantResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgRemoveMultiGrantResponse({ value: MsgRemoveMultiGrantResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgRemoveMultiGrantResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSignMethodPasskey({ value, fee, memo }: sendSignMethodPasskeyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSignMethodPasskey: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.signMethodPasskey({ value: SignMethodPasskey.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSignMethodPasskey: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddMultiGrant({ value, fee, memo }: sendMsgAddMultiGrantParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddMultiGrant: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddMultiGrant({ value: MsgAddMultiGrant.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddMultiGrant: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAdditionalSignaturePasskey({ value, fee, memo }: sendAdditionalSignaturePasskeyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAdditionalSignaturePasskey: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.additionalSignaturePasskey({ value: AdditionalSignaturePasskey.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAdditionalSignaturePasskey: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddSignMethod({ value, fee, memo }: sendMsgAddSignMethodParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddSignMethod: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddSignMethod({ value: MsgAddSignMethod.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddSignMethod: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPolicy({ value, fee, memo }: sendPolicyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPolicy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.policy({ value: Policy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPolicy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPolicyParticipant({ value, fee, memo }: sendPolicyParticipantParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPolicyParticipant: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.policyParticipant({ value: PolicyParticipant.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPolicyParticipant: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisSignMethod({ value, fee, memo }: sendGenesisSignMethodParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisSignMethod: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisSignMethod({ value: GenesisSignMethod.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisSignMethod: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryActionsResponse({ value, fee, memo }: sendQueryActionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryActionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryActionsResponse({ value: QueryActionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryActionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		boolparserPolicy({ value }: boolparserPolicyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.BoolparserPolicy", value: BoolparserPolicy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:BoolparserPolicy: Could not create message: ' + e.message)
			}
		},
		
		action({ value }: actionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.Action", value: Action.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Action: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveSignMethod({ value }: msgRemoveSignMethodParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgRemoveSignMethod", value: MsgRemoveSignMethod.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveSignMethod: Could not create message: ' + e.message)
			}
		},
		
		noData({ value }: noDataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.NoData", value: NoData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:NoData: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveMultiGrant({ value }: msgRemoveMultiGrantParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgRemoveMultiGrant", value: MsgRemoveMultiGrant.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveMultiGrant: Could not create message: ' + e.message)
			}
		},
		
		queryActionsRequest({ value }: queryActionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryActionsRequest", value: QueryActionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryActionsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPoliciesRequest({ value }: queryPoliciesRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryPoliciesRequest", value: QueryPoliciesRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoliciesRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPoliciesResponse({ value }: queryPoliciesResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryPoliciesResponse", value: QueryPoliciesResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoliciesResponse: Could not create message: ' + e.message)
			}
		},
		
		msgApproveAction({ value }: msgApproveActionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgApproveAction", value: MsgApproveAction.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgApproveAction: Could not create message: ' + e.message)
			}
		},
		
		keyValue({ value }: keyValueParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.KeyValue", value: KeyValue.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:KeyValue: Could not create message: ' + e.message)
			}
		},
		
		actionResponse({ value }: actionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.ActionResponse", value: ActionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:ActionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		querySignMethodsByAddressResponse({ value }: querySignMethodsByAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QuerySignMethodsByAddressResponse", value: QuerySignMethodsByAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignMethodsByAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		queryPoliciesByCreatorRequest({ value }: queryPoliciesByCreatorRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryPoliciesByCreatorRequest", value: QueryPoliciesByCreatorRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoliciesByCreatorRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPoliciesByCreatorResponse({ value }: queryPoliciesByCreatorResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryPoliciesByCreatorResponse", value: QueryPoliciesByCreatorResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPoliciesByCreatorResponse: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		msgNewPolicy({ value }: msgNewPolicyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgNewPolicy", value: MsgNewPolicy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewPolicy: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		queryPolicyByIdRequest({ value }: queryPolicyByIdRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryPolicyByIdRequest", value: QueryPolicyByIdRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPolicyByIdRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPolicyByIdResponse({ value }: queryPolicyByIdResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryPolicyByIdResponse", value: QueryPolicyByIdResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPolicyByIdResponse: Could not create message: ' + e.message)
			}
		},
		
		querySignMethodsByAddressRequest({ value }: querySignMethodsByAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QuerySignMethodsByAddressRequest", value: QuerySignMethodsByAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySignMethodsByAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveSignMethodResponse({ value }: msgRemoveSignMethodResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgRemoveSignMethodResponse", value: MsgRemoveSignMethodResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveSignMethodResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAddMultiGrantResponse({ value }: msgAddMultiGrantResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgAddMultiGrantResponse", value: MsgAddMultiGrantResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddMultiGrantResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgNewPolicyResponse({ value }: msgNewPolicyResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgNewPolicyResponse", value: MsgNewPolicyResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgNewPolicyResponse: Could not create message: ' + e.message)
			}
		},
		
		msgRevokeActionResponse({ value }: msgRevokeActionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgRevokeActionResponse", value: MsgRevokeActionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRevokeActionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryActionDetailsByIdResponse({ value }: queryActionDetailsByIdResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryActionDetailsByIdResponse", value: QueryActionDetailsByIdResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryActionDetailsByIdResponse: Could not create message: ' + e.message)
			}
		},
		
		msgRevokeAction({ value }: msgRevokeActionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgRevokeAction", value: MsgRevokeAction.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRevokeAction: Could not create message: ' + e.message)
			}
		},
		
		msgApproveActionResponse({ value }: msgApproveActionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgApproveActionResponse", value: MsgApproveActionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgApproveActionResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAddSignMethodResponse({ value }: msgAddSignMethodResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgAddSignMethodResponse", value: MsgAddSignMethodResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddSignMethodResponse: Could not create message: ' + e.message)
			}
		},
		
		policyResponse({ value }: policyResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.PolicyResponse", value: PolicyResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PolicyResponse: Could not create message: ' + e.message)
			}
		},
		
		queryActionDetailsByIdRequest({ value }: queryActionDetailsByIdRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryActionDetailsByIdRequest", value: QueryActionDetailsByIdRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryActionDetailsByIdRequest: Could not create message: ' + e.message)
			}
		},
		
		policyPacketData({ value }: policyPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.PolicyPacketData", value: PolicyPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PolicyPacketData: Could not create message: ' + e.message)
			}
		},
		
		msgRemoveMultiGrantResponse({ value }: msgRemoveMultiGrantResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgRemoveMultiGrantResponse", value: MsgRemoveMultiGrantResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgRemoveMultiGrantResponse: Could not create message: ' + e.message)
			}
		},
		
		signMethodPasskey({ value }: signMethodPasskeyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.SignMethodPasskey", value: SignMethodPasskey.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:SignMethodPasskey: Could not create message: ' + e.message)
			}
		},
		
		msgAddMultiGrant({ value }: msgAddMultiGrantParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgAddMultiGrant", value: MsgAddMultiGrant.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddMultiGrant: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		additionalSignaturePasskey({ value }: additionalSignaturePasskeyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.AdditionalSignaturePasskey", value: AdditionalSignaturePasskey.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AdditionalSignaturePasskey: Could not create message: ' + e.message)
			}
		},
		
		msgAddSignMethod({ value }: msgAddSignMethodParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.MsgAddSignMethod", value: MsgAddSignMethod.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddSignMethod: Could not create message: ' + e.message)
			}
		},
		
		policy({ value }: policyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.Policy", value: Policy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Policy: Could not create message: ' + e.message)
			}
		},
		
		policyParticipant({ value }: policyParticipantParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.PolicyParticipant", value: PolicyParticipant.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PolicyParticipant: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		genesisSignMethod({ value }: genesisSignMethodParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.GenesisSignMethod", value: GenesisSignMethod.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisSignMethod: Could not create message: ' + e.message)
			}
		},
		
		queryActionsResponse({ value }: queryActionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.policy.QueryActionsResponse", value: QueryActionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryActionsResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						Action: getStructure(typeAction.fromPartial({})),
						KeyValue: getStructure(typeKeyValue.fromPartial({})),
						ActionResponse: getStructure(typeActionResponse.fromPartial({})),
						AdditionalSignaturePasskey: getStructure(typeAdditionalSignaturePasskey.fromPartial({})),
						GenesisSignMethod: getStructure(typeGenesisSignMethod.fromPartial({})),
						PolicyPacketData: getStructure(typePolicyPacketData.fromPartial({})),
						NoData: getStructure(typeNoData.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						Policy: getStructure(typePolicy.fromPartial({})),
						BoolparserPolicy: getStructure(typeBoolparserPolicy.fromPartial({})),
						PolicyParticipant: getStructure(typePolicyParticipant.fromPartial({})),
						PolicyResponse: getStructure(typePolicyResponse.fromPartial({})),
						SignMethodPasskey: getStructure(typeSignMethodPasskey.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			ZrchainPolicy: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;