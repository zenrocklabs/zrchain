// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: zrchain/zenbtc/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  LockTransaction,
  MintTransactionStatus,
  mintTransactionStatusFromJSON,
  mintTransactionStatusToJSON,
  PendingMintTransaction,
} from "./mint";
import { Params } from "./params";
import {
  BurnEvent,
  BurnStatus,
  burnStatusFromJSON,
  burnStatusToJSON,
  Redemption,
  RedemptionStatus,
  redemptionStatusFromJSON,
  redemptionStatusToJSON,
} from "./redemptions";

export const protobufPackage = "zrchain.zenbtc";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

export interface QueryLockTransactionsRequest {
}

export interface QueryLockTransactionsResponse {
  lockTransactions: LockTransaction[];
}

export interface QueryRedemptionsRequest {
  startIndex: number;
  status: RedemptionStatus;
}

export interface QueryRedemptionsResponse {
  redemptions: Redemption[];
}

export interface QueryPendingMintTransactionsRequest {
  startIndex: number;
  status: MintTransactionStatus;
}

export interface QueryPendingMintTransactionsResponse {
  pendingMintTransactions: PendingMintTransaction[];
}

export interface QueryPendingMintTransactionRequest {
  txHash: string;
}

export interface QueryPendingMintTransactionResponse {
  pendingMintTransaction: PendingMintTransaction | undefined;
}

export interface QuerySupplyRequest {
}

export interface QuerySupplyResponse {
  custodiedBTC: number;
  totalZenBTC: number;
  mintedZenBTC: number;
  pendingZenBTC: number;
  exchangeRate: string;
}

export interface QueryBurnEventsRequest {
  startIndex: number;
  txID: string;
  logIndex: number;
  chainID: string;
  status: BurnStatus;
}

export interface QueryBurnEventsResponse {
  burnEvents: BurnEvent[];
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryLockTransactionsRequest(): QueryLockTransactionsRequest {
  return {};
}

export const QueryLockTransactionsRequest: MessageFns<QueryLockTransactionsRequest> = {
  encode(_: QueryLockTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLockTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLockTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryLockTransactionsRequest {
    return {};
  },

  toJSON(_: QueryLockTransactionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLockTransactionsRequest>, I>>(base?: I): QueryLockTransactionsRequest {
    return QueryLockTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLockTransactionsRequest>, I>>(_: I): QueryLockTransactionsRequest {
    const message = createBaseQueryLockTransactionsRequest();
    return message;
  },
};

function createBaseQueryLockTransactionsResponse(): QueryLockTransactionsResponse {
  return { lockTransactions: [] };
}

export const QueryLockTransactionsResponse: MessageFns<QueryLockTransactionsResponse> = {
  encode(message: QueryLockTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lockTransactions) {
      LockTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLockTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLockTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lockTransactions.push(LockTransaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLockTransactionsResponse {
    return {
      lockTransactions: globalThis.Array.isArray(object?.lockTransactions)
        ? object.lockTransactions.map((e: any) => LockTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryLockTransactionsResponse): unknown {
    const obj: any = {};
    if (message.lockTransactions?.length) {
      obj.lockTransactions = message.lockTransactions.map((e) => LockTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLockTransactionsResponse>, I>>(base?: I): QueryLockTransactionsResponse {
    return QueryLockTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLockTransactionsResponse>, I>>(
    object: I,
  ): QueryLockTransactionsResponse {
    const message = createBaseQueryLockTransactionsResponse();
    message.lockTransactions = object.lockTransactions?.map((e) => LockTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryRedemptionsRequest(): QueryRedemptionsRequest {
  return { startIndex: 0, status: 0 };
}

export const QueryRedemptionsRequest: MessageFns<QueryRedemptionsRequest> = {
  encode(message: QueryRedemptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== 0) {
      writer.uint32(8).uint64(message.startIndex);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRedemptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRedemptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startIndex = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRedemptionsRequest {
    return {
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      status: isSet(object.status) ? redemptionStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: QueryRedemptionsRequest): unknown {
    const obj: any = {};
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.status !== 0) {
      obj.status = redemptionStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRedemptionsRequest>, I>>(base?: I): QueryRedemptionsRequest {
    return QueryRedemptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRedemptionsRequest>, I>>(object: I): QueryRedemptionsRequest {
    const message = createBaseQueryRedemptionsRequest();
    message.startIndex = object.startIndex ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseQueryRedemptionsResponse(): QueryRedemptionsResponse {
  return { redemptions: [] };
}

export const QueryRedemptionsResponse: MessageFns<QueryRedemptionsResponse> = {
  encode(message: QueryRedemptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.redemptions) {
      Redemption.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryRedemptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryRedemptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.redemptions.push(Redemption.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryRedemptionsResponse {
    return {
      redemptions: globalThis.Array.isArray(object?.redemptions)
        ? object.redemptions.map((e: any) => Redemption.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryRedemptionsResponse): unknown {
    const obj: any = {};
    if (message.redemptions?.length) {
      obj.redemptions = message.redemptions.map((e) => Redemption.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryRedemptionsResponse>, I>>(base?: I): QueryRedemptionsResponse {
    return QueryRedemptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryRedemptionsResponse>, I>>(object: I): QueryRedemptionsResponse {
    const message = createBaseQueryRedemptionsResponse();
    message.redemptions = object.redemptions?.map((e) => Redemption.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPendingMintTransactionsRequest(): QueryPendingMintTransactionsRequest {
  return { startIndex: 0, status: 0 };
}

export const QueryPendingMintTransactionsRequest: MessageFns<QueryPendingMintTransactionsRequest> = {
  encode(message: QueryPendingMintTransactionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== 0) {
      writer.uint32(8).uint64(message.startIndex);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingMintTransactionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingMintTransactionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startIndex = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingMintTransactionsRequest {
    return {
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      status: isSet(object.status) ? mintTransactionStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: QueryPendingMintTransactionsRequest): unknown {
    const obj: any = {};
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.status !== 0) {
      obj.status = mintTransactionStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPendingMintTransactionsRequest>, I>>(
    base?: I,
  ): QueryPendingMintTransactionsRequest {
    return QueryPendingMintTransactionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPendingMintTransactionsRequest>, I>>(
    object: I,
  ): QueryPendingMintTransactionsRequest {
    const message = createBaseQueryPendingMintTransactionsRequest();
    message.startIndex = object.startIndex ?? 0;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseQueryPendingMintTransactionsResponse(): QueryPendingMintTransactionsResponse {
  return { pendingMintTransactions: [] };
}

export const QueryPendingMintTransactionsResponse: MessageFns<QueryPendingMintTransactionsResponse> = {
  encode(message: QueryPendingMintTransactionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pendingMintTransactions) {
      PendingMintTransaction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingMintTransactionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingMintTransactionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingMintTransactions.push(PendingMintTransaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingMintTransactionsResponse {
    return {
      pendingMintTransactions: globalThis.Array.isArray(object?.pendingMintTransactions)
        ? object.pendingMintTransactions.map((e: any) => PendingMintTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryPendingMintTransactionsResponse): unknown {
    const obj: any = {};
    if (message.pendingMintTransactions?.length) {
      obj.pendingMintTransactions = message.pendingMintTransactions.map((e) => PendingMintTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPendingMintTransactionsResponse>, I>>(
    base?: I,
  ): QueryPendingMintTransactionsResponse {
    return QueryPendingMintTransactionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPendingMintTransactionsResponse>, I>>(
    object: I,
  ): QueryPendingMintTransactionsResponse {
    const message = createBaseQueryPendingMintTransactionsResponse();
    message.pendingMintTransactions =
      object.pendingMintTransactions?.map((e) => PendingMintTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryPendingMintTransactionRequest(): QueryPendingMintTransactionRequest {
  return { txHash: "" };
}

export const QueryPendingMintTransactionRequest: MessageFns<QueryPendingMintTransactionRequest> = {
  encode(message: QueryPendingMintTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.txHash !== "") {
      writer.uint32(10).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingMintTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingMintTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingMintTransactionRequest {
    return { txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "" };
  },

  toJSON(message: QueryPendingMintTransactionRequest): unknown {
    const obj: any = {};
    if (message.txHash !== "") {
      obj.txHash = message.txHash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPendingMintTransactionRequest>, I>>(
    base?: I,
  ): QueryPendingMintTransactionRequest {
    return QueryPendingMintTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPendingMintTransactionRequest>, I>>(
    object: I,
  ): QueryPendingMintTransactionRequest {
    const message = createBaseQueryPendingMintTransactionRequest();
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseQueryPendingMintTransactionResponse(): QueryPendingMintTransactionResponse {
  return { pendingMintTransaction: undefined };
}

export const QueryPendingMintTransactionResponse: MessageFns<QueryPendingMintTransactionResponse> = {
  encode(message: QueryPendingMintTransactionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pendingMintTransaction !== undefined) {
      PendingMintTransaction.encode(message.pendingMintTransaction, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPendingMintTransactionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPendingMintTransactionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pendingMintTransaction = PendingMintTransaction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPendingMintTransactionResponse {
    return {
      pendingMintTransaction: isSet(object.pendingMintTransaction)
        ? PendingMintTransaction.fromJSON(object.pendingMintTransaction)
        : undefined,
    };
  },

  toJSON(message: QueryPendingMintTransactionResponse): unknown {
    const obj: any = {};
    if (message.pendingMintTransaction !== undefined) {
      obj.pendingMintTransaction = PendingMintTransaction.toJSON(message.pendingMintTransaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryPendingMintTransactionResponse>, I>>(
    base?: I,
  ): QueryPendingMintTransactionResponse {
    return QueryPendingMintTransactionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryPendingMintTransactionResponse>, I>>(
    object: I,
  ): QueryPendingMintTransactionResponse {
    const message = createBaseQueryPendingMintTransactionResponse();
    message.pendingMintTransaction =
      (object.pendingMintTransaction !== undefined && object.pendingMintTransaction !== null)
        ? PendingMintTransaction.fromPartial(object.pendingMintTransaction)
        : undefined;
    return message;
  },
};

function createBaseQuerySupplyRequest(): QuerySupplyRequest {
  return {};
}

export const QuerySupplyRequest: MessageFns<QuerySupplyRequest> = {
  encode(_: QuerySupplyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySupplyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySupplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QuerySupplyRequest {
    return {};
  },

  toJSON(_: QuerySupplyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySupplyRequest>, I>>(base?: I): QuerySupplyRequest {
    return QuerySupplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySupplyRequest>, I>>(_: I): QuerySupplyRequest {
    const message = createBaseQuerySupplyRequest();
    return message;
  },
};

function createBaseQuerySupplyResponse(): QuerySupplyResponse {
  return { custodiedBTC: 0, totalZenBTC: 0, mintedZenBTC: 0, pendingZenBTC: 0, exchangeRate: "" };
}

export const QuerySupplyResponse: MessageFns<QuerySupplyResponse> = {
  encode(message: QuerySupplyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.custodiedBTC !== 0) {
      writer.uint32(8).uint64(message.custodiedBTC);
    }
    if (message.totalZenBTC !== 0) {
      writer.uint32(16).uint64(message.totalZenBTC);
    }
    if (message.mintedZenBTC !== 0) {
      writer.uint32(24).uint64(message.mintedZenBTC);
    }
    if (message.pendingZenBTC !== 0) {
      writer.uint32(32).uint64(message.pendingZenBTC);
    }
    if (message.exchangeRate !== "") {
      writer.uint32(42).string(message.exchangeRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySupplyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySupplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.custodiedBTC = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalZenBTC = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mintedZenBTC = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.pendingZenBTC = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.exchangeRate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySupplyResponse {
    return {
      custodiedBTC: isSet(object.custodiedBTC) ? globalThis.Number(object.custodiedBTC) : 0,
      totalZenBTC: isSet(object.totalZenBTC) ? globalThis.Number(object.totalZenBTC) : 0,
      mintedZenBTC: isSet(object.mintedZenBTC) ? globalThis.Number(object.mintedZenBTC) : 0,
      pendingZenBTC: isSet(object.pendingZenBTC) ? globalThis.Number(object.pendingZenBTC) : 0,
      exchangeRate: isSet(object.exchangeRate) ? globalThis.String(object.exchangeRate) : "",
    };
  },

  toJSON(message: QuerySupplyResponse): unknown {
    const obj: any = {};
    if (message.custodiedBTC !== 0) {
      obj.custodiedBTC = Math.round(message.custodiedBTC);
    }
    if (message.totalZenBTC !== 0) {
      obj.totalZenBTC = Math.round(message.totalZenBTC);
    }
    if (message.mintedZenBTC !== 0) {
      obj.mintedZenBTC = Math.round(message.mintedZenBTC);
    }
    if (message.pendingZenBTC !== 0) {
      obj.pendingZenBTC = Math.round(message.pendingZenBTC);
    }
    if (message.exchangeRate !== "") {
      obj.exchangeRate = message.exchangeRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySupplyResponse>, I>>(base?: I): QuerySupplyResponse {
    return QuerySupplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySupplyResponse>, I>>(object: I): QuerySupplyResponse {
    const message = createBaseQuerySupplyResponse();
    message.custodiedBTC = object.custodiedBTC ?? 0;
    message.totalZenBTC = object.totalZenBTC ?? 0;
    message.mintedZenBTC = object.mintedZenBTC ?? 0;
    message.pendingZenBTC = object.pendingZenBTC ?? 0;
    message.exchangeRate = object.exchangeRate ?? "";
    return message;
  },
};

function createBaseQueryBurnEventsRequest(): QueryBurnEventsRequest {
  return { startIndex: 0, txID: "", logIndex: 0, chainID: "", status: 0 };
}

export const QueryBurnEventsRequest: MessageFns<QueryBurnEventsRequest> = {
  encode(message: QueryBurnEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startIndex !== 0) {
      writer.uint32(8).uint64(message.startIndex);
    }
    if (message.txID !== "") {
      writer.uint32(18).string(message.txID);
    }
    if (message.logIndex !== 0) {
      writer.uint32(24).uint64(message.logIndex);
    }
    if (message.chainID !== "") {
      writer.uint32(34).string(message.chainID);
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBurnEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBurnEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startIndex = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.txID = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.logIndex = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chainID = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBurnEventsRequest {
    return {
      startIndex: isSet(object.startIndex) ? globalThis.Number(object.startIndex) : 0,
      txID: isSet(object.txID) ? globalThis.String(object.txID) : "",
      logIndex: isSet(object.logIndex) ? globalThis.Number(object.logIndex) : 0,
      chainID: isSet(object.chainID) ? globalThis.String(object.chainID) : "",
      status: isSet(object.status) ? burnStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: QueryBurnEventsRequest): unknown {
    const obj: any = {};
    if (message.startIndex !== 0) {
      obj.startIndex = Math.round(message.startIndex);
    }
    if (message.txID !== "") {
      obj.txID = message.txID;
    }
    if (message.logIndex !== 0) {
      obj.logIndex = Math.round(message.logIndex);
    }
    if (message.chainID !== "") {
      obj.chainID = message.chainID;
    }
    if (message.status !== 0) {
      obj.status = burnStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBurnEventsRequest>, I>>(base?: I): QueryBurnEventsRequest {
    return QueryBurnEventsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBurnEventsRequest>, I>>(object: I): QueryBurnEventsRequest {
    const message = createBaseQueryBurnEventsRequest();
    message.startIndex = object.startIndex ?? 0;
    message.txID = object.txID ?? "";
    message.logIndex = object.logIndex ?? 0;
    message.chainID = object.chainID ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseQueryBurnEventsResponse(): QueryBurnEventsResponse {
  return { burnEvents: [] };
}

export const QueryBurnEventsResponse: MessageFns<QueryBurnEventsResponse> = {
  encode(message: QueryBurnEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.burnEvents) {
      BurnEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBurnEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBurnEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.burnEvents.push(BurnEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBurnEventsResponse {
    return {
      burnEvents: globalThis.Array.isArray(object?.burnEvents)
        ? object.burnEvents.map((e: any) => BurnEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryBurnEventsResponse): unknown {
    const obj: any = {};
    if (message.burnEvents?.length) {
      obj.burnEvents = message.burnEvents.map((e) => BurnEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryBurnEventsResponse>, I>>(base?: I): QueryBurnEventsResponse {
    return QueryBurnEventsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryBurnEventsResponse>, I>>(object: I): QueryBurnEventsResponse {
    const message = createBaseQueryBurnEventsResponse();
    message.burnEvents = object.burnEvents?.map((e) => BurnEvent.fromPartial(e)) || [];
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  QueryParams(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Queries a list of LockTransactions items. */
  GetLockTransactions(request: QueryLockTransactionsRequest): Promise<QueryLockTransactionsResponse>;
  /** Queries a list of Redemptions items. */
  GetRedemptions(request: QueryRedemptionsRequest): Promise<QueryRedemptionsResponse>;
  /** Queries a list of PendingMintTransactions items. */
  QueryPendingMintTransactions(
    request: QueryPendingMintTransactionsRequest,
  ): Promise<QueryPendingMintTransactionsResponse>;
  /** Queries a list of PendingMintTransactions items. */
  QueryPendingMintTransaction(
    request: QueryPendingMintTransactionRequest,
  ): Promise<QueryPendingMintTransactionResponse>;
  /** Queries the current supply of zenBTC. */
  QuerySupply(request: QuerySupplyRequest): Promise<QuerySupplyResponse>;
  /** Queries a list of BurnEvents items. */
  QueryBurnEvents(request: QueryBurnEventsRequest): Promise<QueryBurnEventsResponse>;
}

export const QueryServiceName = "zrchain.zenbtc.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.QueryParams = this.QueryParams.bind(this);
    this.GetLockTransactions = this.GetLockTransactions.bind(this);
    this.GetRedemptions = this.GetRedemptions.bind(this);
    this.QueryPendingMintTransactions = this.QueryPendingMintTransactions.bind(this);
    this.QueryPendingMintTransaction = this.QueryPendingMintTransaction.bind(this);
    this.QuerySupply = this.QuerySupply.bind(this);
    this.QueryBurnEvents = this.QueryBurnEvents.bind(this);
  }
  QueryParams(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryParams", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  GetLockTransactions(request: QueryLockTransactionsRequest): Promise<QueryLockTransactionsResponse> {
    const data = QueryLockTransactionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetLockTransactions", data);
    return promise.then((data) => QueryLockTransactionsResponse.decode(new BinaryReader(data)));
  }

  GetRedemptions(request: QueryRedemptionsRequest): Promise<QueryRedemptionsResponse> {
    const data = QueryRedemptionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetRedemptions", data);
    return promise.then((data) => QueryRedemptionsResponse.decode(new BinaryReader(data)));
  }

  QueryPendingMintTransactions(
    request: QueryPendingMintTransactionsRequest,
  ): Promise<QueryPendingMintTransactionsResponse> {
    const data = QueryPendingMintTransactionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryPendingMintTransactions", data);
    return promise.then((data) => QueryPendingMintTransactionsResponse.decode(new BinaryReader(data)));
  }

  QueryPendingMintTransaction(
    request: QueryPendingMintTransactionRequest,
  ): Promise<QueryPendingMintTransactionResponse> {
    const data = QueryPendingMintTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryPendingMintTransaction", data);
    return promise.then((data) => QueryPendingMintTransactionResponse.decode(new BinaryReader(data)));
  }

  QuerySupply(request: QuerySupplyRequest): Promise<QuerySupplyResponse> {
    const data = QuerySupplyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QuerySupply", data);
    return promise.then((data) => QuerySupplyResponse.decode(new BinaryReader(data)));
  }

  QueryBurnEvents(request: QueryBurnEventsRequest): Promise<QueryBurnEventsResponse> {
    const data = QueryBurnEventsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryBurnEvents", data);
    return promise.then((data) => QueryBurnEventsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
