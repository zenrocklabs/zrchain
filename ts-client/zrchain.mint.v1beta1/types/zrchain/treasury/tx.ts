// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: zrchain/treasury/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../google/protobuf/any";
import { KeyRequestStatus, keyRequestStatusFromJSON, keyRequestStatusToJSON, ZenBTCMetadata } from "./key";
import { SignRequestStatus, signRequestStatusFromJSON, signRequestStatusToJSON } from "./mpcsign";
import { Params } from "./params";
import { WalletType, walletTypeFromJSON, walletTypeToJSON } from "./wallet";

export const protobufPackage = "zrchain.treasury";

/**
 * Verification contains any data required to verify the incoming
 * data_fop_signing 1st case is to check the sighashes generated from the
 * supplied Bitcoin TX are correct
 */
export enum VerificationVersion {
  UNKNOWN = 0,
  BITCOIN_PLUS = 1,
  UNRECOGNIZED = -1,
}

export function verificationVersionFromJSON(object: any): VerificationVersion {
  switch (object) {
    case 0:
    case "UNKNOWN":
      return VerificationVersion.UNKNOWN;
    case 1:
    case "BITCOIN_PLUS":
      return VerificationVersion.BITCOIN_PLUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VerificationVersion.UNRECOGNIZED;
  }
}

export function verificationVersionToJSON(object: VerificationVersion): string {
  switch (object) {
    case VerificationVersion.UNKNOWN:
      return "UNKNOWN";
    case VerificationVersion.BITCOIN_PLUS:
      return "BITCOIN_PLUS";
    case VerificationVersion.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Define an enum for Solana network types */
export enum SolanaNetworkType {
  UNDEFINED = 0,
  MAINNET = 1,
  DEVNET = 2,
  TESTNET = 3,
  REGNET = 4,
  UNRECOGNIZED = -1,
}

export function solanaNetworkTypeFromJSON(object: any): SolanaNetworkType {
  switch (object) {
    case 0:
    case "UNDEFINED":
      return SolanaNetworkType.UNDEFINED;
    case 1:
    case "MAINNET":
      return SolanaNetworkType.MAINNET;
    case 2:
    case "DEVNET":
      return SolanaNetworkType.DEVNET;
    case 3:
    case "TESTNET":
      return SolanaNetworkType.TESTNET;
    case 4:
    case "REGNET":
      return SolanaNetworkType.REGNET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SolanaNetworkType.UNRECOGNIZED;
  }
}

export function solanaNetworkTypeToJSON(object: SolanaNetworkType): string {
  switch (object) {
    case SolanaNetworkType.UNDEFINED:
      return "UNDEFINED";
    case SolanaNetworkType.MAINNET:
      return "MAINNET";
    case SolanaNetworkType.DEVNET:
      return "DEVNET";
    case SolanaNetworkType.TESTNET:
      return "TESTNET";
    case SolanaNetworkType.REGNET:
      return "REGNET";
    case SolanaNetworkType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /**
   * authority is the address that controls the module (defaults to x/gov unless
   * overwritten).
   */
  authority: string;
  /** NOTE: All parameters must be supplied. */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

/** MsgNewKeyRequest is the Msg/NewKeyRequest request type. */
export interface MsgNewKeyRequest {
  creator: string;
  workspaceAddr: string;
  keyringAddr: string;
  keyType: string;
  btl: number;
  index: number;
  extRequester: string;
  extKeyType: number;
  signPolicyId: number;
  /** Optional */
  zenbtcMetadata: ZenBTCMetadata | undefined;
  mpcBtl: number;
}

/**
 * MsgNewKeyRequestResponse defines the response structure for executing a
 * MsgNewKeyRequest message.
 */
export interface MsgNewKeyRequestResponse {
  keyReqId: number;
}

/** MsgFulfilKeyRequest is the Msg/FulfilKeyRequest request type. */
export interface MsgFulfilKeyRequest {
  creator: string;
  requestId: number;
  status: KeyRequestStatus;
  key?: MsgNewKey | undefined;
  rejectReason?: string | undefined;
  keyringPartySignature: Uint8Array;
}

/** MsgNewKey defines the attributes of a key */
export interface MsgNewKey {
  publicKey: Uint8Array;
}

/**
 * MsgNewKeyRequestResponse defines the response structure for executing a
 * MsgNewKeyRequest message.
 */
export interface MsgFulfilKeyRequestResponse {
}

/** MsgNewSignatureRequest is the Msg/NewSignatureRequest request type. */
export interface MsgNewSignatureRequest {
  creator: string;
  keyIds: number[];
  dataForSigning: string;
  btl: number;
  cacheId: Uint8Array;
  verifySigningData: Uint8Array;
  verifySigningDataVersion: VerificationVersion;
  mpcBtl: number;
  /** Optional */
  zenbtcTxBytes: Uint8Array;
}

/**
 * MsgNewKeyRequestResponse defines the response structure for executing a
 * MsgNewKeyRequest message.
 */
export interface MsgNewSignatureRequestResponse {
  sigReqId: number;
}

/** MsgFulfilSignatureRequest is the Msg/NewSignatureRequest request type. */
export interface MsgFulfilSignatureRequest {
  creator: string;
  requestId: number;
  status: SignRequestStatus;
  keyringPartySignature: Uint8Array;
  signedData: Uint8Array;
  rejectReason: string;
}

/**
 * MsgFulfilSignatureRequestResponse defines the response structure for
 * executing a MsgFulfilSignatureRequest message.
 */
export interface MsgFulfilSignatureRequestResponse {
}

/** MetadataEthereum defines the chain id */
export interface MetadataEthereum {
  chainId: number;
}

/**
 * MetadataSolana defines the network (i.e. mainnet, devnet, testnet) for a
 * given transaction
 */
export interface MetadataSolana {
  network: SolanaNetworkType;
  mintAddress: string;
}

/**
 * MsgNewSignTransactionRequest is the Msg/NewSignTransactionRequest request
 * type.
 */
export interface MsgNewSignTransactionRequest {
  creator: string;
  /** Deprecated */
  keyId: number;
  walletType: WalletType;
  unsignedTransaction: Uint8Array;
  /** Additional metadata required when parsing the unsigned transaction. */
  metadata: Any | undefined;
  btl: number;
  cacheId: Uint8Array;
  noBroadcast: boolean;
  mpcBtl: number;
  keyIds: number[];
}

/**
 * MsgNewSignTransactionRequestResponse defines the response structure for
 * executing a MsgNewSignTransactionRequest message.
 */
export interface MsgNewSignTransactionRequestResponse {
  id: number;
  signatureRequestId: number;
}

/** MsgTransferFromKeyring is the Msg/TransferFromKeyring request type. */
export interface MsgTransferFromKeyring {
  creator: string;
  keyring: string;
  recipient: string;
  amount: number;
  denom: string;
}

/**
 * MsgTransferFromKeyringResponse defines the response structure for executing a
 * MsgTransferFromKeyring message.
 */
export interface MsgTransferFromKeyringResponse {
}

/**
 * ---------------------
 *  INTERCHAIN ACCOUNTS
 * ---------------------
 *
 * MsgNewICATransactionRequest is the Msg/NewIcaTransactionRequest request type.
 */
export interface MsgNewICATransactionRequest {
  creator: string;
  keyId: number;
  inputPayload: string;
  connectionId: string;
  relativeTimeoutTimestamp: number;
  btl: number;
}

/**
 * MsgNewICATransactionRequestResponse defines the response structure for
 * executing a MsgNewICATransactionRequest message.
 */
export interface MsgNewICATransactionRequestResponse {
  id: number;
  signatureRequestId: number;
}

/**
 * MsgFulfilICATransactionRequest is the Msg/FulfilICATransactionRequest request
 * type.
 */
export interface MsgFulfilICATransactionRequest {
  creator: string;
  requestId: number;
  status: SignRequestStatus;
  keyringPartySignature: Uint8Array;
  signedData: Uint8Array;
  rejectReason: string;
}

/**
 * MsgFulfilICATransactionRequestResponse defines the response structure for
 * executing a MsgFulfilICATransactionRequest message.
 */
export interface MsgFulfilICATransactionRequestResponse {
}

/**
 * MsgNewZrSignSignatureRequest is the Msg/NewZrSignSignatureRequest request
 * type.
 */
export interface MsgNewZrSignSignatureRequest {
  creator: string;
  address: string;
  keyType: number;
  walletIndex: number;
  cacheId: Uint8Array;
  data: string;
  verifySigningData: Uint8Array;
  verifySigningDataVersion: VerificationVersion;
  walletType: WalletType;
  metadata: Any | undefined;
  noBroadcast: boolean;
  btl: number;
  tx: boolean;
}

/**
 * MsgNewZrSignSignatureRequestResponse defines the response structure for
 * executing a MsgNewZrSignSignatureRequest message.
 */
export interface MsgNewZrSignSignatureRequestResponse {
  reqId: number;
}

/** MsgUpdateKeyPolicy is the Msg/UpdateKeyPolicy request type. */
export interface MsgUpdateKeyPolicy {
  creator: string;
  keyId: number;
  signPolicyId: number;
}

/**
 * MsgUpdateKeyPolicyResponse defines the response structure for executing a
 * MsgUpdateKeyPolicy message.
 */
export interface MsgUpdateKeyPolicyResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgNewKeyRequest(): MsgNewKeyRequest {
  return {
    creator: "",
    workspaceAddr: "",
    keyringAddr: "",
    keyType: "",
    btl: 0,
    index: 0,
    extRequester: "",
    extKeyType: 0,
    signPolicyId: 0,
    zenbtcMetadata: undefined,
    mpcBtl: 0,
  };
}

export const MsgNewKeyRequest: MessageFns<MsgNewKeyRequest> = {
  encode(message: MsgNewKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.workspaceAddr !== "") {
      writer.uint32(18).string(message.workspaceAddr);
    }
    if (message.keyringAddr !== "") {
      writer.uint32(26).string(message.keyringAddr);
    }
    if (message.keyType !== "") {
      writer.uint32(34).string(message.keyType);
    }
    if (message.btl !== 0) {
      writer.uint32(40).uint64(message.btl);
    }
    if (message.index !== 0) {
      writer.uint32(48).uint64(message.index);
    }
    if (message.extRequester !== "") {
      writer.uint32(58).string(message.extRequester);
    }
    if (message.extKeyType !== 0) {
      writer.uint32(64).uint64(message.extKeyType);
    }
    if (message.signPolicyId !== 0) {
      writer.uint32(72).uint64(message.signPolicyId);
    }
    if (message.zenbtcMetadata !== undefined) {
      ZenBTCMetadata.encode(message.zenbtcMetadata, writer.uint32(82).fork()).join();
    }
    if (message.mpcBtl !== 0) {
      writer.uint32(88).uint64(message.mpcBtl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workspaceAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyringAddr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.btl = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.extRequester = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.extKeyType = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.signPolicyId = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.zenbtcMetadata = ZenBTCMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mpcBtl = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewKeyRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      workspaceAddr: isSet(object.workspaceAddr) ? globalThis.String(object.workspaceAddr) : "",
      keyringAddr: isSet(object.keyringAddr) ? globalThis.String(object.keyringAddr) : "",
      keyType: isSet(object.keyType) ? globalThis.String(object.keyType) : "",
      btl: isSet(object.btl) ? globalThis.Number(object.btl) : 0,
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      extRequester: isSet(object.extRequester) ? globalThis.String(object.extRequester) : "",
      extKeyType: isSet(object.extKeyType) ? globalThis.Number(object.extKeyType) : 0,
      signPolicyId: isSet(object.signPolicyId) ? globalThis.Number(object.signPolicyId) : 0,
      zenbtcMetadata: isSet(object.zenbtcMetadata) ? ZenBTCMetadata.fromJSON(object.zenbtcMetadata) : undefined,
      mpcBtl: isSet(object.mpcBtl) ? globalThis.Number(object.mpcBtl) : 0,
    };
  },

  toJSON(message: MsgNewKeyRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.workspaceAddr !== "") {
      obj.workspaceAddr = message.workspaceAddr;
    }
    if (message.keyringAddr !== "") {
      obj.keyringAddr = message.keyringAddr;
    }
    if (message.keyType !== "") {
      obj.keyType = message.keyType;
    }
    if (message.btl !== 0) {
      obj.btl = Math.round(message.btl);
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.extRequester !== "") {
      obj.extRequester = message.extRequester;
    }
    if (message.extKeyType !== 0) {
      obj.extKeyType = Math.round(message.extKeyType);
    }
    if (message.signPolicyId !== 0) {
      obj.signPolicyId = Math.round(message.signPolicyId);
    }
    if (message.zenbtcMetadata !== undefined) {
      obj.zenbtcMetadata = ZenBTCMetadata.toJSON(message.zenbtcMetadata);
    }
    if (message.mpcBtl !== 0) {
      obj.mpcBtl = Math.round(message.mpcBtl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewKeyRequest>, I>>(base?: I): MsgNewKeyRequest {
    return MsgNewKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewKeyRequest>, I>>(object: I): MsgNewKeyRequest {
    const message = createBaseMsgNewKeyRequest();
    message.creator = object.creator ?? "";
    message.workspaceAddr = object.workspaceAddr ?? "";
    message.keyringAddr = object.keyringAddr ?? "";
    message.keyType = object.keyType ?? "";
    message.btl = object.btl ?? 0;
    message.index = object.index ?? 0;
    message.extRequester = object.extRequester ?? "";
    message.extKeyType = object.extKeyType ?? 0;
    message.signPolicyId = object.signPolicyId ?? 0;
    message.zenbtcMetadata = (object.zenbtcMetadata !== undefined && object.zenbtcMetadata !== null)
      ? ZenBTCMetadata.fromPartial(object.zenbtcMetadata)
      : undefined;
    message.mpcBtl = object.mpcBtl ?? 0;
    return message;
  },
};

function createBaseMsgNewKeyRequestResponse(): MsgNewKeyRequestResponse {
  return { keyReqId: 0 };
}

export const MsgNewKeyRequestResponse: MessageFns<MsgNewKeyRequestResponse> = {
  encode(message: MsgNewKeyRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyReqId !== 0) {
      writer.uint32(8).uint64(message.keyReqId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewKeyRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewKeyRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyReqId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewKeyRequestResponse {
    return { keyReqId: isSet(object.keyReqId) ? globalThis.Number(object.keyReqId) : 0 };
  },

  toJSON(message: MsgNewKeyRequestResponse): unknown {
    const obj: any = {};
    if (message.keyReqId !== 0) {
      obj.keyReqId = Math.round(message.keyReqId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewKeyRequestResponse>, I>>(base?: I): MsgNewKeyRequestResponse {
    return MsgNewKeyRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewKeyRequestResponse>, I>>(object: I): MsgNewKeyRequestResponse {
    const message = createBaseMsgNewKeyRequestResponse();
    message.keyReqId = object.keyReqId ?? 0;
    return message;
  },
};

function createBaseMsgFulfilKeyRequest(): MsgFulfilKeyRequest {
  return {
    creator: "",
    requestId: 0,
    status: 0,
    key: undefined,
    rejectReason: undefined,
    keyringPartySignature: new Uint8Array(0),
  };
}

export const MsgFulfilKeyRequest: MessageFns<MsgFulfilKeyRequest> = {
  encode(message: MsgFulfilKeyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.requestId !== 0) {
      writer.uint32(16).uint64(message.requestId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.key !== undefined) {
      MsgNewKey.encode(message.key, writer.uint32(34).fork()).join();
    }
    if (message.rejectReason !== undefined) {
      writer.uint32(42).string(message.rejectReason);
    }
    if (message.keyringPartySignature.length !== 0) {
      writer.uint32(50).bytes(message.keyringPartySignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFulfilKeyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFulfilKeyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requestId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.key = MsgNewKey.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.rejectReason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.keyringPartySignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFulfilKeyRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      status: isSet(object.status) ? keyRequestStatusFromJSON(object.status) : 0,
      key: isSet(object.key) ? MsgNewKey.fromJSON(object.key) : undefined,
      rejectReason: isSet(object.rejectReason) ? globalThis.String(object.rejectReason) : undefined,
      keyringPartySignature: isSet(object.keyringPartySignature)
        ? bytesFromBase64(object.keyringPartySignature)
        : new Uint8Array(0),
    };
  },

  toJSON(message: MsgFulfilKeyRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.status !== 0) {
      obj.status = keyRequestStatusToJSON(message.status);
    }
    if (message.key !== undefined) {
      obj.key = MsgNewKey.toJSON(message.key);
    }
    if (message.rejectReason !== undefined) {
      obj.rejectReason = message.rejectReason;
    }
    if (message.keyringPartySignature.length !== 0) {
      obj.keyringPartySignature = base64FromBytes(message.keyringPartySignature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFulfilKeyRequest>, I>>(base?: I): MsgFulfilKeyRequest {
    return MsgFulfilKeyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFulfilKeyRequest>, I>>(object: I): MsgFulfilKeyRequest {
    const message = createBaseMsgFulfilKeyRequest();
    message.creator = object.creator ?? "";
    message.requestId = object.requestId ?? 0;
    message.status = object.status ?? 0;
    message.key = (object.key !== undefined && object.key !== null) ? MsgNewKey.fromPartial(object.key) : undefined;
    message.rejectReason = object.rejectReason ?? undefined;
    message.keyringPartySignature = object.keyringPartySignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgNewKey(): MsgNewKey {
  return { publicKey: new Uint8Array(0) };
}

export const MsgNewKey: MessageFns<MsgNewKey> = {
  encode(message: MsgNewKey, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.publicKey.length !== 0) {
      writer.uint32(10).bytes(message.publicKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewKey {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewKey {
    return { publicKey: isSet(object.publicKey) ? bytesFromBase64(object.publicKey) : new Uint8Array(0) };
  },

  toJSON(message: MsgNewKey): unknown {
    const obj: any = {};
    if (message.publicKey.length !== 0) {
      obj.publicKey = base64FromBytes(message.publicKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewKey>, I>>(base?: I): MsgNewKey {
    return MsgNewKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewKey>, I>>(object: I): MsgNewKey {
    const message = createBaseMsgNewKey();
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgFulfilKeyRequestResponse(): MsgFulfilKeyRequestResponse {
  return {};
}

export const MsgFulfilKeyRequestResponse: MessageFns<MsgFulfilKeyRequestResponse> = {
  encode(_: MsgFulfilKeyRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFulfilKeyRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFulfilKeyRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFulfilKeyRequestResponse {
    return {};
  },

  toJSON(_: MsgFulfilKeyRequestResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFulfilKeyRequestResponse>, I>>(base?: I): MsgFulfilKeyRequestResponse {
    return MsgFulfilKeyRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFulfilKeyRequestResponse>, I>>(_: I): MsgFulfilKeyRequestResponse {
    const message = createBaseMsgFulfilKeyRequestResponse();
    return message;
  },
};

function createBaseMsgNewSignatureRequest(): MsgNewSignatureRequest {
  return {
    creator: "",
    keyIds: [],
    dataForSigning: "",
    btl: 0,
    cacheId: new Uint8Array(0),
    verifySigningData: new Uint8Array(0),
    verifySigningDataVersion: 0,
    mpcBtl: 0,
    zenbtcTxBytes: new Uint8Array(0),
  };
}

export const MsgNewSignatureRequest: MessageFns<MsgNewSignatureRequest> = {
  encode(message: MsgNewSignatureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    writer.uint32(18).fork();
    for (const v of message.keyIds) {
      writer.uint64(v);
    }
    writer.join();
    if (message.dataForSigning !== "") {
      writer.uint32(26).string(message.dataForSigning);
    }
    if (message.btl !== 0) {
      writer.uint32(32).uint64(message.btl);
    }
    if (message.cacheId.length !== 0) {
      writer.uint32(42).bytes(message.cacheId);
    }
    if (message.verifySigningData.length !== 0) {
      writer.uint32(50).bytes(message.verifySigningData);
    }
    if (message.verifySigningDataVersion !== 0) {
      writer.uint32(56).int32(message.verifySigningDataVersion);
    }
    if (message.mpcBtl !== 0) {
      writer.uint32(64).uint64(message.mpcBtl);
    }
    if (message.zenbtcTxBytes.length !== 0) {
      writer.uint32(74).bytes(message.zenbtcTxBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewSignatureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewSignatureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.keyIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataForSigning = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.btl = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cacheId = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.verifySigningData = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.verifySigningDataVersion = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mpcBtl = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.zenbtcTxBytes = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewSignatureRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      keyIds: globalThis.Array.isArray(object?.keyIds) ? object.keyIds.map((e: any) => globalThis.Number(e)) : [],
      dataForSigning: isSet(object.dataForSigning) ? globalThis.String(object.dataForSigning) : "",
      btl: isSet(object.btl) ? globalThis.Number(object.btl) : 0,
      cacheId: isSet(object.cacheId) ? bytesFromBase64(object.cacheId) : new Uint8Array(0),
      verifySigningData: isSet(object.verifySigningData)
        ? bytesFromBase64(object.verifySigningData)
        : new Uint8Array(0),
      verifySigningDataVersion: isSet(object.verifySigningDataVersion)
        ? verificationVersionFromJSON(object.verifySigningDataVersion)
        : 0,
      mpcBtl: isSet(object.mpcBtl) ? globalThis.Number(object.mpcBtl) : 0,
      zenbtcTxBytes: isSet(object.zenbtcTxBytes) ? bytesFromBase64(object.zenbtcTxBytes) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgNewSignatureRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.keyIds?.length) {
      obj.keyIds = message.keyIds.map((e) => Math.round(e));
    }
    if (message.dataForSigning !== "") {
      obj.dataForSigning = message.dataForSigning;
    }
    if (message.btl !== 0) {
      obj.btl = Math.round(message.btl);
    }
    if (message.cacheId.length !== 0) {
      obj.cacheId = base64FromBytes(message.cacheId);
    }
    if (message.verifySigningData.length !== 0) {
      obj.verifySigningData = base64FromBytes(message.verifySigningData);
    }
    if (message.verifySigningDataVersion !== 0) {
      obj.verifySigningDataVersion = verificationVersionToJSON(message.verifySigningDataVersion);
    }
    if (message.mpcBtl !== 0) {
      obj.mpcBtl = Math.round(message.mpcBtl);
    }
    if (message.zenbtcTxBytes.length !== 0) {
      obj.zenbtcTxBytes = base64FromBytes(message.zenbtcTxBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewSignatureRequest>, I>>(base?: I): MsgNewSignatureRequest {
    return MsgNewSignatureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewSignatureRequest>, I>>(object: I): MsgNewSignatureRequest {
    const message = createBaseMsgNewSignatureRequest();
    message.creator = object.creator ?? "";
    message.keyIds = object.keyIds?.map((e) => e) || [];
    message.dataForSigning = object.dataForSigning ?? "";
    message.btl = object.btl ?? 0;
    message.cacheId = object.cacheId ?? new Uint8Array(0);
    message.verifySigningData = object.verifySigningData ?? new Uint8Array(0);
    message.verifySigningDataVersion = object.verifySigningDataVersion ?? 0;
    message.mpcBtl = object.mpcBtl ?? 0;
    message.zenbtcTxBytes = object.zenbtcTxBytes ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgNewSignatureRequestResponse(): MsgNewSignatureRequestResponse {
  return { sigReqId: 0 };
}

export const MsgNewSignatureRequestResponse: MessageFns<MsgNewSignatureRequestResponse> = {
  encode(message: MsgNewSignatureRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sigReqId !== 0) {
      writer.uint32(8).uint64(message.sigReqId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewSignatureRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewSignatureRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sigReqId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewSignatureRequestResponse {
    return { sigReqId: isSet(object.sigReqId) ? globalThis.Number(object.sigReqId) : 0 };
  },

  toJSON(message: MsgNewSignatureRequestResponse): unknown {
    const obj: any = {};
    if (message.sigReqId !== 0) {
      obj.sigReqId = Math.round(message.sigReqId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewSignatureRequestResponse>, I>>(base?: I): MsgNewSignatureRequestResponse {
    return MsgNewSignatureRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewSignatureRequestResponse>, I>>(
    object: I,
  ): MsgNewSignatureRequestResponse {
    const message = createBaseMsgNewSignatureRequestResponse();
    message.sigReqId = object.sigReqId ?? 0;
    return message;
  },
};

function createBaseMsgFulfilSignatureRequest(): MsgFulfilSignatureRequest {
  return {
    creator: "",
    requestId: 0,
    status: 0,
    keyringPartySignature: new Uint8Array(0),
    signedData: new Uint8Array(0),
    rejectReason: "",
  };
}

export const MsgFulfilSignatureRequest: MessageFns<MsgFulfilSignatureRequest> = {
  encode(message: MsgFulfilSignatureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.requestId !== 0) {
      writer.uint32(16).uint64(message.requestId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.keyringPartySignature.length !== 0) {
      writer.uint32(34).bytes(message.keyringPartySignature);
    }
    if (message.signedData.length !== 0) {
      writer.uint32(42).bytes(message.signedData);
    }
    if (message.rejectReason !== "") {
      writer.uint32(50).string(message.rejectReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFulfilSignatureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFulfilSignatureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requestId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyringPartySignature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signedData = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rejectReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFulfilSignatureRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      status: isSet(object.status) ? signRequestStatusFromJSON(object.status) : 0,
      keyringPartySignature: isSet(object.keyringPartySignature)
        ? bytesFromBase64(object.keyringPartySignature)
        : new Uint8Array(0),
      signedData: isSet(object.signedData) ? bytesFromBase64(object.signedData) : new Uint8Array(0),
      rejectReason: isSet(object.rejectReason) ? globalThis.String(object.rejectReason) : "",
    };
  },

  toJSON(message: MsgFulfilSignatureRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.status !== 0) {
      obj.status = signRequestStatusToJSON(message.status);
    }
    if (message.keyringPartySignature.length !== 0) {
      obj.keyringPartySignature = base64FromBytes(message.keyringPartySignature);
    }
    if (message.signedData.length !== 0) {
      obj.signedData = base64FromBytes(message.signedData);
    }
    if (message.rejectReason !== "") {
      obj.rejectReason = message.rejectReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFulfilSignatureRequest>, I>>(base?: I): MsgFulfilSignatureRequest {
    return MsgFulfilSignatureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFulfilSignatureRequest>, I>>(object: I): MsgFulfilSignatureRequest {
    const message = createBaseMsgFulfilSignatureRequest();
    message.creator = object.creator ?? "";
    message.requestId = object.requestId ?? 0;
    message.status = object.status ?? 0;
    message.keyringPartySignature = object.keyringPartySignature ?? new Uint8Array(0);
    message.signedData = object.signedData ?? new Uint8Array(0);
    message.rejectReason = object.rejectReason ?? "";
    return message;
  },
};

function createBaseMsgFulfilSignatureRequestResponse(): MsgFulfilSignatureRequestResponse {
  return {};
}

export const MsgFulfilSignatureRequestResponse: MessageFns<MsgFulfilSignatureRequestResponse> = {
  encode(_: MsgFulfilSignatureRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFulfilSignatureRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFulfilSignatureRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFulfilSignatureRequestResponse {
    return {};
  },

  toJSON(_: MsgFulfilSignatureRequestResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFulfilSignatureRequestResponse>, I>>(
    base?: I,
  ): MsgFulfilSignatureRequestResponse {
    return MsgFulfilSignatureRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFulfilSignatureRequestResponse>, I>>(
    _: I,
  ): MsgFulfilSignatureRequestResponse {
    const message = createBaseMsgFulfilSignatureRequestResponse();
    return message;
  },
};

function createBaseMetadataEthereum(): MetadataEthereum {
  return { chainId: 0 };
}

export const MetadataEthereum: MessageFns<MetadataEthereum> = {
  encode(message: MetadataEthereum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chainId !== 0) {
      writer.uint32(8).uint64(message.chainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataEthereum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataEthereum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.chainId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataEthereum {
    return { chainId: isSet(object.chainId) ? globalThis.Number(object.chainId) : 0 };
  },

  toJSON(message: MetadataEthereum): unknown {
    const obj: any = {};
    if (message.chainId !== 0) {
      obj.chainId = Math.round(message.chainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataEthereum>, I>>(base?: I): MetadataEthereum {
    return MetadataEthereum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataEthereum>, I>>(object: I): MetadataEthereum {
    const message = createBaseMetadataEthereum();
    message.chainId = object.chainId ?? 0;
    return message;
  },
};

function createBaseMetadataSolana(): MetadataSolana {
  return { network: 0, mintAddress: "" };
}

export const MetadataSolana: MessageFns<MetadataSolana> = {
  encode(message: MetadataSolana, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== 0) {
      writer.uint32(8).int32(message.network);
    }
    if (message.mintAddress !== "") {
      writer.uint32(18).string(message.mintAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetadataSolana {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadataSolana();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.network = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mintAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetadataSolana {
    return {
      network: isSet(object.network) ? solanaNetworkTypeFromJSON(object.network) : 0,
      mintAddress: isSet(object.mintAddress) ? globalThis.String(object.mintAddress) : "",
    };
  },

  toJSON(message: MetadataSolana): unknown {
    const obj: any = {};
    if (message.network !== 0) {
      obj.network = solanaNetworkTypeToJSON(message.network);
    }
    if (message.mintAddress !== "") {
      obj.mintAddress = message.mintAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetadataSolana>, I>>(base?: I): MetadataSolana {
    return MetadataSolana.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetadataSolana>, I>>(object: I): MetadataSolana {
    const message = createBaseMetadataSolana();
    message.network = object.network ?? 0;
    message.mintAddress = object.mintAddress ?? "";
    return message;
  },
};

function createBaseMsgNewSignTransactionRequest(): MsgNewSignTransactionRequest {
  return {
    creator: "",
    keyId: 0,
    walletType: 0,
    unsignedTransaction: new Uint8Array(0),
    metadata: undefined,
    btl: 0,
    cacheId: new Uint8Array(0),
    noBroadcast: false,
    mpcBtl: 0,
    keyIds: [],
  };
}

export const MsgNewSignTransactionRequest: MessageFns<MsgNewSignTransactionRequest> = {
  encode(message: MsgNewSignTransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.keyId !== 0) {
      writer.uint32(16).uint64(message.keyId);
    }
    if (message.walletType !== 0) {
      writer.uint32(24).int32(message.walletType);
    }
    if (message.unsignedTransaction.length !== 0) {
      writer.uint32(34).bytes(message.unsignedTransaction);
    }
    if (message.metadata !== undefined) {
      Any.encode(message.metadata, writer.uint32(42).fork()).join();
    }
    if (message.btl !== 0) {
      writer.uint32(48).uint64(message.btl);
    }
    if (message.cacheId.length !== 0) {
      writer.uint32(58).bytes(message.cacheId);
    }
    if (message.noBroadcast !== false) {
      writer.uint32(64).bool(message.noBroadcast);
    }
    if (message.mpcBtl !== 0) {
      writer.uint32(72).uint64(message.mpcBtl);
    }
    writer.uint32(82).fork();
    for (const v of message.keyIds) {
      writer.uint64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewSignTransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewSignTransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.unsignedTransaction = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = Any.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.btl = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.cacheId = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.noBroadcast = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.mpcBtl = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag === 80) {
            message.keyIds.push(longToNumber(reader.uint64()));

            continue;
          }

          if (tag === 82) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.keyIds.push(longToNumber(reader.uint64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewSignTransactionRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      keyId: isSet(object.keyId) ? globalThis.Number(object.keyId) : 0,
      walletType: isSet(object.walletType) ? walletTypeFromJSON(object.walletType) : 0,
      unsignedTransaction: isSet(object.unsignedTransaction)
        ? bytesFromBase64(object.unsignedTransaction)
        : new Uint8Array(0),
      metadata: isSet(object.metadata) ? Any.fromJSON(object.metadata) : undefined,
      btl: isSet(object.btl) ? globalThis.Number(object.btl) : 0,
      cacheId: isSet(object.cacheId) ? bytesFromBase64(object.cacheId) : new Uint8Array(0),
      noBroadcast: isSet(object.noBroadcast) ? globalThis.Boolean(object.noBroadcast) : false,
      mpcBtl: isSet(object.mpcBtl) ? globalThis.Number(object.mpcBtl) : 0,
      keyIds: globalThis.Array.isArray(object?.keyIds) ? object.keyIds.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: MsgNewSignTransactionRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.keyId !== 0) {
      obj.keyId = Math.round(message.keyId);
    }
    if (message.walletType !== 0) {
      obj.walletType = walletTypeToJSON(message.walletType);
    }
    if (message.unsignedTransaction.length !== 0) {
      obj.unsignedTransaction = base64FromBytes(message.unsignedTransaction);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Any.toJSON(message.metadata);
    }
    if (message.btl !== 0) {
      obj.btl = Math.round(message.btl);
    }
    if (message.cacheId.length !== 0) {
      obj.cacheId = base64FromBytes(message.cacheId);
    }
    if (message.noBroadcast !== false) {
      obj.noBroadcast = message.noBroadcast;
    }
    if (message.mpcBtl !== 0) {
      obj.mpcBtl = Math.round(message.mpcBtl);
    }
    if (message.keyIds?.length) {
      obj.keyIds = message.keyIds.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewSignTransactionRequest>, I>>(base?: I): MsgNewSignTransactionRequest {
    return MsgNewSignTransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewSignTransactionRequest>, I>>(object: I): MsgNewSignTransactionRequest {
    const message = createBaseMsgNewSignTransactionRequest();
    message.creator = object.creator ?? "";
    message.keyId = object.keyId ?? 0;
    message.walletType = object.walletType ?? 0;
    message.unsignedTransaction = object.unsignedTransaction ?? new Uint8Array(0);
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Any.fromPartial(object.metadata)
      : undefined;
    message.btl = object.btl ?? 0;
    message.cacheId = object.cacheId ?? new Uint8Array(0);
    message.noBroadcast = object.noBroadcast ?? false;
    message.mpcBtl = object.mpcBtl ?? 0;
    message.keyIds = object.keyIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgNewSignTransactionRequestResponse(): MsgNewSignTransactionRequestResponse {
  return { id: 0, signatureRequestId: 0 };
}

export const MsgNewSignTransactionRequestResponse: MessageFns<MsgNewSignTransactionRequestResponse> = {
  encode(message: MsgNewSignTransactionRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.signatureRequestId !== 0) {
      writer.uint32(16).uint64(message.signatureRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewSignTransactionRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewSignTransactionRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signatureRequestId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewSignTransactionRequestResponse {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      signatureRequestId: isSet(object.signatureRequestId) ? globalThis.Number(object.signatureRequestId) : 0,
    };
  },

  toJSON(message: MsgNewSignTransactionRequestResponse): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.signatureRequestId !== 0) {
      obj.signatureRequestId = Math.round(message.signatureRequestId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewSignTransactionRequestResponse>, I>>(
    base?: I,
  ): MsgNewSignTransactionRequestResponse {
    return MsgNewSignTransactionRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewSignTransactionRequestResponse>, I>>(
    object: I,
  ): MsgNewSignTransactionRequestResponse {
    const message = createBaseMsgNewSignTransactionRequestResponse();
    message.id = object.id ?? 0;
    message.signatureRequestId = object.signatureRequestId ?? 0;
    return message;
  },
};

function createBaseMsgTransferFromKeyring(): MsgTransferFromKeyring {
  return { creator: "", keyring: "", recipient: "", amount: 0, denom: "" };
}

export const MsgTransferFromKeyring: MessageFns<MsgTransferFromKeyring> = {
  encode(message: MsgTransferFromKeyring, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.keyring !== "") {
      writer.uint32(18).string(message.keyring);
    }
    if (message.recipient !== "") {
      writer.uint32(26).string(message.recipient);
    }
    if (message.amount !== 0) {
      writer.uint32(32).uint64(message.amount);
    }
    if (message.denom !== "") {
      writer.uint32(42).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferFromKeyring {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferFromKeyring();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyring = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recipient = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgTransferFromKeyring {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      keyring: isSet(object.keyring) ? globalThis.String(object.keyring) : "",
      recipient: isSet(object.recipient) ? globalThis.String(object.recipient) : "",
      amount: isSet(object.amount) ? globalThis.Number(object.amount) : 0,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
    };
  },

  toJSON(message: MsgTransferFromKeyring): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.keyring !== "") {
      obj.keyring = message.keyring;
    }
    if (message.recipient !== "") {
      obj.recipient = message.recipient;
    }
    if (message.amount !== 0) {
      obj.amount = Math.round(message.amount);
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTransferFromKeyring>, I>>(base?: I): MsgTransferFromKeyring {
    return MsgTransferFromKeyring.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTransferFromKeyring>, I>>(object: I): MsgTransferFromKeyring {
    const message = createBaseMsgTransferFromKeyring();
    message.creator = object.creator ?? "";
    message.keyring = object.keyring ?? "";
    message.recipient = object.recipient ?? "";
    message.amount = object.amount ?? 0;
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseMsgTransferFromKeyringResponse(): MsgTransferFromKeyringResponse {
  return {};
}

export const MsgTransferFromKeyringResponse: MessageFns<MsgTransferFromKeyringResponse> = {
  encode(_: MsgTransferFromKeyringResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgTransferFromKeyringResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgTransferFromKeyringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgTransferFromKeyringResponse {
    return {};
  },

  toJSON(_: MsgTransferFromKeyringResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgTransferFromKeyringResponse>, I>>(base?: I): MsgTransferFromKeyringResponse {
    return MsgTransferFromKeyringResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgTransferFromKeyringResponse>, I>>(_: I): MsgTransferFromKeyringResponse {
    const message = createBaseMsgTransferFromKeyringResponse();
    return message;
  },
};

function createBaseMsgNewICATransactionRequest(): MsgNewICATransactionRequest {
  return { creator: "", keyId: 0, inputPayload: "", connectionId: "", relativeTimeoutTimestamp: 0, btl: 0 };
}

export const MsgNewICATransactionRequest: MessageFns<MsgNewICATransactionRequest> = {
  encode(message: MsgNewICATransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.keyId !== 0) {
      writer.uint32(16).uint64(message.keyId);
    }
    if (message.inputPayload !== "") {
      writer.uint32(26).string(message.inputPayload);
    }
    if (message.connectionId !== "") {
      writer.uint32(34).string(message.connectionId);
    }
    if (message.relativeTimeoutTimestamp !== 0) {
      writer.uint32(40).uint64(message.relativeTimeoutTimestamp);
    }
    if (message.btl !== 0) {
      writer.uint32(48).uint64(message.btl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewICATransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewICATransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inputPayload = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.relativeTimeoutTimestamp = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.btl = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewICATransactionRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      keyId: isSet(object.keyId) ? globalThis.Number(object.keyId) : 0,
      inputPayload: isSet(object.inputPayload) ? globalThis.String(object.inputPayload) : "",
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      relativeTimeoutTimestamp: isSet(object.relativeTimeoutTimestamp)
        ? globalThis.Number(object.relativeTimeoutTimestamp)
        : 0,
      btl: isSet(object.btl) ? globalThis.Number(object.btl) : 0,
    };
  },

  toJSON(message: MsgNewICATransactionRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.keyId !== 0) {
      obj.keyId = Math.round(message.keyId);
    }
    if (message.inputPayload !== "") {
      obj.inputPayload = message.inputPayload;
    }
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.relativeTimeoutTimestamp !== 0) {
      obj.relativeTimeoutTimestamp = Math.round(message.relativeTimeoutTimestamp);
    }
    if (message.btl !== 0) {
      obj.btl = Math.round(message.btl);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewICATransactionRequest>, I>>(base?: I): MsgNewICATransactionRequest {
    return MsgNewICATransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewICATransactionRequest>, I>>(object: I): MsgNewICATransactionRequest {
    const message = createBaseMsgNewICATransactionRequest();
    message.creator = object.creator ?? "";
    message.keyId = object.keyId ?? 0;
    message.inputPayload = object.inputPayload ?? "";
    message.connectionId = object.connectionId ?? "";
    message.relativeTimeoutTimestamp = object.relativeTimeoutTimestamp ?? 0;
    message.btl = object.btl ?? 0;
    return message;
  },
};

function createBaseMsgNewICATransactionRequestResponse(): MsgNewICATransactionRequestResponse {
  return { id: 0, signatureRequestId: 0 };
}

export const MsgNewICATransactionRequestResponse: MessageFns<MsgNewICATransactionRequestResponse> = {
  encode(message: MsgNewICATransactionRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.signatureRequestId !== 0) {
      writer.uint32(16).uint64(message.signatureRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewICATransactionRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewICATransactionRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signatureRequestId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewICATransactionRequestResponse {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      signatureRequestId: isSet(object.signatureRequestId) ? globalThis.Number(object.signatureRequestId) : 0,
    };
  },

  toJSON(message: MsgNewICATransactionRequestResponse): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.signatureRequestId !== 0) {
      obj.signatureRequestId = Math.round(message.signatureRequestId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewICATransactionRequestResponse>, I>>(
    base?: I,
  ): MsgNewICATransactionRequestResponse {
    return MsgNewICATransactionRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewICATransactionRequestResponse>, I>>(
    object: I,
  ): MsgNewICATransactionRequestResponse {
    const message = createBaseMsgNewICATransactionRequestResponse();
    message.id = object.id ?? 0;
    message.signatureRequestId = object.signatureRequestId ?? 0;
    return message;
  },
};

function createBaseMsgFulfilICATransactionRequest(): MsgFulfilICATransactionRequest {
  return {
    creator: "",
    requestId: 0,
    status: 0,
    keyringPartySignature: new Uint8Array(0),
    signedData: new Uint8Array(0),
    rejectReason: "",
  };
}

export const MsgFulfilICATransactionRequest: MessageFns<MsgFulfilICATransactionRequest> = {
  encode(message: MsgFulfilICATransactionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.requestId !== 0) {
      writer.uint32(16).uint64(message.requestId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.keyringPartySignature.length !== 0) {
      writer.uint32(34).bytes(message.keyringPartySignature);
    }
    if (message.signedData.length !== 0) {
      writer.uint32(42).bytes(message.signedData);
    }
    if (message.rejectReason !== "") {
      writer.uint32(50).string(message.rejectReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFulfilICATransactionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFulfilICATransactionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requestId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.keyringPartySignature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signedData = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rejectReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFulfilICATransactionRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      status: isSet(object.status) ? signRequestStatusFromJSON(object.status) : 0,
      keyringPartySignature: isSet(object.keyringPartySignature)
        ? bytesFromBase64(object.keyringPartySignature)
        : new Uint8Array(0),
      signedData: isSet(object.signedData) ? bytesFromBase64(object.signedData) : new Uint8Array(0),
      rejectReason: isSet(object.rejectReason) ? globalThis.String(object.rejectReason) : "",
    };
  },

  toJSON(message: MsgFulfilICATransactionRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.status !== 0) {
      obj.status = signRequestStatusToJSON(message.status);
    }
    if (message.keyringPartySignature.length !== 0) {
      obj.keyringPartySignature = base64FromBytes(message.keyringPartySignature);
    }
    if (message.signedData.length !== 0) {
      obj.signedData = base64FromBytes(message.signedData);
    }
    if (message.rejectReason !== "") {
      obj.rejectReason = message.rejectReason;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFulfilICATransactionRequest>, I>>(base?: I): MsgFulfilICATransactionRequest {
    return MsgFulfilICATransactionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFulfilICATransactionRequest>, I>>(
    object: I,
  ): MsgFulfilICATransactionRequest {
    const message = createBaseMsgFulfilICATransactionRequest();
    message.creator = object.creator ?? "";
    message.requestId = object.requestId ?? 0;
    message.status = object.status ?? 0;
    message.keyringPartySignature = object.keyringPartySignature ?? new Uint8Array(0);
    message.signedData = object.signedData ?? new Uint8Array(0);
    message.rejectReason = object.rejectReason ?? "";
    return message;
  },
};

function createBaseMsgFulfilICATransactionRequestResponse(): MsgFulfilICATransactionRequestResponse {
  return {};
}

export const MsgFulfilICATransactionRequestResponse: MessageFns<MsgFulfilICATransactionRequestResponse> = {
  encode(_: MsgFulfilICATransactionRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFulfilICATransactionRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFulfilICATransactionRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgFulfilICATransactionRequestResponse {
    return {};
  },

  toJSON(_: MsgFulfilICATransactionRequestResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFulfilICATransactionRequestResponse>, I>>(
    base?: I,
  ): MsgFulfilICATransactionRequestResponse {
    return MsgFulfilICATransactionRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFulfilICATransactionRequestResponse>, I>>(
    _: I,
  ): MsgFulfilICATransactionRequestResponse {
    const message = createBaseMsgFulfilICATransactionRequestResponse();
    return message;
  },
};

function createBaseMsgNewZrSignSignatureRequest(): MsgNewZrSignSignatureRequest {
  return {
    creator: "",
    address: "",
    keyType: 0,
    walletIndex: 0,
    cacheId: new Uint8Array(0),
    data: "",
    verifySigningData: new Uint8Array(0),
    verifySigningDataVersion: 0,
    walletType: 0,
    metadata: undefined,
    noBroadcast: false,
    btl: 0,
    tx: false,
  };
}

export const MsgNewZrSignSignatureRequest: MessageFns<MsgNewZrSignSignatureRequest> = {
  encode(message: MsgNewZrSignSignatureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.keyType !== 0) {
      writer.uint32(24).uint64(message.keyType);
    }
    if (message.walletIndex !== 0) {
      writer.uint32(32).uint64(message.walletIndex);
    }
    if (message.cacheId.length !== 0) {
      writer.uint32(42).bytes(message.cacheId);
    }
    if (message.data !== "") {
      writer.uint32(50).string(message.data);
    }
    if (message.verifySigningData.length !== 0) {
      writer.uint32(58).bytes(message.verifySigningData);
    }
    if (message.verifySigningDataVersion !== 0) {
      writer.uint32(64).int32(message.verifySigningDataVersion);
    }
    if (message.walletType !== 0) {
      writer.uint32(72).int32(message.walletType);
    }
    if (message.metadata !== undefined) {
      Any.encode(message.metadata, writer.uint32(82).fork()).join();
    }
    if (message.noBroadcast !== false) {
      writer.uint32(88).bool(message.noBroadcast);
    }
    if (message.btl !== 0) {
      writer.uint32(96).uint64(message.btl);
    }
    if (message.tx !== false) {
      writer.uint32(104).bool(message.tx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewZrSignSignatureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewZrSignSignatureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyType = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.walletIndex = longToNumber(reader.uint64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cacheId = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.verifySigningData = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.verifySigningDataVersion = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.walletType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadata = Any.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.noBroadcast = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.btl = longToNumber(reader.uint64());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.tx = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewZrSignSignatureRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      keyType: isSet(object.keyType) ? globalThis.Number(object.keyType) : 0,
      walletIndex: isSet(object.walletIndex) ? globalThis.Number(object.walletIndex) : 0,
      cacheId: isSet(object.cacheId) ? bytesFromBase64(object.cacheId) : new Uint8Array(0),
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      verifySigningData: isSet(object.verifySigningData)
        ? bytesFromBase64(object.verifySigningData)
        : new Uint8Array(0),
      verifySigningDataVersion: isSet(object.verifySigningDataVersion)
        ? verificationVersionFromJSON(object.verifySigningDataVersion)
        : 0,
      walletType: isSet(object.walletType) ? walletTypeFromJSON(object.walletType) : 0,
      metadata: isSet(object.metadata) ? Any.fromJSON(object.metadata) : undefined,
      noBroadcast: isSet(object.noBroadcast) ? globalThis.Boolean(object.noBroadcast) : false,
      btl: isSet(object.btl) ? globalThis.Number(object.btl) : 0,
      tx: isSet(object.tx) ? globalThis.Boolean(object.tx) : false,
    };
  },

  toJSON(message: MsgNewZrSignSignatureRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.keyType !== 0) {
      obj.keyType = Math.round(message.keyType);
    }
    if (message.walletIndex !== 0) {
      obj.walletIndex = Math.round(message.walletIndex);
    }
    if (message.cacheId.length !== 0) {
      obj.cacheId = base64FromBytes(message.cacheId);
    }
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.verifySigningData.length !== 0) {
      obj.verifySigningData = base64FromBytes(message.verifySigningData);
    }
    if (message.verifySigningDataVersion !== 0) {
      obj.verifySigningDataVersion = verificationVersionToJSON(message.verifySigningDataVersion);
    }
    if (message.walletType !== 0) {
      obj.walletType = walletTypeToJSON(message.walletType);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Any.toJSON(message.metadata);
    }
    if (message.noBroadcast !== false) {
      obj.noBroadcast = message.noBroadcast;
    }
    if (message.btl !== 0) {
      obj.btl = Math.round(message.btl);
    }
    if (message.tx !== false) {
      obj.tx = message.tx;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewZrSignSignatureRequest>, I>>(base?: I): MsgNewZrSignSignatureRequest {
    return MsgNewZrSignSignatureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewZrSignSignatureRequest>, I>>(object: I): MsgNewZrSignSignatureRequest {
    const message = createBaseMsgNewZrSignSignatureRequest();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    message.keyType = object.keyType ?? 0;
    message.walletIndex = object.walletIndex ?? 0;
    message.cacheId = object.cacheId ?? new Uint8Array(0);
    message.data = object.data ?? "";
    message.verifySigningData = object.verifySigningData ?? new Uint8Array(0);
    message.verifySigningDataVersion = object.verifySigningDataVersion ?? 0;
    message.walletType = object.walletType ?? 0;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Any.fromPartial(object.metadata)
      : undefined;
    message.noBroadcast = object.noBroadcast ?? false;
    message.btl = object.btl ?? 0;
    message.tx = object.tx ?? false;
    return message;
  },
};

function createBaseMsgNewZrSignSignatureRequestResponse(): MsgNewZrSignSignatureRequestResponse {
  return { reqId: 0 };
}

export const MsgNewZrSignSignatureRequestResponse: MessageFns<MsgNewZrSignSignatureRequestResponse> = {
  encode(message: MsgNewZrSignSignatureRequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reqId !== 0) {
      writer.uint32(8).uint64(message.reqId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgNewZrSignSignatureRequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgNewZrSignSignatureRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reqId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgNewZrSignSignatureRequestResponse {
    return { reqId: isSet(object.reqId) ? globalThis.Number(object.reqId) : 0 };
  },

  toJSON(message: MsgNewZrSignSignatureRequestResponse): unknown {
    const obj: any = {};
    if (message.reqId !== 0) {
      obj.reqId = Math.round(message.reqId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgNewZrSignSignatureRequestResponse>, I>>(
    base?: I,
  ): MsgNewZrSignSignatureRequestResponse {
    return MsgNewZrSignSignatureRequestResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgNewZrSignSignatureRequestResponse>, I>>(
    object: I,
  ): MsgNewZrSignSignatureRequestResponse {
    const message = createBaseMsgNewZrSignSignatureRequestResponse();
    message.reqId = object.reqId ?? 0;
    return message;
  },
};

function createBaseMsgUpdateKeyPolicy(): MsgUpdateKeyPolicy {
  return { creator: "", keyId: 0, signPolicyId: 0 };
}

export const MsgUpdateKeyPolicy: MessageFns<MsgUpdateKeyPolicy> = {
  encode(message: MsgUpdateKeyPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.keyId !== 0) {
      writer.uint32(16).uint64(message.keyId);
    }
    if (message.signPolicyId !== 0) {
      writer.uint32(24).uint64(message.signPolicyId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateKeyPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateKeyPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signPolicyId = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateKeyPolicy {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      keyId: isSet(object.keyId) ? globalThis.Number(object.keyId) : 0,
      signPolicyId: isSet(object.signPolicyId) ? globalThis.Number(object.signPolicyId) : 0,
    };
  },

  toJSON(message: MsgUpdateKeyPolicy): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.keyId !== 0) {
      obj.keyId = Math.round(message.keyId);
    }
    if (message.signPolicyId !== 0) {
      obj.signPolicyId = Math.round(message.signPolicyId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateKeyPolicy>, I>>(base?: I): MsgUpdateKeyPolicy {
    return MsgUpdateKeyPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateKeyPolicy>, I>>(object: I): MsgUpdateKeyPolicy {
    const message = createBaseMsgUpdateKeyPolicy();
    message.creator = object.creator ?? "";
    message.keyId = object.keyId ?? 0;
    message.signPolicyId = object.signPolicyId ?? 0;
    return message;
  },
};

function createBaseMsgUpdateKeyPolicyResponse(): MsgUpdateKeyPolicyResponse {
  return {};
}

export const MsgUpdateKeyPolicyResponse: MessageFns<MsgUpdateKeyPolicyResponse> = {
  encode(_: MsgUpdateKeyPolicyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateKeyPolicyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateKeyPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateKeyPolicyResponse {
    return {};
  },

  toJSON(_: MsgUpdateKeyPolicyResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateKeyPolicyResponse>, I>>(base?: I): MsgUpdateKeyPolicyResponse {
    return MsgUpdateKeyPolicyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateKeyPolicyResponse>, I>>(_: I): MsgUpdateKeyPolicyResponse {
    const message = createBaseMsgUpdateKeyPolicyResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines the operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  /** NewKeyRequest defines an operation for creating a key request. */
  NewKeyRequest(request: MsgNewKeyRequest): Promise<MsgNewKeyRequestResponse>;
  /** FulfilKeyRequest defines an operation for responding to a key request */
  FulfilKeyRequest(request: MsgFulfilKeyRequest): Promise<MsgFulfilKeyRequestResponse>;
  /** NewSignatureRequest defines an operation for creating a signature request */
  NewSignatureRequest(request: MsgNewSignatureRequest): Promise<MsgNewSignatureRequestResponse>;
  /**
   * FulfilSignatureRequest defines an operation for returning a signature
   * response to a request
   */
  FulfilSignatureRequest(request: MsgFulfilSignatureRequest): Promise<MsgFulfilSignatureRequestResponse>;
  /**
   * NewSignTransactionRequest defines an operation for creating a signature for
   * transaction request
   */
  NewSignTransactionRequest(request: MsgNewSignTransactionRequest): Promise<MsgNewSignTransactionRequestResponse>;
  /**
   * TransferFromKeyring defines an operation for transferring tokens from a
   * keyring
   */
  TransferFromKeyring(request: MsgTransferFromKeyring): Promise<MsgTransferFromKeyringResponse>;
  /**
   * NewICATransactionRequest defines an operation for creating an interchain
   * account transaction request
   */
  NewICATransactionRequest(request: MsgNewICATransactionRequest): Promise<MsgNewICATransactionRequestResponse>;
  /**
   * FulfilICATransactionRequest defines an operation for responding to an
   * interchain account transaction request
   */
  FulfilICATransactionRequest(request: MsgFulfilICATransactionRequest): Promise<MsgFulfilICATransactionRequestResponse>;
  /**
   * NewZrSignSignatureRequest defines an operation for creating a zrsign
   * signature request
   */
  NewZrSignSignatureRequest(request: MsgNewZrSignSignatureRequest): Promise<MsgNewZrSignSignatureRequestResponse>;
  /** UpdateKeyPolicy defines an operation for updating a key policy */
  UpdateKeyPolicy(request: MsgUpdateKeyPolicy): Promise<MsgUpdateKeyPolicyResponse>;
}

export const MsgServiceName = "zrchain.treasury.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.NewKeyRequest = this.NewKeyRequest.bind(this);
    this.FulfilKeyRequest = this.FulfilKeyRequest.bind(this);
    this.NewSignatureRequest = this.NewSignatureRequest.bind(this);
    this.FulfilSignatureRequest = this.FulfilSignatureRequest.bind(this);
    this.NewSignTransactionRequest = this.NewSignTransactionRequest.bind(this);
    this.TransferFromKeyring = this.TransferFromKeyring.bind(this);
    this.NewICATransactionRequest = this.NewICATransactionRequest.bind(this);
    this.FulfilICATransactionRequest = this.FulfilICATransactionRequest.bind(this);
    this.NewZrSignSignatureRequest = this.NewZrSignSignatureRequest.bind(this);
    this.UpdateKeyPolicy = this.UpdateKeyPolicy.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  NewKeyRequest(request: MsgNewKeyRequest): Promise<MsgNewKeyRequestResponse> {
    const data = MsgNewKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NewKeyRequest", data);
    return promise.then((data) => MsgNewKeyRequestResponse.decode(new BinaryReader(data)));
  }

  FulfilKeyRequest(request: MsgFulfilKeyRequest): Promise<MsgFulfilKeyRequestResponse> {
    const data = MsgFulfilKeyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FulfilKeyRequest", data);
    return promise.then((data) => MsgFulfilKeyRequestResponse.decode(new BinaryReader(data)));
  }

  NewSignatureRequest(request: MsgNewSignatureRequest): Promise<MsgNewSignatureRequestResponse> {
    const data = MsgNewSignatureRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NewSignatureRequest", data);
    return promise.then((data) => MsgNewSignatureRequestResponse.decode(new BinaryReader(data)));
  }

  FulfilSignatureRequest(request: MsgFulfilSignatureRequest): Promise<MsgFulfilSignatureRequestResponse> {
    const data = MsgFulfilSignatureRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FulfilSignatureRequest", data);
    return promise.then((data) => MsgFulfilSignatureRequestResponse.decode(new BinaryReader(data)));
  }

  NewSignTransactionRequest(request: MsgNewSignTransactionRequest): Promise<MsgNewSignTransactionRequestResponse> {
    const data = MsgNewSignTransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NewSignTransactionRequest", data);
    return promise.then((data) => MsgNewSignTransactionRequestResponse.decode(new BinaryReader(data)));
  }

  TransferFromKeyring(request: MsgTransferFromKeyring): Promise<MsgTransferFromKeyringResponse> {
    const data = MsgTransferFromKeyring.encode(request).finish();
    const promise = this.rpc.request(this.service, "TransferFromKeyring", data);
    return promise.then((data) => MsgTransferFromKeyringResponse.decode(new BinaryReader(data)));
  }

  NewICATransactionRequest(request: MsgNewICATransactionRequest): Promise<MsgNewICATransactionRequestResponse> {
    const data = MsgNewICATransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NewICATransactionRequest", data);
    return promise.then((data) => MsgNewICATransactionRequestResponse.decode(new BinaryReader(data)));
  }

  FulfilICATransactionRequest(
    request: MsgFulfilICATransactionRequest,
  ): Promise<MsgFulfilICATransactionRequestResponse> {
    const data = MsgFulfilICATransactionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FulfilICATransactionRequest", data);
    return promise.then((data) => MsgFulfilICATransactionRequestResponse.decode(new BinaryReader(data)));
  }

  NewZrSignSignatureRequest(request: MsgNewZrSignSignatureRequest): Promise<MsgNewZrSignSignatureRequestResponse> {
    const data = MsgNewZrSignSignatureRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NewZrSignSignatureRequest", data);
    return promise.then((data) => MsgNewZrSignSignatureRequestResponse.decode(new BinaryReader(data)));
  }

  UpdateKeyPolicy(request: MsgUpdateKeyPolicy): Promise<MsgUpdateKeyPolicyResponse> {
    const data = MsgUpdateKeyPolicy.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateKeyPolicy", data);
    return promise.then((data) => MsgUpdateKeyPolicyResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
