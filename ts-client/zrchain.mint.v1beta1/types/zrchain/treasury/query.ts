// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: zrchain/treasury/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { PageRequest, PageResponse } from "../../cosmos/base/query/v1beta1/pagination";
import {
  KeyReqResponse,
  KeyRequestStatus,
  keyRequestStatusFromJSON,
  keyRequestStatusToJSON,
  KeyResponse,
  KeyType,
  keyTypeFromJSON,
  keyTypeToJSON,
} from "./key";
import {
  SignReqResponse,
  SignRequestStatus,
  signRequestStatusFromJSON,
  signRequestStatusToJSON,
  SignTxReqResponse,
} from "./mpcsign";
import { Params } from "./params";
import { WalletType, walletTypeFromJSON, walletTypeToJSON } from "./wallet";

export const protobufPackage = "zrchain.treasury";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

/**
 * QueryKeyRequestsRequest is request type for the Query/KeyRequestsRequest RPC
 * method.
 */
export interface QueryKeyRequestsRequest {
  keyringAddr: string;
  status: KeyRequestStatus;
  workspaceAddr: string;
  pagination: PageRequest | undefined;
}

/**
 * QueryKeyRequestsResponse is response type for the Query/KeyRequestsResponse
 * RPC method.
 */
export interface QueryKeyRequestsResponse {
  keyRequests: KeyReqResponse[];
  pagination: PageResponse | undefined;
}

/**
 * QueryKeyByIDRequest is request type for the
 * Query/KeyByIDRequest RPC method.
 */
export interface QueryKeyByIDRequest {
  id: number;
  /** Optional */
  walletType: WalletType;
  /** Optional */
  prefixes: string[];
}

/**
 * QueryKeyByIDResponse is response type for the
 * Query/KeyByIDResponse RPC method.
 */
export interface QueryKeyByIDResponse {
  key: KeyResponse | undefined;
  wallets: WalletResponse[];
}

/** QueryKeysRequest is request type for the Query/KeysRequest RPC method. */
export interface QueryKeysRequest {
  /** Optional */
  workspaceAddr: string;
  /** Optional */
  walletType: WalletType;
  /** Optional */
  prefixes: string[];
  pagination: PageRequest | undefined;
}

/** QueryKeysResponse is response type for the Query/KeysResponse RPC method. */
export interface QueryKeysResponse {
  keys: KeyAndWalletResponse[];
  pagination: PageResponse | undefined;
}

/** KeyWalletResponse returns the key along with derived wallets */
export interface KeyAndWalletResponse {
  key: KeyResponse | undefined;
  wallets: WalletResponse[];
}

/** WalletResponse returns the address to a certain wallet type */
export interface WalletResponse {
  address: string;
  type: string;
}

/**
 * QueryKeyRequestByIDRequest is request type for the
 * Query/KeyRequestByIDRequest RPC method.
 */
export interface QueryKeyRequestByIDRequest {
  id: number;
}

/**
 * QueryKeyRequestByIDResponse is response type for the
 * Query/KeyRequestByIDResponse RPC method.
 */
export interface QueryKeyRequestByIDResponse {
  keyRequest: KeyReqResponse | undefined;
}

/**
 * QuerySignatureRequestsRequest is request type for the
 * Query/SignatureRequestsRequest RPC method.
 */
export interface QuerySignatureRequestsRequest {
  keyringAddr: string;
  /** Optional */
  status: SignRequestStatus;
  pagination: PageRequest | undefined;
}

/**
 * QuerySignatureRequestsResponse is response type for the
 * Query/SignatureRequestsResponse RPC method.
 */
export interface QuerySignatureRequestsResponse {
  signRequests: SignReqResponse[];
  pagination: PageResponse | undefined;
}

/**
 * QuerySignatureRequestByIDRequest is request type for the
 * Query/SignatureRequestByIDRequest RPC method.
 */
export interface QuerySignatureRequestByIDRequest {
  id: number;
}

/**
 * QuerySignatureRequestByIDResponse is response type for the
 * Query/SignatureRequestByIDResponse RPC method.
 */
export interface QuerySignatureRequestByIDResponse {
  signRequest: SignReqResponse | undefined;
}

/**
 * QuerySignTransactionRequestsRequest is request type for the
 * Query/SignTransactionRequestsRequest RPC method.
 */
export interface QuerySignTransactionRequestsRequest {
  /** Optional */
  requestId: number;
  /** Optional */
  keyId: number;
  /** Optional */
  walletType: WalletType;
  /** Optional */
  status: SignRequestStatus;
  pagination: PageRequest | undefined;
}

/**
 * QuerySignTransactionRequestsResponse is response type for the
 * Query/SignTransactionRequestsResponse RPC method.
 */
export interface QuerySignTransactionRequestsResponse {
  signTransactionRequests: SignTransactionRequestsResponse[];
  pagination: PageResponse | undefined;
}

/** SignTransactionRequestResponse returns the sign transcation- and sign request */
export interface SignTransactionRequestsResponse {
  signTransactionRequests: SignTxReqResponse | undefined;
  signRequest: SignReqResponse | undefined;
}

/**
 * QuerySignTransactionRequestByIDRequest is request type for the
 * Query/SignTransactionRequestByIDRequest RPC method.
 */
export interface QuerySignTransactionRequestByIDRequest {
  id: number;
}

/**
 * QuerySignTransactionRequestByIDResponse is response type for the
 * Query/SignTransactionRequestByIDResponse RPC method.
 */
export interface QuerySignTransactionRequestByIDResponse {
  signTransactionRequest: SignTxReqResponse | undefined;
}

/**
 * QueryZrSignKeysRequest is request type for the
 * Query/ZrSignKeysRequest RPC method.
 */
export interface QueryZrSignKeysRequest {
  address: string;
  walletType: string;
  pagination: PageRequest | undefined;
}

/**
 * QueryZrSignKeysResponse is response type for the
 * Query/ZrSignKeysResponse RPC method.
 */
export interface ZrSignKeyEntry {
  walletType: string;
  address: string;
  index: number;
  id: number;
}

/**
 * QueryZrSignKeysResponse is response type for the
 * Query/ZrSignKeysResponse RPC method.
 */
export interface QueryZrSignKeysResponse {
  Keys: ZrSignKeyEntry[];
  pagination: PageResponse | undefined;
}

/**
 * QueryKeyByAddressRequest is request type for the
 * Query/KeyByAddressRequest RPC method.
 */
export interface QueryKeyByAddressRequest {
  address: string;
  /** Optional */
  keyringAddr: string;
  /** Optional */
  keyType: KeyType;
  walletType: WalletType;
  prefixes: string[];
}

/**
 * QueryKeyByAddressResponse is response type for the
 * Query/KeyByAddressResponse RPC method.
 */
export interface QueryKeyByAddressResponse {
  response: KeyAndWalletResponse | undefined;
}

/**
 * QueryZenbtcWalletsRequest is request type for the
 * Query/ZenbtcWalletsRequest RPC method.
 */
export interface QueryZenbtcWalletsRequest {
  /** Optional */
  recipientAddr: string;
  /** Optional */
  chainType: WalletType;
  /** Optional */
  mintChainId: string;
  /** Optional */
  returnAddr: string;
  pagination: PageRequest | undefined;
}

/**
 * QueryZenbtcWalletsResponse is response type for the
 * Query/ZenbtcWalletsResponse RPC method.
 */
export interface QueryZenbtcWalletsResponse {
  zenbtcWallets: KeyAndWalletResponse[];
  pagination: PageResponse | undefined;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryKeyRequestsRequest(): QueryKeyRequestsRequest {
  return { keyringAddr: "", status: 0, workspaceAddr: "", pagination: undefined };
}

export const QueryKeyRequestsRequest: MessageFns<QueryKeyRequestsRequest> = {
  encode(message: QueryKeyRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyringAddr !== "") {
      writer.uint32(10).string(message.keyringAddr);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.workspaceAddr !== "") {
      writer.uint32(26).string(message.workspaceAddr);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyringAddr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.workspaceAddr = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyRequestsRequest {
    return {
      keyringAddr: isSet(object.keyringAddr) ? globalThis.String(object.keyringAddr) : "",
      status: isSet(object.status) ? keyRequestStatusFromJSON(object.status) : 0,
      workspaceAddr: isSet(object.workspaceAddr) ? globalThis.String(object.workspaceAddr) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryKeyRequestsRequest): unknown {
    const obj: any = {};
    if (message.keyringAddr !== "") {
      obj.keyringAddr = message.keyringAddr;
    }
    if (message.status !== 0) {
      obj.status = keyRequestStatusToJSON(message.status);
    }
    if (message.workspaceAddr !== "") {
      obj.workspaceAddr = message.workspaceAddr;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyRequestsRequest>, I>>(base?: I): QueryKeyRequestsRequest {
    return QueryKeyRequestsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyRequestsRequest>, I>>(object: I): QueryKeyRequestsRequest {
    const message = createBaseQueryKeyRequestsRequest();
    message.keyringAddr = object.keyringAddr ?? "";
    message.status = object.status ?? 0;
    message.workspaceAddr = object.workspaceAddr ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryKeyRequestsResponse(): QueryKeyRequestsResponse {
  return { keyRequests: [], pagination: undefined };
}

export const QueryKeyRequestsResponse: MessageFns<QueryKeyRequestsResponse> = {
  encode(message: QueryKeyRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keyRequests) {
      KeyReqResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyRequests.push(KeyReqResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyRequestsResponse {
    return {
      keyRequests: globalThis.Array.isArray(object?.keyRequests)
        ? object.keyRequests.map((e: any) => KeyReqResponse.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryKeyRequestsResponse): unknown {
    const obj: any = {};
    if (message.keyRequests?.length) {
      obj.keyRequests = message.keyRequests.map((e) => KeyReqResponse.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyRequestsResponse>, I>>(base?: I): QueryKeyRequestsResponse {
    return QueryKeyRequestsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyRequestsResponse>, I>>(object: I): QueryKeyRequestsResponse {
    const message = createBaseQueryKeyRequestsResponse();
    message.keyRequests = object.keyRequests?.map((e) => KeyReqResponse.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryKeyByIDRequest(): QueryKeyByIDRequest {
  return { id: 0, walletType: 0, prefixes: [] };
}

export const QueryKeyByIDRequest: MessageFns<QueryKeyByIDRequest> = {
  encode(message: QueryKeyByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    if (message.walletType !== 0) {
      writer.uint32(16).int32(message.walletType);
    }
    for (const v of message.prefixes) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyByIDRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      walletType: isSet(object.walletType) ? walletTypeFromJSON(object.walletType) : 0,
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QueryKeyByIDRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.walletType !== 0) {
      obj.walletType = walletTypeToJSON(message.walletType);
    }
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyByIDRequest>, I>>(base?: I): QueryKeyByIDRequest {
    return QueryKeyByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyByIDRequest>, I>>(object: I): QueryKeyByIDRequest {
    const message = createBaseQueryKeyByIDRequest();
    message.id = object.id ?? 0;
    message.walletType = object.walletType ?? 0;
    message.prefixes = object.prefixes?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryKeyByIDResponse(): QueryKeyByIDResponse {
  return { key: undefined, wallets: [] };
}

export const QueryKeyByIDResponse: MessageFns<QueryKeyByIDResponse> = {
  encode(message: QueryKeyByIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      KeyResponse.encode(message.key, writer.uint32(10).fork()).join();
    }
    for (const v of message.wallets) {
      WalletResponse.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyByIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = KeyResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallets.push(WalletResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyByIDResponse {
    return {
      key: isSet(object.key) ? KeyResponse.fromJSON(object.key) : undefined,
      wallets: globalThis.Array.isArray(object?.wallets)
        ? object.wallets.map((e: any) => WalletResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryKeyByIDResponse): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = KeyResponse.toJSON(message.key);
    }
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => WalletResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyByIDResponse>, I>>(base?: I): QueryKeyByIDResponse {
    return QueryKeyByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyByIDResponse>, I>>(object: I): QueryKeyByIDResponse {
    const message = createBaseQueryKeyByIDResponse();
    message.key = (object.key !== undefined && object.key !== null) ? KeyResponse.fromPartial(object.key) : undefined;
    message.wallets = object.wallets?.map((e) => WalletResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryKeysRequest(): QueryKeysRequest {
  return { workspaceAddr: "", walletType: 0, prefixes: [], pagination: undefined };
}

export const QueryKeysRequest: MessageFns<QueryKeysRequest> = {
  encode(message: QueryKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workspaceAddr !== "") {
      writer.uint32(10).string(message.workspaceAddr);
    }
    if (message.walletType !== 0) {
      writer.uint32(16).int32(message.walletType);
    }
    for (const v of message.prefixes) {
      writer.uint32(26).string(v!);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workspaceAddr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.walletType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeysRequest {
    return {
      workspaceAddr: isSet(object.workspaceAddr) ? globalThis.String(object.workspaceAddr) : "",
      walletType: isSet(object.walletType) ? walletTypeFromJSON(object.walletType) : 0,
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryKeysRequest): unknown {
    const obj: any = {};
    if (message.workspaceAddr !== "") {
      obj.workspaceAddr = message.workspaceAddr;
    }
    if (message.walletType !== 0) {
      obj.walletType = walletTypeToJSON(message.walletType);
    }
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeysRequest>, I>>(base?: I): QueryKeysRequest {
    return QueryKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeysRequest>, I>>(object: I): QueryKeysRequest {
    const message = createBaseQueryKeysRequest();
    message.workspaceAddr = object.workspaceAddr ?? "";
    message.walletType = object.walletType ?? 0;
    message.prefixes = object.prefixes?.map((e) => e) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryKeysResponse(): QueryKeysResponse {
  return { keys: [], pagination: undefined };
}

export const QueryKeysResponse: MessageFns<QueryKeysResponse> = {
  encode(message: QueryKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.keys) {
      KeyAndWalletResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keys.push(KeyAndWalletResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeysResponse {
    return {
      keys: globalThis.Array.isArray(object?.keys) ? object.keys.map((e: any) => KeyAndWalletResponse.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryKeysResponse): unknown {
    const obj: any = {};
    if (message.keys?.length) {
      obj.keys = message.keys.map((e) => KeyAndWalletResponse.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeysResponse>, I>>(base?: I): QueryKeysResponse {
    return QueryKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeysResponse>, I>>(object: I): QueryKeysResponse {
    const message = createBaseQueryKeysResponse();
    message.keys = object.keys?.map((e) => KeyAndWalletResponse.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseKeyAndWalletResponse(): KeyAndWalletResponse {
  return { key: undefined, wallets: [] };
}

export const KeyAndWalletResponse: MessageFns<KeyAndWalletResponse> = {
  encode(message: KeyAndWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== undefined) {
      KeyResponse.encode(message.key, writer.uint32(10).fork()).join();
    }
    for (const v of message.wallets) {
      WalletResponse.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyAndWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyAndWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = KeyResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wallets.push(WalletResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyAndWalletResponse {
    return {
      key: isSet(object.key) ? KeyResponse.fromJSON(object.key) : undefined,
      wallets: globalThis.Array.isArray(object?.wallets)
        ? object.wallets.map((e: any) => WalletResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: KeyAndWalletResponse): unknown {
    const obj: any = {};
    if (message.key !== undefined) {
      obj.key = KeyResponse.toJSON(message.key);
    }
    if (message.wallets?.length) {
      obj.wallets = message.wallets.map((e) => WalletResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KeyAndWalletResponse>, I>>(base?: I): KeyAndWalletResponse {
    return KeyAndWalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KeyAndWalletResponse>, I>>(object: I): KeyAndWalletResponse {
    const message = createBaseKeyAndWalletResponse();
    message.key = (object.key !== undefined && object.key !== null) ? KeyResponse.fromPartial(object.key) : undefined;
    message.wallets = object.wallets?.map((e) => WalletResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWalletResponse(): WalletResponse {
  return { address: "", type: "" };
}

export const WalletResponse: MessageFns<WalletResponse> = {
  encode(message: WalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletResponse {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: WalletResponse): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WalletResponse>, I>>(base?: I): WalletResponse {
    return WalletResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WalletResponse>, I>>(object: I): WalletResponse {
    const message = createBaseWalletResponse();
    message.address = object.address ?? "";
    message.type = object.type ?? "";
    return message;
  },
};

function createBaseQueryKeyRequestByIDRequest(): QueryKeyRequestByIDRequest {
  return { id: 0 };
}

export const QueryKeyRequestByIDRequest: MessageFns<QueryKeyRequestByIDRequest> = {
  encode(message: QueryKeyRequestByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyRequestByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyRequestByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyRequestByIDRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: QueryKeyRequestByIDRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyRequestByIDRequest>, I>>(base?: I): QueryKeyRequestByIDRequest {
    return QueryKeyRequestByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyRequestByIDRequest>, I>>(object: I): QueryKeyRequestByIDRequest {
    const message = createBaseQueryKeyRequestByIDRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseQueryKeyRequestByIDResponse(): QueryKeyRequestByIDResponse {
  return { keyRequest: undefined };
}

export const QueryKeyRequestByIDResponse: MessageFns<QueryKeyRequestByIDResponse> = {
  encode(message: QueryKeyRequestByIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyRequest !== undefined) {
      KeyReqResponse.encode(message.keyRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyRequestByIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyRequestByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyRequest = KeyReqResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyRequestByIDResponse {
    return { keyRequest: isSet(object.keyRequest) ? KeyReqResponse.fromJSON(object.keyRequest) : undefined };
  },

  toJSON(message: QueryKeyRequestByIDResponse): unknown {
    const obj: any = {};
    if (message.keyRequest !== undefined) {
      obj.keyRequest = KeyReqResponse.toJSON(message.keyRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyRequestByIDResponse>, I>>(base?: I): QueryKeyRequestByIDResponse {
    return QueryKeyRequestByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyRequestByIDResponse>, I>>(object: I): QueryKeyRequestByIDResponse {
    const message = createBaseQueryKeyRequestByIDResponse();
    message.keyRequest = (object.keyRequest !== undefined && object.keyRequest !== null)
      ? KeyReqResponse.fromPartial(object.keyRequest)
      : undefined;
    return message;
  },
};

function createBaseQuerySignatureRequestsRequest(): QuerySignatureRequestsRequest {
  return { keyringAddr: "", status: 0, pagination: undefined };
}

export const QuerySignatureRequestsRequest: MessageFns<QuerySignatureRequestsRequest> = {
  encode(message: QuerySignatureRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyringAddr !== "") {
      writer.uint32(10).string(message.keyringAddr);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignatureRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignatureRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyringAddr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignatureRequestsRequest {
    return {
      keyringAddr: isSet(object.keyringAddr) ? globalThis.String(object.keyringAddr) : "",
      status: isSet(object.status) ? signRequestStatusFromJSON(object.status) : 0,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QuerySignatureRequestsRequest): unknown {
    const obj: any = {};
    if (message.keyringAddr !== "") {
      obj.keyringAddr = message.keyringAddr;
    }
    if (message.status !== 0) {
      obj.status = signRequestStatusToJSON(message.status);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignatureRequestsRequest>, I>>(base?: I): QuerySignatureRequestsRequest {
    return QuerySignatureRequestsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignatureRequestsRequest>, I>>(
    object: I,
  ): QuerySignatureRequestsRequest {
    const message = createBaseQuerySignatureRequestsRequest();
    message.keyringAddr = object.keyringAddr ?? "";
    message.status = object.status ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQuerySignatureRequestsResponse(): QuerySignatureRequestsResponse {
  return { signRequests: [], pagination: undefined };
}

export const QuerySignatureRequestsResponse: MessageFns<QuerySignatureRequestsResponse> = {
  encode(message: QuerySignatureRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signRequests) {
      SignReqResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignatureRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignatureRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signRequests.push(SignReqResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignatureRequestsResponse {
    return {
      signRequests: globalThis.Array.isArray(object?.signRequests)
        ? object.signRequests.map((e: any) => SignReqResponse.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QuerySignatureRequestsResponse): unknown {
    const obj: any = {};
    if (message.signRequests?.length) {
      obj.signRequests = message.signRequests.map((e) => SignReqResponse.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignatureRequestsResponse>, I>>(base?: I): QuerySignatureRequestsResponse {
    return QuerySignatureRequestsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignatureRequestsResponse>, I>>(
    object: I,
  ): QuerySignatureRequestsResponse {
    const message = createBaseQuerySignatureRequestsResponse();
    message.signRequests = object.signRequests?.map((e) => SignReqResponse.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQuerySignatureRequestByIDRequest(): QuerySignatureRequestByIDRequest {
  return { id: 0 };
}

export const QuerySignatureRequestByIDRequest: MessageFns<QuerySignatureRequestByIDRequest> = {
  encode(message: QuerySignatureRequestByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignatureRequestByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignatureRequestByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignatureRequestByIDRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: QuerySignatureRequestByIDRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignatureRequestByIDRequest>, I>>(
    base?: I,
  ): QuerySignatureRequestByIDRequest {
    return QuerySignatureRequestByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignatureRequestByIDRequest>, I>>(
    object: I,
  ): QuerySignatureRequestByIDRequest {
    const message = createBaseQuerySignatureRequestByIDRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseQuerySignatureRequestByIDResponse(): QuerySignatureRequestByIDResponse {
  return { signRequest: undefined };
}

export const QuerySignatureRequestByIDResponse: MessageFns<QuerySignatureRequestByIDResponse> = {
  encode(message: QuerySignatureRequestByIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signRequest !== undefined) {
      SignReqResponse.encode(message.signRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignatureRequestByIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignatureRequestByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signRequest = SignReqResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignatureRequestByIDResponse {
    return { signRequest: isSet(object.signRequest) ? SignReqResponse.fromJSON(object.signRequest) : undefined };
  },

  toJSON(message: QuerySignatureRequestByIDResponse): unknown {
    const obj: any = {};
    if (message.signRequest !== undefined) {
      obj.signRequest = SignReqResponse.toJSON(message.signRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignatureRequestByIDResponse>, I>>(
    base?: I,
  ): QuerySignatureRequestByIDResponse {
    return QuerySignatureRequestByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignatureRequestByIDResponse>, I>>(
    object: I,
  ): QuerySignatureRequestByIDResponse {
    const message = createBaseQuerySignatureRequestByIDResponse();
    message.signRequest = (object.signRequest !== undefined && object.signRequest !== null)
      ? SignReqResponse.fromPartial(object.signRequest)
      : undefined;
    return message;
  },
};

function createBaseQuerySignTransactionRequestsRequest(): QuerySignTransactionRequestsRequest {
  return { requestId: 0, keyId: 0, walletType: 0, status: 0, pagination: undefined };
}

export const QuerySignTransactionRequestsRequest: MessageFns<QuerySignTransactionRequestsRequest> = {
  encode(message: QuerySignTransactionRequestsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).uint64(message.requestId);
    }
    if (message.keyId !== 0) {
      writer.uint32(16).uint64(message.keyId);
    }
    if (message.walletType !== 0) {
      writer.uint32(24).int32(message.walletType);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignTransactionRequestsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignTransactionRequestsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = longToNumber(reader.uint64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.keyId = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.walletType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignTransactionRequestsRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      keyId: isSet(object.keyId) ? globalThis.Number(object.keyId) : 0,
      walletType: isSet(object.walletType) ? walletTypeFromJSON(object.walletType) : 0,
      status: isSet(object.status) ? signRequestStatusFromJSON(object.status) : 0,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QuerySignTransactionRequestsRequest): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.keyId !== 0) {
      obj.keyId = Math.round(message.keyId);
    }
    if (message.walletType !== 0) {
      obj.walletType = walletTypeToJSON(message.walletType);
    }
    if (message.status !== 0) {
      obj.status = signRequestStatusToJSON(message.status);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignTransactionRequestsRequest>, I>>(
    base?: I,
  ): QuerySignTransactionRequestsRequest {
    return QuerySignTransactionRequestsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignTransactionRequestsRequest>, I>>(
    object: I,
  ): QuerySignTransactionRequestsRequest {
    const message = createBaseQuerySignTransactionRequestsRequest();
    message.requestId = object.requestId ?? 0;
    message.keyId = object.keyId ?? 0;
    message.walletType = object.walletType ?? 0;
    message.status = object.status ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQuerySignTransactionRequestsResponse(): QuerySignTransactionRequestsResponse {
  return { signTransactionRequests: [], pagination: undefined };
}

export const QuerySignTransactionRequestsResponse: MessageFns<QuerySignTransactionRequestsResponse> = {
  encode(message: QuerySignTransactionRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.signTransactionRequests) {
      SignTransactionRequestsResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignTransactionRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignTransactionRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signTransactionRequests.push(SignTransactionRequestsResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignTransactionRequestsResponse {
    return {
      signTransactionRequests: globalThis.Array.isArray(object?.signTransactionRequests)
        ? object.signTransactionRequests.map((e: any) => SignTransactionRequestsResponse.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QuerySignTransactionRequestsResponse): unknown {
    const obj: any = {};
    if (message.signTransactionRequests?.length) {
      obj.signTransactionRequests = message.signTransactionRequests.map((e) =>
        SignTransactionRequestsResponse.toJSON(e)
      );
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignTransactionRequestsResponse>, I>>(
    base?: I,
  ): QuerySignTransactionRequestsResponse {
    return QuerySignTransactionRequestsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignTransactionRequestsResponse>, I>>(
    object: I,
  ): QuerySignTransactionRequestsResponse {
    const message = createBaseQuerySignTransactionRequestsResponse();
    message.signTransactionRequests =
      object.signTransactionRequests?.map((e) => SignTransactionRequestsResponse.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseSignTransactionRequestsResponse(): SignTransactionRequestsResponse {
  return { signTransactionRequests: undefined, signRequest: undefined };
}

export const SignTransactionRequestsResponse: MessageFns<SignTransactionRequestsResponse> = {
  encode(message: SignTransactionRequestsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signTransactionRequests !== undefined) {
      SignTxReqResponse.encode(message.signTransactionRequests, writer.uint32(10).fork()).join();
    }
    if (message.signRequest !== undefined) {
      SignReqResponse.encode(message.signRequest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignTransactionRequestsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignTransactionRequestsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signTransactionRequests = SignTxReqResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signRequest = SignReqResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignTransactionRequestsResponse {
    return {
      signTransactionRequests: isSet(object.signTransactionRequests)
        ? SignTxReqResponse.fromJSON(object.signTransactionRequests)
        : undefined,
      signRequest: isSet(object.signRequest) ? SignReqResponse.fromJSON(object.signRequest) : undefined,
    };
  },

  toJSON(message: SignTransactionRequestsResponse): unknown {
    const obj: any = {};
    if (message.signTransactionRequests !== undefined) {
      obj.signTransactionRequests = SignTxReqResponse.toJSON(message.signTransactionRequests);
    }
    if (message.signRequest !== undefined) {
      obj.signRequest = SignReqResponse.toJSON(message.signRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignTransactionRequestsResponse>, I>>(base?: I): SignTransactionRequestsResponse {
    return SignTransactionRequestsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignTransactionRequestsResponse>, I>>(
    object: I,
  ): SignTransactionRequestsResponse {
    const message = createBaseSignTransactionRequestsResponse();
    message.signTransactionRequests =
      (object.signTransactionRequests !== undefined && object.signTransactionRequests !== null)
        ? SignTxReqResponse.fromPartial(object.signTransactionRequests)
        : undefined;
    message.signRequest = (object.signRequest !== undefined && object.signRequest !== null)
      ? SignReqResponse.fromPartial(object.signRequest)
      : undefined;
    return message;
  },
};

function createBaseQuerySignTransactionRequestByIDRequest(): QuerySignTransactionRequestByIDRequest {
  return { id: 0 };
}

export const QuerySignTransactionRequestByIDRequest: MessageFns<QuerySignTransactionRequestByIDRequest> = {
  encode(message: QuerySignTransactionRequestByIDRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignTransactionRequestByIDRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignTransactionRequestByIDRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignTransactionRequestByIDRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: QuerySignTransactionRequestByIDRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignTransactionRequestByIDRequest>, I>>(
    base?: I,
  ): QuerySignTransactionRequestByIDRequest {
    return QuerySignTransactionRequestByIDRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignTransactionRequestByIDRequest>, I>>(
    object: I,
  ): QuerySignTransactionRequestByIDRequest {
    const message = createBaseQuerySignTransactionRequestByIDRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseQuerySignTransactionRequestByIDResponse(): QuerySignTransactionRequestByIDResponse {
  return { signTransactionRequest: undefined };
}

export const QuerySignTransactionRequestByIDResponse: MessageFns<QuerySignTransactionRequestByIDResponse> = {
  encode(message: QuerySignTransactionRequestByIDResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.signTransactionRequest !== undefined) {
      SignTxReqResponse.encode(message.signTransactionRequest, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QuerySignTransactionRequestByIDResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuerySignTransactionRequestByIDResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.signTransactionRequest = SignTxReqResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QuerySignTransactionRequestByIDResponse {
    return {
      signTransactionRequest: isSet(object.signTransactionRequest)
        ? SignTxReqResponse.fromJSON(object.signTransactionRequest)
        : undefined,
    };
  },

  toJSON(message: QuerySignTransactionRequestByIDResponse): unknown {
    const obj: any = {};
    if (message.signTransactionRequest !== undefined) {
      obj.signTransactionRequest = SignTxReqResponse.toJSON(message.signTransactionRequest);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QuerySignTransactionRequestByIDResponse>, I>>(
    base?: I,
  ): QuerySignTransactionRequestByIDResponse {
    return QuerySignTransactionRequestByIDResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QuerySignTransactionRequestByIDResponse>, I>>(
    object: I,
  ): QuerySignTransactionRequestByIDResponse {
    const message = createBaseQuerySignTransactionRequestByIDResponse();
    message.signTransactionRequest =
      (object.signTransactionRequest !== undefined && object.signTransactionRequest !== null)
        ? SignTxReqResponse.fromPartial(object.signTransactionRequest)
        : undefined;
    return message;
  },
};

function createBaseQueryZrSignKeysRequest(): QueryZrSignKeysRequest {
  return { address: "", walletType: "", pagination: undefined };
}

export const QueryZrSignKeysRequest: MessageFns<QueryZrSignKeysRequest> = {
  encode(message: QueryZrSignKeysRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.walletType !== "") {
      writer.uint32(18).string(message.walletType);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryZrSignKeysRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryZrSignKeysRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.walletType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryZrSignKeysRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      walletType: isSet(object.walletType) ? globalThis.String(object.walletType) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryZrSignKeysRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.walletType !== "") {
      obj.walletType = message.walletType;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryZrSignKeysRequest>, I>>(base?: I): QueryZrSignKeysRequest {
    return QueryZrSignKeysRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryZrSignKeysRequest>, I>>(object: I): QueryZrSignKeysRequest {
    const message = createBaseQueryZrSignKeysRequest();
    message.address = object.address ?? "";
    message.walletType = object.walletType ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseZrSignKeyEntry(): ZrSignKeyEntry {
  return { walletType: "", address: "", index: 0, id: 0 };
}

export const ZrSignKeyEntry: MessageFns<ZrSignKeyEntry> = {
  encode(message: ZrSignKeyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletType !== "") {
      writer.uint32(10).string(message.walletType);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.index !== 0) {
      writer.uint32(24).uint64(message.index);
    }
    if (message.id !== 0) {
      writer.uint32(32).uint64(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ZrSignKeyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseZrSignKeyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.index = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.id = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ZrSignKeyEntry {
    return {
      walletType: isSet(object.walletType) ? globalThis.String(object.walletType) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
    };
  },

  toJSON(message: ZrSignKeyEntry): unknown {
    const obj: any = {};
    if (message.walletType !== "") {
      obj.walletType = message.walletType;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ZrSignKeyEntry>, I>>(base?: I): ZrSignKeyEntry {
    return ZrSignKeyEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ZrSignKeyEntry>, I>>(object: I): ZrSignKeyEntry {
    const message = createBaseZrSignKeyEntry();
    message.walletType = object.walletType ?? "";
    message.address = object.address ?? "";
    message.index = object.index ?? 0;
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseQueryZrSignKeysResponse(): QueryZrSignKeysResponse {
  return { Keys: [], pagination: undefined };
}

export const QueryZrSignKeysResponse: MessageFns<QueryZrSignKeysResponse> = {
  encode(message: QueryZrSignKeysResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.Keys) {
      ZrSignKeyEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryZrSignKeysResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryZrSignKeysResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Keys.push(ZrSignKeyEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryZrSignKeysResponse {
    return {
      Keys: globalThis.Array.isArray(object?.Keys) ? object.Keys.map((e: any) => ZrSignKeyEntry.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryZrSignKeysResponse): unknown {
    const obj: any = {};
    if (message.Keys?.length) {
      obj.Keys = message.Keys.map((e) => ZrSignKeyEntry.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryZrSignKeysResponse>, I>>(base?: I): QueryZrSignKeysResponse {
    return QueryZrSignKeysResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryZrSignKeysResponse>, I>>(object: I): QueryZrSignKeysResponse {
    const message = createBaseQueryZrSignKeysResponse();
    message.Keys = object.Keys?.map((e) => ZrSignKeyEntry.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryKeyByAddressRequest(): QueryKeyByAddressRequest {
  return { address: "", keyringAddr: "", keyType: 0, walletType: 0, prefixes: [] };
}

export const QueryKeyByAddressRequest: MessageFns<QueryKeyByAddressRequest> = {
  encode(message: QueryKeyByAddressRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.keyringAddr !== "") {
      writer.uint32(18).string(message.keyringAddr);
    }
    if (message.keyType !== 0) {
      writer.uint32(24).int32(message.keyType);
    }
    if (message.walletType !== 0) {
      writer.uint32(32).int32(message.walletType);
    }
    for (const v of message.prefixes) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyByAddressRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyByAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyringAddr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.walletType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.prefixes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyByAddressRequest {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      keyringAddr: isSet(object.keyringAddr) ? globalThis.String(object.keyringAddr) : "",
      keyType: isSet(object.keyType) ? keyTypeFromJSON(object.keyType) : 0,
      walletType: isSet(object.walletType) ? walletTypeFromJSON(object.walletType) : 0,
      prefixes: globalThis.Array.isArray(object?.prefixes) ? object.prefixes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: QueryKeyByAddressRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.keyringAddr !== "") {
      obj.keyringAddr = message.keyringAddr;
    }
    if (message.keyType !== 0) {
      obj.keyType = keyTypeToJSON(message.keyType);
    }
    if (message.walletType !== 0) {
      obj.walletType = walletTypeToJSON(message.walletType);
    }
    if (message.prefixes?.length) {
      obj.prefixes = message.prefixes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyByAddressRequest>, I>>(base?: I): QueryKeyByAddressRequest {
    return QueryKeyByAddressRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyByAddressRequest>, I>>(object: I): QueryKeyByAddressRequest {
    const message = createBaseQueryKeyByAddressRequest();
    message.address = object.address ?? "";
    message.keyringAddr = object.keyringAddr ?? "";
    message.keyType = object.keyType ?? 0;
    message.walletType = object.walletType ?? 0;
    message.prefixes = object.prefixes?.map((e) => e) || [];
    return message;
  },
};

function createBaseQueryKeyByAddressResponse(): QueryKeyByAddressResponse {
  return { response: undefined };
}

export const QueryKeyByAddressResponse: MessageFns<QueryKeyByAddressResponse> = {
  encode(message: QueryKeyByAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      KeyAndWalletResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryKeyByAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryKeyByAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = KeyAndWalletResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryKeyByAddressResponse {
    return { response: isSet(object.response) ? KeyAndWalletResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: QueryKeyByAddressResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = KeyAndWalletResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryKeyByAddressResponse>, I>>(base?: I): QueryKeyByAddressResponse {
    return QueryKeyByAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryKeyByAddressResponse>, I>>(object: I): QueryKeyByAddressResponse {
    const message = createBaseQueryKeyByAddressResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? KeyAndWalletResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseQueryZenbtcWalletsRequest(): QueryZenbtcWalletsRequest {
  return { recipientAddr: "", chainType: 0, mintChainId: "", returnAddr: "", pagination: undefined };
}

export const QueryZenbtcWalletsRequest: MessageFns<QueryZenbtcWalletsRequest> = {
  encode(message: QueryZenbtcWalletsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipientAddr !== "") {
      writer.uint32(10).string(message.recipientAddr);
    }
    if (message.chainType !== 0) {
      writer.uint32(16).int32(message.chainType);
    }
    if (message.mintChainId !== "") {
      writer.uint32(26).string(message.mintChainId);
    }
    if (message.returnAddr !== "") {
      writer.uint32(34).string(message.returnAddr);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryZenbtcWalletsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryZenbtcWalletsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipientAddr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.chainType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mintChainId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.returnAddr = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryZenbtcWalletsRequest {
    return {
      recipientAddr: isSet(object.recipientAddr) ? globalThis.String(object.recipientAddr) : "",
      chainType: isSet(object.chainType) ? walletTypeFromJSON(object.chainType) : 0,
      mintChainId: isSet(object.mintChainId) ? globalThis.String(object.mintChainId) : "",
      returnAddr: isSet(object.returnAddr) ? globalThis.String(object.returnAddr) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryZenbtcWalletsRequest): unknown {
    const obj: any = {};
    if (message.recipientAddr !== "") {
      obj.recipientAddr = message.recipientAddr;
    }
    if (message.chainType !== 0) {
      obj.chainType = walletTypeToJSON(message.chainType);
    }
    if (message.mintChainId !== "") {
      obj.mintChainId = message.mintChainId;
    }
    if (message.returnAddr !== "") {
      obj.returnAddr = message.returnAddr;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryZenbtcWalletsRequest>, I>>(base?: I): QueryZenbtcWalletsRequest {
    return QueryZenbtcWalletsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryZenbtcWalletsRequest>, I>>(object: I): QueryZenbtcWalletsRequest {
    const message = createBaseQueryZenbtcWalletsRequest();
    message.recipientAddr = object.recipientAddr ?? "";
    message.chainType = object.chainType ?? 0;
    message.mintChainId = object.mintChainId ?? "";
    message.returnAddr = object.returnAddr ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryZenbtcWalletsResponse(): QueryZenbtcWalletsResponse {
  return { zenbtcWallets: [], pagination: undefined };
}

export const QueryZenbtcWalletsResponse: MessageFns<QueryZenbtcWalletsResponse> = {
  encode(message: QueryZenbtcWalletsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.zenbtcWallets) {
      KeyAndWalletResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryZenbtcWalletsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryZenbtcWalletsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.zenbtcWallets.push(KeyAndWalletResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryZenbtcWalletsResponse {
    return {
      zenbtcWallets: globalThis.Array.isArray(object?.zenbtcWallets)
        ? object.zenbtcWallets.map((e: any) => KeyAndWalletResponse.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryZenbtcWalletsResponse): unknown {
    const obj: any = {};
    if (message.zenbtcWallets?.length) {
      obj.zenbtcWallets = message.zenbtcWallets.map((e) => KeyAndWalletResponse.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryZenbtcWalletsResponse>, I>>(base?: I): QueryZenbtcWalletsResponse {
    return QueryZenbtcWalletsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryZenbtcWalletsResponse>, I>>(object: I): QueryZenbtcWalletsResponse {
    const message = createBaseQueryZenbtcWalletsResponse();
    message.zenbtcWallets = object.zenbtcWallets?.map((e) => KeyAndWalletResponse.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  /** Queries a list of KeyRequests items. */
  KeyRequests(request: QueryKeyRequestsRequest): Promise<QueryKeyRequestsResponse>;
  /** Queries a list of KeyRequestByID items. */
  KeyRequestByID(request: QueryKeyRequestByIDRequest): Promise<QueryKeyRequestByIDResponse>;
  /** Queries a list of Keys items. */
  Keys(request: QueryKeysRequest): Promise<QueryKeysResponse>;
  /** Queries a list of KeyByID items. */
  KeyByID(request: QueryKeyByIDRequest): Promise<QueryKeyByIDResponse>;
  /** Queries a list of SignatureRequests items. */
  SignatureRequests(request: QuerySignatureRequestsRequest): Promise<QuerySignatureRequestsResponse>;
  /** Queries a list of SignatureRequestByID items. */
  SignatureRequestByID(request: QuerySignatureRequestByIDRequest): Promise<QuerySignatureRequestByIDResponse>;
  /** Queries a list of SignTransactionRequests items. */
  SignTransactionRequests(request: QuerySignTransactionRequestsRequest): Promise<QuerySignTransactionRequestsResponse>;
  /** Queries a list of SignTransactionRequestByID items. */
  SignTransactionRequestByID(
    request: QuerySignTransactionRequestByIDRequest,
  ): Promise<QuerySignTransactionRequestByIDResponse>;
  /** Queries a list of ZrSignKeys items. */
  ZrSignKeys(request: QueryZrSignKeysRequest): Promise<QueryZrSignKeysResponse>;
  /** Queries a list of KeyByAddress items. */
  KeyByAddress(request: QueryKeyByAddressRequest): Promise<QueryKeyByAddressResponse>;
  /** Queries a list of ZenbtcWallets items. */
  ZenbtcWallets(request: QueryZenbtcWalletsRequest): Promise<QueryZenbtcWalletsResponse>;
}

export const QueryServiceName = "zrchain.treasury.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.KeyRequests = this.KeyRequests.bind(this);
    this.KeyRequestByID = this.KeyRequestByID.bind(this);
    this.Keys = this.Keys.bind(this);
    this.KeyByID = this.KeyByID.bind(this);
    this.SignatureRequests = this.SignatureRequests.bind(this);
    this.SignatureRequestByID = this.SignatureRequestByID.bind(this);
    this.SignTransactionRequests = this.SignTransactionRequests.bind(this);
    this.SignTransactionRequestByID = this.SignTransactionRequestByID.bind(this);
    this.ZrSignKeys = this.ZrSignKeys.bind(this);
    this.KeyByAddress = this.KeyByAddress.bind(this);
    this.ZenbtcWallets = this.ZenbtcWallets.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  KeyRequests(request: QueryKeyRequestsRequest): Promise<QueryKeyRequestsResponse> {
    const data = QueryKeyRequestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "KeyRequests", data);
    return promise.then((data) => QueryKeyRequestsResponse.decode(new BinaryReader(data)));
  }

  KeyRequestByID(request: QueryKeyRequestByIDRequest): Promise<QueryKeyRequestByIDResponse> {
    const data = QueryKeyRequestByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "KeyRequestByID", data);
    return promise.then((data) => QueryKeyRequestByIDResponse.decode(new BinaryReader(data)));
  }

  Keys(request: QueryKeysRequest): Promise<QueryKeysResponse> {
    const data = QueryKeysRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Keys", data);
    return promise.then((data) => QueryKeysResponse.decode(new BinaryReader(data)));
  }

  KeyByID(request: QueryKeyByIDRequest): Promise<QueryKeyByIDResponse> {
    const data = QueryKeyByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "KeyByID", data);
    return promise.then((data) => QueryKeyByIDResponse.decode(new BinaryReader(data)));
  }

  SignatureRequests(request: QuerySignatureRequestsRequest): Promise<QuerySignatureRequestsResponse> {
    const data = QuerySignatureRequestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SignatureRequests", data);
    return promise.then((data) => QuerySignatureRequestsResponse.decode(new BinaryReader(data)));
  }

  SignatureRequestByID(request: QuerySignatureRequestByIDRequest): Promise<QuerySignatureRequestByIDResponse> {
    const data = QuerySignatureRequestByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SignatureRequestByID", data);
    return promise.then((data) => QuerySignatureRequestByIDResponse.decode(new BinaryReader(data)));
  }

  SignTransactionRequests(request: QuerySignTransactionRequestsRequest): Promise<QuerySignTransactionRequestsResponse> {
    const data = QuerySignTransactionRequestsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SignTransactionRequests", data);
    return promise.then((data) => QuerySignTransactionRequestsResponse.decode(new BinaryReader(data)));
  }

  SignTransactionRequestByID(
    request: QuerySignTransactionRequestByIDRequest,
  ): Promise<QuerySignTransactionRequestByIDResponse> {
    const data = QuerySignTransactionRequestByIDRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SignTransactionRequestByID", data);
    return promise.then((data) => QuerySignTransactionRequestByIDResponse.decode(new BinaryReader(data)));
  }

  ZrSignKeys(request: QueryZrSignKeysRequest): Promise<QueryZrSignKeysResponse> {
    const data = QueryZrSignKeysRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ZrSignKeys", data);
    return promise.then((data) => QueryZrSignKeysResponse.decode(new BinaryReader(data)));
  }

  KeyByAddress(request: QueryKeyByAddressRequest): Promise<QueryKeyByAddressResponse> {
    const data = QueryKeyByAddressRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "KeyByAddress", data);
    return promise.then((data) => QueryKeyByAddressResponse.decode(new BinaryReader(data)));
  }

  ZenbtcWallets(request: QueryZenbtcWalletsRequest): Promise<QueryZenbtcWalletsResponse> {
    const data = QueryZenbtcWalletsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ZenbtcWallets", data);
    return promise.then((data) => QueryZenbtcWalletsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
