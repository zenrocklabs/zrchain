// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { QueryParamsRequest } from "./types/zrchain/zenbtc/query";
import { QuerySupplyResponse } from "./types/zrchain/zenbtc/query";
import { NonceData } from "./types/zrchain/zenbtc/mint";
import { PendingMintTransactions } from "./types/zrchain/zenbtc/mint";
import { QueryParamsResponse } from "./types/zrchain/zenbtc/query";
import { QueryLockTransactionsRequest } from "./types/zrchain/zenbtc/query";
import { QueryRedemptionsResponse } from "./types/zrchain/zenbtc/query";
import { BurnEvent } from "./types/zrchain/zenbtc/redemptions";
import { MsgSubmitUnsignedRedemptionTxResponse } from "./types/zrchain/zenbtc/tx";
import { QueryRedemptionsRequest } from "./types/zrchain/zenbtc/query";
import { QueryPendingMintTransactionsRequest } from "./types/zrchain/zenbtc/query";
import { RedemptionData } from "./types/zrchain/zenbtc/redemptions";
import { GenesisState } from "./types/zrchain/zenbtc/genesis";
import { RequestedBitcoinHeaders } from "./types/zrchain/zenbtc/mint";
import { QuerySupplyRequest } from "./types/zrchain/zenbtc/query";
import { Supply } from "./types/zrchain/zenbtc/supply";
import { Solana } from "./types/zrchain/zenbtc/params";
import { MsgUpdateParamsResponse } from "./types/zrchain/zenbtc/tx";
import { MsgVerifyDepositBlockInclusionResponse } from "./types/zrchain/zenbtc/tx";
import { PendingMintTransaction } from "./types/zrchain/zenbtc/mint";
import { QueryLockTransactionsResponse } from "./types/zrchain/zenbtc/query";
import { QueryPendingMintTransactionsResponse } from "./types/zrchain/zenbtc/query";
import { Params } from "./types/zrchain/zenbtc/params";
import { Redemption } from "./types/zrchain/zenbtc/redemptions";
import { MsgSubmitUnsignedRedemptionTx } from "./types/zrchain/zenbtc/tx";
import { MsgUpdateParams } from "./types/zrchain/zenbtc/tx";
import { MsgVerifyDepositBlockInclusion } from "./types/zrchain/zenbtc/tx";
import { InputHashes } from "./types/zrchain/zenbtc/tx";
import { LockTransaction } from "./types/zrchain/zenbtc/mint";
import { QueryBurnEventsRequest } from "./types/zrchain/zenbtc/query";
import { QueryBurnEventsResponse } from "./types/zrchain/zenbtc/query";

import { NonceData as typeNonceData} from "./types"
import { RequestedBitcoinHeaders as typeRequestedBitcoinHeaders} from "./types"
import { LockTransaction as typeLockTransaction} from "./types"
import { PendingMintTransaction as typePendingMintTransaction} from "./types"
import { PendingMintTransactions as typePendingMintTransactions} from "./types"
import { Params as typeParams} from "./types"
import { Solana as typeSolana} from "./types"
import { Redemption as typeRedemption} from "./types"
import { RedemptionData as typeRedemptionData} from "./types"
import { BurnEvent as typeBurnEvent} from "./types"
import { Supply as typeSupply} from "./types"
import { InputHashes as typeInputHashes} from "./types"

export { QueryParamsRequest, QuerySupplyResponse, NonceData, PendingMintTransactions, QueryParamsResponse, QueryLockTransactionsRequest, QueryRedemptionsResponse, BurnEvent, MsgSubmitUnsignedRedemptionTxResponse, QueryRedemptionsRequest, QueryPendingMintTransactionsRequest, RedemptionData, GenesisState, RequestedBitcoinHeaders, QuerySupplyRequest, Supply, Solana, MsgUpdateParamsResponse, MsgVerifyDepositBlockInclusionResponse, PendingMintTransaction, QueryLockTransactionsResponse, QueryPendingMintTransactionsResponse, Params, Redemption, MsgSubmitUnsignedRedemptionTx, MsgUpdateParams, MsgVerifyDepositBlockInclusion, InputHashes, LockTransaction, QueryBurnEventsRequest, QueryBurnEventsResponse };

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQuerySupplyResponseParams = {
  value: QuerySupplyResponse,
  fee?: StdFee,
  memo?: string
};

type sendNonceDataParams = {
  value: NonceData,
  fee?: StdFee,
  memo?: string
};

type sendPendingMintTransactionsParams = {
  value: PendingMintTransactions,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryLockTransactionsRequestParams = {
  value: QueryLockTransactionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryRedemptionsResponseParams = {
  value: QueryRedemptionsResponse,
  fee?: StdFee,
  memo?: string
};

type sendBurnEventParams = {
  value: BurnEvent,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubmitUnsignedRedemptionTxResponseParams = {
  value: MsgSubmitUnsignedRedemptionTxResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryRedemptionsRequestParams = {
  value: QueryRedemptionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryPendingMintTransactionsRequestParams = {
  value: QueryPendingMintTransactionsRequest,
  fee?: StdFee,
  memo?: string
};

type sendRedemptionDataParams = {
  value: RedemptionData,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendRequestedBitcoinHeadersParams = {
  value: RequestedBitcoinHeaders,
  fee?: StdFee,
  memo?: string
};

type sendQuerySupplyRequestParams = {
  value: QuerySupplyRequest,
  fee?: StdFee,
  memo?: string
};

type sendSupplyParams = {
  value: Supply,
  fee?: StdFee,
  memo?: string
};

type sendSolanaParams = {
  value: Solana,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgVerifyDepositBlockInclusionResponseParams = {
  value: MsgVerifyDepositBlockInclusionResponse,
  fee?: StdFee,
  memo?: string
};

type sendPendingMintTransactionParams = {
  value: PendingMintTransaction,
  fee?: StdFee,
  memo?: string
};

type sendQueryLockTransactionsResponseParams = {
  value: QueryLockTransactionsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryPendingMintTransactionsResponseParams = {
  value: QueryPendingMintTransactionsResponse,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendRedemptionParams = {
  value: Redemption,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubmitUnsignedRedemptionTxParams = {
  value: MsgSubmitUnsignedRedemptionTx,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgVerifyDepositBlockInclusionParams = {
  value: MsgVerifyDepositBlockInclusion,
  fee?: StdFee,
  memo?: string
};

type sendInputHashesParams = {
  value: InputHashes,
  fee?: StdFee,
  memo?: string
};

type sendLockTransactionParams = {
  value: LockTransaction,
  fee?: StdFee,
  memo?: string
};

type sendQueryBurnEventsRequestParams = {
  value: QueryBurnEventsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryBurnEventsResponseParams = {
  value: QueryBurnEventsResponse,
  fee?: StdFee,
  memo?: string
};


type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type querySupplyResponseParams = {
  value: QuerySupplyResponse,
};

type nonceDataParams = {
  value: NonceData,
};

type pendingMintTransactionsParams = {
  value: PendingMintTransactions,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryLockTransactionsRequestParams = {
  value: QueryLockTransactionsRequest,
};

type queryRedemptionsResponseParams = {
  value: QueryRedemptionsResponse,
};

type burnEventParams = {
  value: BurnEvent,
};

type msgSubmitUnsignedRedemptionTxResponseParams = {
  value: MsgSubmitUnsignedRedemptionTxResponse,
};

type queryRedemptionsRequestParams = {
  value: QueryRedemptionsRequest,
};

type queryPendingMintTransactionsRequestParams = {
  value: QueryPendingMintTransactionsRequest,
};

type redemptionDataParams = {
  value: RedemptionData,
};

type genesisStateParams = {
  value: GenesisState,
};

type requestedBitcoinHeadersParams = {
  value: RequestedBitcoinHeaders,
};

type querySupplyRequestParams = {
  value: QuerySupplyRequest,
};

type supplyParams = {
  value: Supply,
};

type solanaParams = {
  value: Solana,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgVerifyDepositBlockInclusionResponseParams = {
  value: MsgVerifyDepositBlockInclusionResponse,
};

type pendingMintTransactionParams = {
  value: PendingMintTransaction,
};

type queryLockTransactionsResponseParams = {
  value: QueryLockTransactionsResponse,
};

type queryPendingMintTransactionsResponseParams = {
  value: QueryPendingMintTransactionsResponse,
};

type paramsParams = {
  value: Params,
};

type redemptionParams = {
  value: Redemption,
};

type msgSubmitUnsignedRedemptionTxParams = {
  value: MsgSubmitUnsignedRedemptionTx,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgVerifyDepositBlockInclusionParams = {
  value: MsgVerifyDepositBlockInclusion,
};

type inputHashesParams = {
  value: InputHashes,
};

type lockTransactionParams = {
  value: LockTransaction,
};

type queryBurnEventsRequestParams = {
  value: QueryBurnEventsRequest,
};

type queryBurnEventsResponseParams = {
  value: QueryBurnEventsResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySupplyResponse({ value, fee, memo }: sendQuerySupplyResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySupplyResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySupplyResponse({ value: QuerySupplyResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySupplyResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendNonceData({ value, fee, memo }: sendNonceDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendNonceData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.nonceData({ value: NonceData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendNonceData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPendingMintTransactions({ value, fee, memo }: sendPendingMintTransactionsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPendingMintTransactions: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.pendingMintTransactions({ value: PendingMintTransactions.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPendingMintTransactions: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryLockTransactionsRequest({ value, fee, memo }: sendQueryLockTransactionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryLockTransactionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryLockTransactionsRequest({ value: QueryLockTransactionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryLockTransactionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryRedemptionsResponse({ value, fee, memo }: sendQueryRedemptionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryRedemptionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryRedemptionsResponse({ value: QueryRedemptionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryRedemptionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendBurnEvent({ value, fee, memo }: sendBurnEventParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendBurnEvent: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.burnEvent({ value: BurnEvent.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendBurnEvent: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubmitUnsignedRedemptionTxResponse({ value, fee, memo }: sendMsgSubmitUnsignedRedemptionTxResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubmitUnsignedRedemptionTxResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubmitUnsignedRedemptionTxResponse({ value: MsgSubmitUnsignedRedemptionTxResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubmitUnsignedRedemptionTxResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryRedemptionsRequest({ value, fee, memo }: sendQueryRedemptionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryRedemptionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryRedemptionsRequest({ value: QueryRedemptionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryRedemptionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPendingMintTransactionsRequest({ value, fee, memo }: sendQueryPendingMintTransactionsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPendingMintTransactionsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPendingMintTransactionsRequest({ value: QueryPendingMintTransactionsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPendingMintTransactionsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRedemptionData({ value, fee, memo }: sendRedemptionDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRedemptionData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.redemptionData({ value: RedemptionData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRedemptionData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRequestedBitcoinHeaders({ value, fee, memo }: sendRequestedBitcoinHeadersParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRequestedBitcoinHeaders: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.requestedBitcoinHeaders({ value: RequestedBitcoinHeaders.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRequestedBitcoinHeaders: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQuerySupplyRequest({ value, fee, memo }: sendQuerySupplyRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQuerySupplyRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.querySupplyRequest({ value: QuerySupplyRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQuerySupplyRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSupply({ value, fee, memo }: sendSupplyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSupply: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.supply({ value: Supply.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSupply: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSolana({ value, fee, memo }: sendSolanaParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSolana: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.solana({ value: Solana.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSolana: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgVerifyDepositBlockInclusionResponse({ value, fee, memo }: sendMsgVerifyDepositBlockInclusionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgVerifyDepositBlockInclusionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgVerifyDepositBlockInclusionResponse({ value: MsgVerifyDepositBlockInclusionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgVerifyDepositBlockInclusionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPendingMintTransaction({ value, fee, memo }: sendPendingMintTransactionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPendingMintTransaction: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.pendingMintTransaction({ value: PendingMintTransaction.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPendingMintTransaction: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryLockTransactionsResponse({ value, fee, memo }: sendQueryLockTransactionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryLockTransactionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryLockTransactionsResponse({ value: QueryLockTransactionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryLockTransactionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryPendingMintTransactionsResponse({ value, fee, memo }: sendQueryPendingMintTransactionsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryPendingMintTransactionsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryPendingMintTransactionsResponse({ value: QueryPendingMintTransactionsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryPendingMintTransactionsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendRedemption({ value, fee, memo }: sendRedemptionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendRedemption: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.redemption({ value: Redemption.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendRedemption: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubmitUnsignedRedemptionTx({ value, fee, memo }: sendMsgSubmitUnsignedRedemptionTxParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubmitUnsignedRedemptionTx: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubmitUnsignedRedemptionTx({ value: MsgSubmitUnsignedRedemptionTx.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubmitUnsignedRedemptionTx: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgVerifyDepositBlockInclusion({ value, fee, memo }: sendMsgVerifyDepositBlockInclusionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgVerifyDepositBlockInclusion: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgVerifyDepositBlockInclusion({ value: MsgVerifyDepositBlockInclusion.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgVerifyDepositBlockInclusion: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendInputHashes({ value, fee, memo }: sendInputHashesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendInputHashes: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.inputHashes({ value: InputHashes.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendInputHashes: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendLockTransaction({ value, fee, memo }: sendLockTransactionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendLockTransaction: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.lockTransaction({ value: LockTransaction.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendLockTransaction: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryBurnEventsRequest({ value, fee, memo }: sendQueryBurnEventsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryBurnEventsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryBurnEventsRequest({ value: QueryBurnEventsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryBurnEventsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryBurnEventsResponse({ value, fee, memo }: sendQueryBurnEventsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryBurnEventsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryBurnEventsResponse({ value: QueryBurnEventsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryBurnEventsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		querySupplyResponse({ value }: querySupplyResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QuerySupplyResponse", value: QuerySupplyResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySupplyResponse: Could not create message: ' + e.message)
			}
		},
		
		nonceData({ value }: nonceDataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.NonceData", value: NonceData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:NonceData: Could not create message: ' + e.message)
			}
		},
		
		pendingMintTransactions({ value }: pendingMintTransactionsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.PendingMintTransactions", value: PendingMintTransactions.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PendingMintTransactions: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryLockTransactionsRequest({ value }: queryLockTransactionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryLockTransactionsRequest", value: QueryLockTransactionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryLockTransactionsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryRedemptionsResponse({ value }: queryRedemptionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryRedemptionsResponse", value: QueryRedemptionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryRedemptionsResponse: Could not create message: ' + e.message)
			}
		},
		
		burnEvent({ value }: burnEventParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.BurnEvent", value: BurnEvent.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:BurnEvent: Could not create message: ' + e.message)
			}
		},
		
		msgSubmitUnsignedRedemptionTxResponse({ value }: msgSubmitUnsignedRedemptionTxResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.MsgSubmitUnsignedRedemptionTxResponse", value: MsgSubmitUnsignedRedemptionTxResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubmitUnsignedRedemptionTxResponse: Could not create message: ' + e.message)
			}
		},
		
		queryRedemptionsRequest({ value }: queryRedemptionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryRedemptionsRequest", value: QueryRedemptionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryRedemptionsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryPendingMintTransactionsRequest({ value }: queryPendingMintTransactionsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryPendingMintTransactionsRequest", value: QueryPendingMintTransactionsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPendingMintTransactionsRequest: Could not create message: ' + e.message)
			}
		},
		
		redemptionData({ value }: redemptionDataParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.RedemptionData", value: RedemptionData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RedemptionData: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		requestedBitcoinHeaders({ value }: requestedBitcoinHeadersParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.RequestedBitcoinHeaders", value: RequestedBitcoinHeaders.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:RequestedBitcoinHeaders: Could not create message: ' + e.message)
			}
		},
		
		querySupplyRequest({ value }: querySupplyRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QuerySupplyRequest", value: QuerySupplyRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QuerySupplyRequest: Could not create message: ' + e.message)
			}
		},
		
		supply({ value }: supplyParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.Supply", value: Supply.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Supply: Could not create message: ' + e.message)
			}
		},
		
		solana({ value }: solanaParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.Solana", value: Solana.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Solana: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgVerifyDepositBlockInclusionResponse({ value }: msgVerifyDepositBlockInclusionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.MsgVerifyDepositBlockInclusionResponse", value: MsgVerifyDepositBlockInclusionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgVerifyDepositBlockInclusionResponse: Could not create message: ' + e.message)
			}
		},
		
		pendingMintTransaction({ value }: pendingMintTransactionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.PendingMintTransaction", value: PendingMintTransaction.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PendingMintTransaction: Could not create message: ' + e.message)
			}
		},
		
		queryLockTransactionsResponse({ value }: queryLockTransactionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryLockTransactionsResponse", value: QueryLockTransactionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryLockTransactionsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryPendingMintTransactionsResponse({ value }: queryPendingMintTransactionsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryPendingMintTransactionsResponse", value: QueryPendingMintTransactionsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryPendingMintTransactionsResponse: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		redemption({ value }: redemptionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.Redemption", value: Redemption.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Redemption: Could not create message: ' + e.message)
			}
		},
		
		msgSubmitUnsignedRedemptionTx({ value }: msgSubmitUnsignedRedemptionTxParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.MsgSubmitUnsignedRedemptionTx", value: MsgSubmitUnsignedRedemptionTx.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubmitUnsignedRedemptionTx: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgVerifyDepositBlockInclusion({ value }: msgVerifyDepositBlockInclusionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.MsgVerifyDepositBlockInclusion", value: MsgVerifyDepositBlockInclusion.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgVerifyDepositBlockInclusion: Could not create message: ' + e.message)
			}
		},
		
		inputHashes({ value }: inputHashesParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.InputHashes", value: InputHashes.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:InputHashes: Could not create message: ' + e.message)
			}
		},
		
		lockTransaction({ value }: lockTransactionParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.LockTransaction", value: LockTransaction.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:LockTransaction: Could not create message: ' + e.message)
			}
		},
		
		queryBurnEventsRequest({ value }: queryBurnEventsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryBurnEventsRequest", value: QueryBurnEventsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryBurnEventsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryBurnEventsResponse({ value }: queryBurnEventsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/zrchain.zenbtc.QueryBurnEventsResponse", value: QueryBurnEventsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryBurnEventsResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						NonceData: getStructure(typeNonceData.fromPartial({})),
						RequestedBitcoinHeaders: getStructure(typeRequestedBitcoinHeaders.fromPartial({})),
						LockTransaction: getStructure(typeLockTransaction.fromPartial({})),
						PendingMintTransaction: getStructure(typePendingMintTransaction.fromPartial({})),
						PendingMintTransactions: getStructure(typePendingMintTransactions.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						Solana: getStructure(typeSolana.fromPartial({})),
						Redemption: getStructure(typeRedemption.fromPartial({})),
						RedemptionData: getStructure(typeRedemptionData.fromPartial({})),
						BurnEvent: getStructure(typeBurnEvent.fromPartial({})),
						Supply: getStructure(typeSupply.fromPartial({})),
						InputHashes: getStructure(typeInputHashes.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			ZrchainZenbtc: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;