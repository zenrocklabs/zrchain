// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: zrchain/treasury/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Verification contains any data required to verify the incoming data_fop_signing
// 1st case is to check the sighashes generated from the supplied Bitcoin TX are correct
type VerificationVersion int32

const (
	VerificationVersion_UNKNOWN      VerificationVersion = 0
	VerificationVersion_BITCOIN_PLUS VerificationVersion = 1
)

var VerificationVersion_name = map[int32]string{
	0: "UNKNOWN",
	1: "BITCOIN_PLUS",
}

var VerificationVersion_value = map[string]int32{
	"UNKNOWN":      0,
	"BITCOIN_PLUS": 1,
}

func (x VerificationVersion) String() string {
	return proto.EnumName(VerificationVersion_name, int32(x))
}

func (VerificationVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{0}
}

// Define an enum for Solana network types
type SolanaNetworkType int32

const (
	SolanaNetworkType_UNDEFINED SolanaNetworkType = 0
	SolanaNetworkType_MAINNET   SolanaNetworkType = 1
	SolanaNetworkType_DEVNET    SolanaNetworkType = 2
	SolanaNetworkType_TESTNET   SolanaNetworkType = 3
)

var SolanaNetworkType_name = map[int32]string{
	0: "UNDEFINED",
	1: "MAINNET",
	2: "DEVNET",
	3: "TESTNET",
}

var SolanaNetworkType_value = map[string]int32{
	"UNDEFINED": 0,
	"MAINNET":   1,
	"DEVNET":    2,
	"TESTNET":   3,
}

func (x SolanaNetworkType) String() string {
	return proto.EnumName(SolanaNetworkType_name, int32(x))
}

func (SolanaNetworkType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{1}
}

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless
	// overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgNewKeyRequest is the Msg/NewKeyRequest request type.
type MsgNewKeyRequest struct {
	Creator        string         `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	WorkspaceAddr  string         `protobuf:"bytes,2,opt,name=workspace_addr,json=workspaceAddr,proto3" json:"workspace_addr,omitempty"`
	KeyringAddr    string         `protobuf:"bytes,3,opt,name=keyring_addr,json=keyringAddr,proto3" json:"keyring_addr,omitempty"`
	KeyType        string         `protobuf:"bytes,4,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	Btl            uint64         `protobuf:"varint,5,opt,name=btl,proto3" json:"btl,omitempty"`
	Index          uint64         `protobuf:"varint,6,opt,name=index,proto3" json:"index,omitempty"`
	ExtRequester   string         `protobuf:"bytes,7,opt,name=ext_requester,json=extRequester,proto3" json:"ext_requester,omitempty"`
	ExtKeyType     uint64         `protobuf:"varint,8,opt,name=ext_key_type,json=extKeyType,proto3" json:"ext_key_type,omitempty"`
	SignPolicyId   uint64         `protobuf:"varint,9,opt,name=sign_policy_id,json=signPolicyId,proto3" json:"sign_policy_id,omitempty"`
	ZenbtcMetadata *ZenBTCMetdata `protobuf:"bytes,10,opt,name=zenbtc_metadata,json=zenbtcMetadata,proto3" json:"zenbtc_metadata,omitempty"`
}

func (m *MsgNewKeyRequest) Reset()         { *m = MsgNewKeyRequest{} }
func (m *MsgNewKeyRequest) String() string { return proto.CompactTextString(m) }
func (*MsgNewKeyRequest) ProtoMessage()    {}
func (*MsgNewKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{2}
}
func (m *MsgNewKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewKeyRequest.Merge(m, src)
}
func (m *MsgNewKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewKeyRequest proto.InternalMessageInfo

func (m *MsgNewKeyRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgNewKeyRequest) GetWorkspaceAddr() string {
	if m != nil {
		return m.WorkspaceAddr
	}
	return ""
}

func (m *MsgNewKeyRequest) GetKeyringAddr() string {
	if m != nil {
		return m.KeyringAddr
	}
	return ""
}

func (m *MsgNewKeyRequest) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *MsgNewKeyRequest) GetBtl() uint64 {
	if m != nil {
		return m.Btl
	}
	return 0
}

func (m *MsgNewKeyRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *MsgNewKeyRequest) GetExtRequester() string {
	if m != nil {
		return m.ExtRequester
	}
	return ""
}

func (m *MsgNewKeyRequest) GetExtKeyType() uint64 {
	if m != nil {
		return m.ExtKeyType
	}
	return 0
}

func (m *MsgNewKeyRequest) GetSignPolicyId() uint64 {
	if m != nil {
		return m.SignPolicyId
	}
	return 0
}

func (m *MsgNewKeyRequest) GetZenbtcMetadata() *ZenBTCMetdata {
	if m != nil {
		return m.ZenbtcMetadata
	}
	return nil
}

// MsgNewKeyRequestResponse defines the response structure for executing a
// MsgNewKeyRequest message.
type MsgNewKeyRequestResponse struct {
	KeyReqId uint64 `protobuf:"varint,1,opt,name=key_req_id,json=keyReqId,proto3" json:"key_req_id,omitempty"`
}

func (m *MsgNewKeyRequestResponse) Reset()         { *m = MsgNewKeyRequestResponse{} }
func (m *MsgNewKeyRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgNewKeyRequestResponse) ProtoMessage()    {}
func (*MsgNewKeyRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{3}
}
func (m *MsgNewKeyRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewKeyRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewKeyRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewKeyRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewKeyRequestResponse.Merge(m, src)
}
func (m *MsgNewKeyRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewKeyRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewKeyRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewKeyRequestResponse proto.InternalMessageInfo

func (m *MsgNewKeyRequestResponse) GetKeyReqId() uint64 {
	if m != nil {
		return m.KeyReqId
	}
	return 0
}

// MsgFulfilKeyRequest is the Msg/FulfilKeyRequest request type.
type MsgFulfilKeyRequest struct {
	Creator   string           `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	RequestId uint64           `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Status    KeyRequestStatus `protobuf:"varint,3,opt,name=status,proto3,enum=zrchain.treasury.KeyRequestStatus" json:"status,omitempty"`
	// Holds the result of the request. If status is approved, the result will
	// contain the requested key's public key that can be used for signing
	// payloads.
	// If status is rejected, the result will contain the reason.
	//
	// Types that are valid to be assigned to Result:
	//	*MsgFulfilKeyRequest_Key
	//	*MsgFulfilKeyRequest_RejectReason
	Result                isMsgFulfilKeyRequest_Result `protobuf_oneof:"result"`
	KeyringPartySignature []byte                       `protobuf:"bytes,6,opt,name=keyring_party_signature,json=keyringPartySignature,proto3" json:"keyring_party_signature,omitempty"`
}

func (m *MsgFulfilKeyRequest) Reset()         { *m = MsgFulfilKeyRequest{} }
func (m *MsgFulfilKeyRequest) String() string { return proto.CompactTextString(m) }
func (*MsgFulfilKeyRequest) ProtoMessage()    {}
func (*MsgFulfilKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{4}
}
func (m *MsgFulfilKeyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfilKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfilKeyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfilKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfilKeyRequest.Merge(m, src)
}
func (m *MsgFulfilKeyRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfilKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfilKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfilKeyRequest proto.InternalMessageInfo

type isMsgFulfilKeyRequest_Result interface {
	isMsgFulfilKeyRequest_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgFulfilKeyRequest_Key struct {
	Key *MsgNewKey `protobuf:"bytes,4,opt,name=key,proto3,oneof" json:"key,omitempty"`
}
type MsgFulfilKeyRequest_RejectReason struct {
	RejectReason string `protobuf:"bytes,5,opt,name=reject_reason,json=rejectReason,proto3,oneof" json:"reject_reason,omitempty"`
}

func (*MsgFulfilKeyRequest_Key) isMsgFulfilKeyRequest_Result()          {}
func (*MsgFulfilKeyRequest_RejectReason) isMsgFulfilKeyRequest_Result() {}

func (m *MsgFulfilKeyRequest) GetResult() isMsgFulfilKeyRequest_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *MsgFulfilKeyRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgFulfilKeyRequest) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *MsgFulfilKeyRequest) GetStatus() KeyRequestStatus {
	if m != nil {
		return m.Status
	}
	return KeyRequestStatus_KEY_REQUEST_STATUS_UNSPECIFIED
}

func (m *MsgFulfilKeyRequest) GetKey() *MsgNewKey {
	if x, ok := m.GetResult().(*MsgFulfilKeyRequest_Key); ok {
		return x.Key
	}
	return nil
}

func (m *MsgFulfilKeyRequest) GetRejectReason() string {
	if x, ok := m.GetResult().(*MsgFulfilKeyRequest_RejectReason); ok {
		return x.RejectReason
	}
	return ""
}

func (m *MsgFulfilKeyRequest) GetKeyringPartySignature() []byte {
	if m != nil {
		return m.KeyringPartySignature
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgFulfilKeyRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgFulfilKeyRequest_Key)(nil),
		(*MsgFulfilKeyRequest_RejectReason)(nil),
	}
}

// MsgNewKey defines the attributes of a key
type MsgNewKey struct {
	PublicKey []byte `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
}

func (m *MsgNewKey) Reset()         { *m = MsgNewKey{} }
func (m *MsgNewKey) String() string { return proto.CompactTextString(m) }
func (*MsgNewKey) ProtoMessage()    {}
func (*MsgNewKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{5}
}
func (m *MsgNewKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewKey.Merge(m, src)
}
func (m *MsgNewKey) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewKey) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewKey.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewKey proto.InternalMessageInfo

func (m *MsgNewKey) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// MsgNewKeyRequestResponse defines the response structure for executing a
// MsgNewKeyRequest message.
type MsgFulfilKeyRequestResponse struct {
}

func (m *MsgFulfilKeyRequestResponse) Reset()         { *m = MsgFulfilKeyRequestResponse{} }
func (m *MsgFulfilKeyRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFulfilKeyRequestResponse) ProtoMessage()    {}
func (*MsgFulfilKeyRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{6}
}
func (m *MsgFulfilKeyRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfilKeyRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfilKeyRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfilKeyRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfilKeyRequestResponse.Merge(m, src)
}
func (m *MsgFulfilKeyRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfilKeyRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfilKeyRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfilKeyRequestResponse proto.InternalMessageInfo

// MsgNewSignatureRequest is the Msg/NewSignatureRequest request type.
type MsgNewSignatureRequest struct {
	Creator                  string              `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	KeyId                    uint64              `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	DataForSigning           string              `protobuf:"bytes,3,opt,name=data_for_signing,json=dataForSigning,proto3" json:"data_for_signing,omitempty"`
	Btl                      uint64              `protobuf:"varint,4,opt,name=btl,proto3" json:"btl,omitempty"`
	CacheId                  []byte              `protobuf:"bytes,5,opt,name=cache_id,json=cacheId,proto3" json:"cache_id,omitempty"`
	VerifySigningData        []byte              `protobuf:"bytes,6,opt,name=verify_signing_data,json=verifySigningData,proto3" json:"verify_signing_data,omitempty"`
	VerifySigningDataVersion VerificationVersion `protobuf:"varint,7,opt,name=verify_signing_data_version,json=verifySigningDataVersion,proto3,enum=zrchain.treasury.VerificationVersion" json:"verify_signing_data_version,omitempty"`
}

func (m *MsgNewSignatureRequest) Reset()         { *m = MsgNewSignatureRequest{} }
func (m *MsgNewSignatureRequest) String() string { return proto.CompactTextString(m) }
func (*MsgNewSignatureRequest) ProtoMessage()    {}
func (*MsgNewSignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{7}
}
func (m *MsgNewSignatureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewSignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewSignatureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewSignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewSignatureRequest.Merge(m, src)
}
func (m *MsgNewSignatureRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewSignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewSignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewSignatureRequest proto.InternalMessageInfo

func (m *MsgNewSignatureRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgNewSignatureRequest) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MsgNewSignatureRequest) GetDataForSigning() string {
	if m != nil {
		return m.DataForSigning
	}
	return ""
}

func (m *MsgNewSignatureRequest) GetBtl() uint64 {
	if m != nil {
		return m.Btl
	}
	return 0
}

func (m *MsgNewSignatureRequest) GetCacheId() []byte {
	if m != nil {
		return m.CacheId
	}
	return nil
}

func (m *MsgNewSignatureRequest) GetVerifySigningData() []byte {
	if m != nil {
		return m.VerifySigningData
	}
	return nil
}

func (m *MsgNewSignatureRequest) GetVerifySigningDataVersion() VerificationVersion {
	if m != nil {
		return m.VerifySigningDataVersion
	}
	return VerificationVersion_UNKNOWN
}

// MsgNewKeyRequestResponse defines the response structure for executing a
// MsgNewKeyRequest message.
type MsgNewSignatureRequestResponse struct {
	SigReqId uint64 `protobuf:"varint,1,opt,name=sig_req_id,json=sigReqId,proto3" json:"sig_req_id,omitempty"`
}

func (m *MsgNewSignatureRequestResponse) Reset()         { *m = MsgNewSignatureRequestResponse{} }
func (m *MsgNewSignatureRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgNewSignatureRequestResponse) ProtoMessage()    {}
func (*MsgNewSignatureRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{8}
}
func (m *MsgNewSignatureRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewSignatureRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewSignatureRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewSignatureRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewSignatureRequestResponse.Merge(m, src)
}
func (m *MsgNewSignatureRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewSignatureRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewSignatureRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewSignatureRequestResponse proto.InternalMessageInfo

func (m *MsgNewSignatureRequestResponse) GetSigReqId() uint64 {
	if m != nil {
		return m.SigReqId
	}
	return 0
}

// MsgFulfilSignatureRequest is the Msg/NewSignatureRequest request type.
type MsgFulfilSignatureRequest struct {
	Creator               string            `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	RequestId             uint64            `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Status                SignRequestStatus `protobuf:"varint,3,opt,name=status,proto3,enum=zrchain.treasury.SignRequestStatus" json:"status,omitempty"`
	KeyringPartySignature []byte            `protobuf:"bytes,4,opt,name=keyring_party_signature,json=keyringPartySignature,proto3" json:"keyring_party_signature,omitempty"`
	SignedData            []byte            `protobuf:"bytes,5,opt,name=signed_data,json=signedData,proto3" json:"signed_data,omitempty"`
	RejectReason          string            `protobuf:"bytes,6,opt,name=reject_reason,json=rejectReason,proto3" json:"reject_reason,omitempty"`
}

func (m *MsgFulfilSignatureRequest) Reset()         { *m = MsgFulfilSignatureRequest{} }
func (m *MsgFulfilSignatureRequest) String() string { return proto.CompactTextString(m) }
func (*MsgFulfilSignatureRequest) ProtoMessage()    {}
func (*MsgFulfilSignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{9}
}
func (m *MsgFulfilSignatureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfilSignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfilSignatureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfilSignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfilSignatureRequest.Merge(m, src)
}
func (m *MsgFulfilSignatureRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfilSignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfilSignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfilSignatureRequest proto.InternalMessageInfo

func (m *MsgFulfilSignatureRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgFulfilSignatureRequest) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *MsgFulfilSignatureRequest) GetStatus() SignRequestStatus {
	if m != nil {
		return m.Status
	}
	return SignRequestStatus_SIGN_REQUEST_STATUS_UNSPECIFIED
}

func (m *MsgFulfilSignatureRequest) GetKeyringPartySignature() []byte {
	if m != nil {
		return m.KeyringPartySignature
	}
	return nil
}

func (m *MsgFulfilSignatureRequest) GetSignedData() []byte {
	if m != nil {
		return m.SignedData
	}
	return nil
}

func (m *MsgFulfilSignatureRequest) GetRejectReason() string {
	if m != nil {
		return m.RejectReason
	}
	return ""
}

// MsgFulfilSignatureRequestResponse defines the response structure for
// executing a MsgFulfilSignatureRequest message.
type MsgFulfilSignatureRequestResponse struct {
}

func (m *MsgFulfilSignatureRequestResponse) Reset()         { *m = MsgFulfilSignatureRequestResponse{} }
func (m *MsgFulfilSignatureRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFulfilSignatureRequestResponse) ProtoMessage()    {}
func (*MsgFulfilSignatureRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{10}
}
func (m *MsgFulfilSignatureRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfilSignatureRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfilSignatureRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfilSignatureRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfilSignatureRequestResponse.Merge(m, src)
}
func (m *MsgFulfilSignatureRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfilSignatureRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfilSignatureRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfilSignatureRequestResponse proto.InternalMessageInfo

// MetadataEthereum defines the chain id
type MetadataEthereum struct {
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *MetadataEthereum) Reset()         { *m = MetadataEthereum{} }
func (m *MetadataEthereum) String() string { return proto.CompactTextString(m) }
func (*MetadataEthereum) ProtoMessage()    {}
func (*MetadataEthereum) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{11}
}
func (m *MetadataEthereum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataEthereum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataEthereum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataEthereum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataEthereum.Merge(m, src)
}
func (m *MetadataEthereum) XXX_Size() int {
	return m.Size()
}
func (m *MetadataEthereum) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataEthereum.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataEthereum proto.InternalMessageInfo

func (m *MetadataEthereum) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

// MetadataSolana defines the network (i.e. mainnet, devnet, testnet) for a given transaction
type MetadataSolana struct {
	Network SolanaNetworkType `protobuf:"varint,1,opt,name=network,proto3,enum=zrchain.treasury.SolanaNetworkType" json:"network,omitempty"`
}

func (m *MetadataSolana) Reset()         { *m = MetadataSolana{} }
func (m *MetadataSolana) String() string { return proto.CompactTextString(m) }
func (*MetadataSolana) ProtoMessage()    {}
func (*MetadataSolana) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{12}
}
func (m *MetadataSolana) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataSolana) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataSolana.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataSolana) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataSolana.Merge(m, src)
}
func (m *MetadataSolana) XXX_Size() int {
	return m.Size()
}
func (m *MetadataSolana) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataSolana.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataSolana proto.InternalMessageInfo

func (m *MetadataSolana) GetNetwork() SolanaNetworkType {
	if m != nil {
		return m.Network
	}
	return SolanaNetworkType_UNDEFINED
}

// MsgNewSignTransactionRequest is the Msg/NewSignTransactionRequest request
// type.
type MsgNewSignTransactionRequest struct {
	Creator             string     `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	KeyId               uint64     `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	WalletType          WalletType `protobuf:"varint,3,opt,name=wallet_type,json=walletType,proto3,enum=zrchain.treasury.WalletType" json:"wallet_type,omitempty"`
	UnsignedTransaction []byte     `protobuf:"bytes,4,opt,name=unsigned_transaction,json=unsignedTransaction,proto3" json:"unsigned_transaction,omitempty"`
	// Additional metadata required when parsing the unsigned transaction.
	Metadata    *types.Any `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Btl         uint64     `protobuf:"varint,6,opt,name=btl,proto3" json:"btl,omitempty"`
	CacheId     []byte     `protobuf:"bytes,7,opt,name=cache_id,json=cacheId,proto3" json:"cache_id,omitempty"`
	NoBroadcast bool       `protobuf:"varint,8,opt,name=no_broadcast,json=noBroadcast,proto3" json:"no_broadcast,omitempty"`
}

func (m *MsgNewSignTransactionRequest) Reset()         { *m = MsgNewSignTransactionRequest{} }
func (m *MsgNewSignTransactionRequest) String() string { return proto.CompactTextString(m) }
func (*MsgNewSignTransactionRequest) ProtoMessage()    {}
func (*MsgNewSignTransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{13}
}
func (m *MsgNewSignTransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewSignTransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewSignTransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewSignTransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewSignTransactionRequest.Merge(m, src)
}
func (m *MsgNewSignTransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewSignTransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewSignTransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewSignTransactionRequest proto.InternalMessageInfo

func (m *MsgNewSignTransactionRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgNewSignTransactionRequest) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MsgNewSignTransactionRequest) GetWalletType() WalletType {
	if m != nil {
		return m.WalletType
	}
	return WalletType_WALLET_TYPE_UNSPECIFIED
}

func (m *MsgNewSignTransactionRequest) GetUnsignedTransaction() []byte {
	if m != nil {
		return m.UnsignedTransaction
	}
	return nil
}

func (m *MsgNewSignTransactionRequest) GetMetadata() *types.Any {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *MsgNewSignTransactionRequest) GetBtl() uint64 {
	if m != nil {
		return m.Btl
	}
	return 0
}

func (m *MsgNewSignTransactionRequest) GetCacheId() []byte {
	if m != nil {
		return m.CacheId
	}
	return nil
}

func (m *MsgNewSignTransactionRequest) GetNoBroadcast() bool {
	if m != nil {
		return m.NoBroadcast
	}
	return false
}

// MsgNewSignTransactionRequestResponse defines the response structure for
// executing a MsgNewSignTransactionRequest message.
type MsgNewSignTransactionRequestResponse struct {
	Id                 uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SignatureRequestId uint64 `protobuf:"varint,2,opt,name=signature_request_id,json=signatureRequestId,proto3" json:"signature_request_id,omitempty"`
}

func (m *MsgNewSignTransactionRequestResponse) Reset()         { *m = MsgNewSignTransactionRequestResponse{} }
func (m *MsgNewSignTransactionRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgNewSignTransactionRequestResponse) ProtoMessage()    {}
func (*MsgNewSignTransactionRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{14}
}
func (m *MsgNewSignTransactionRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewSignTransactionRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewSignTransactionRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewSignTransactionRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewSignTransactionRequestResponse.Merge(m, src)
}
func (m *MsgNewSignTransactionRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewSignTransactionRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewSignTransactionRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewSignTransactionRequestResponse proto.InternalMessageInfo

func (m *MsgNewSignTransactionRequestResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgNewSignTransactionRequestResponse) GetSignatureRequestId() uint64 {
	if m != nil {
		return m.SignatureRequestId
	}
	return 0
}

// MsgTransferFromKeyring is the Msg/TransferFromKeyring request type.
type MsgTransferFromKeyring struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Keyring   string `protobuf:"bytes,2,opt,name=keyring,proto3" json:"keyring,omitempty"`
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	Amount    uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
	Denom     string `protobuf:"bytes,5,opt,name=denom,proto3" json:"denom,omitempty"`
}

func (m *MsgTransferFromKeyring) Reset()         { *m = MsgTransferFromKeyring{} }
func (m *MsgTransferFromKeyring) String() string { return proto.CompactTextString(m) }
func (*MsgTransferFromKeyring) ProtoMessage()    {}
func (*MsgTransferFromKeyring) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{15}
}
func (m *MsgTransferFromKeyring) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferFromKeyring) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferFromKeyring.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferFromKeyring) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferFromKeyring.Merge(m, src)
}
func (m *MsgTransferFromKeyring) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferFromKeyring) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferFromKeyring.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferFromKeyring proto.InternalMessageInfo

func (m *MsgTransferFromKeyring) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgTransferFromKeyring) GetKeyring() string {
	if m != nil {
		return m.Keyring
	}
	return ""
}

func (m *MsgTransferFromKeyring) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgTransferFromKeyring) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MsgTransferFromKeyring) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

// MsgTransferFromKeyringResponse defines the response structure for executing a
// MsgTransferFromKeyring message.
type MsgTransferFromKeyringResponse struct {
}

func (m *MsgTransferFromKeyringResponse) Reset()         { *m = MsgTransferFromKeyringResponse{} }
func (m *MsgTransferFromKeyringResponse) String() string { return proto.CompactTextString(m) }
func (*MsgTransferFromKeyringResponse) ProtoMessage()    {}
func (*MsgTransferFromKeyringResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{16}
}
func (m *MsgTransferFromKeyringResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgTransferFromKeyringResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgTransferFromKeyringResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgTransferFromKeyringResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgTransferFromKeyringResponse.Merge(m, src)
}
func (m *MsgTransferFromKeyringResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgTransferFromKeyringResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgTransferFromKeyringResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgTransferFromKeyringResponse proto.InternalMessageInfo

// ---------------------
//
//	INTERCHAIN ACCOUNTS
//
// ---------------------
//
// MsgNewICATransactionRequest is the Msg/NewIcaTransactionRequest request type.
type MsgNewICATransactionRequest struct {
	Creator                  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	KeyId                    uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	InputPayload             string `protobuf:"bytes,3,opt,name=input_payload,json=inputPayload,proto3" json:"input_payload,omitempty"`
	ConnectionId             string `protobuf:"bytes,4,opt,name=connection_id,json=connectionId,proto3" json:"connection_id,omitempty"`
	RelativeTimeoutTimestamp uint64 `protobuf:"varint,5,opt,name=relative_timeout_timestamp,json=relativeTimeoutTimestamp,proto3" json:"relative_timeout_timestamp,omitempty"`
	Btl                      uint64 `protobuf:"varint,6,opt,name=btl,proto3" json:"btl,omitempty"`
}

func (m *MsgNewICATransactionRequest) Reset()         { *m = MsgNewICATransactionRequest{} }
func (m *MsgNewICATransactionRequest) String() string { return proto.CompactTextString(m) }
func (*MsgNewICATransactionRequest) ProtoMessage()    {}
func (*MsgNewICATransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{17}
}
func (m *MsgNewICATransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewICATransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewICATransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewICATransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewICATransactionRequest.Merge(m, src)
}
func (m *MsgNewICATransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewICATransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewICATransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewICATransactionRequest proto.InternalMessageInfo

func (m *MsgNewICATransactionRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgNewICATransactionRequest) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MsgNewICATransactionRequest) GetInputPayload() string {
	if m != nil {
		return m.InputPayload
	}
	return ""
}

func (m *MsgNewICATransactionRequest) GetConnectionId() string {
	if m != nil {
		return m.ConnectionId
	}
	return ""
}

func (m *MsgNewICATransactionRequest) GetRelativeTimeoutTimestamp() uint64 {
	if m != nil {
		return m.RelativeTimeoutTimestamp
	}
	return 0
}

func (m *MsgNewICATransactionRequest) GetBtl() uint64 {
	if m != nil {
		return m.Btl
	}
	return 0
}

// MsgNewICATransactionRequestResponse defines the response structure for
// executing a MsgNewICATransactionRequest message.
type MsgNewICATransactionRequestResponse struct {
	Id                 uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SignatureRequestId uint64 `protobuf:"varint,2,opt,name=signature_request_id,json=signatureRequestId,proto3" json:"signature_request_id,omitempty"`
}

func (m *MsgNewICATransactionRequestResponse) Reset()         { *m = MsgNewICATransactionRequestResponse{} }
func (m *MsgNewICATransactionRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgNewICATransactionRequestResponse) ProtoMessage()    {}
func (*MsgNewICATransactionRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{18}
}
func (m *MsgNewICATransactionRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewICATransactionRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewICATransactionRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewICATransactionRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewICATransactionRequestResponse.Merge(m, src)
}
func (m *MsgNewICATransactionRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewICATransactionRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewICATransactionRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewICATransactionRequestResponse proto.InternalMessageInfo

func (m *MsgNewICATransactionRequestResponse) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MsgNewICATransactionRequestResponse) GetSignatureRequestId() uint64 {
	if m != nil {
		return m.SignatureRequestId
	}
	return 0
}

// MsgFulfilICATransactionRequest is the Msg/FulfilICATransactionRequest request
// type.
type MsgFulfilICATransactionRequest struct {
	Creator               string            `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	RequestId             uint64            `protobuf:"varint,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Status                SignRequestStatus `protobuf:"varint,3,opt,name=status,proto3,enum=zrchain.treasury.SignRequestStatus" json:"status,omitempty"`
	KeyringPartySignature []byte            `protobuf:"bytes,4,opt,name=keyring_party_signature,json=keyringPartySignature,proto3" json:"keyring_party_signature,omitempty"`
	SignedData            []byte            `protobuf:"bytes,5,opt,name=signed_data,json=signedData,proto3" json:"signed_data,omitempty"`
	RejectReason          string            `protobuf:"bytes,6,opt,name=reject_reason,json=rejectReason,proto3" json:"reject_reason,omitempty"`
}

func (m *MsgFulfilICATransactionRequest) Reset()         { *m = MsgFulfilICATransactionRequest{} }
func (m *MsgFulfilICATransactionRequest) String() string { return proto.CompactTextString(m) }
func (*MsgFulfilICATransactionRequest) ProtoMessage()    {}
func (*MsgFulfilICATransactionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{19}
}
func (m *MsgFulfilICATransactionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfilICATransactionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfilICATransactionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfilICATransactionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfilICATransactionRequest.Merge(m, src)
}
func (m *MsgFulfilICATransactionRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfilICATransactionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfilICATransactionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfilICATransactionRequest proto.InternalMessageInfo

func (m *MsgFulfilICATransactionRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgFulfilICATransactionRequest) GetRequestId() uint64 {
	if m != nil {
		return m.RequestId
	}
	return 0
}

func (m *MsgFulfilICATransactionRequest) GetStatus() SignRequestStatus {
	if m != nil {
		return m.Status
	}
	return SignRequestStatus_SIGN_REQUEST_STATUS_UNSPECIFIED
}

func (m *MsgFulfilICATransactionRequest) GetKeyringPartySignature() []byte {
	if m != nil {
		return m.KeyringPartySignature
	}
	return nil
}

func (m *MsgFulfilICATransactionRequest) GetSignedData() []byte {
	if m != nil {
		return m.SignedData
	}
	return nil
}

func (m *MsgFulfilICATransactionRequest) GetRejectReason() string {
	if m != nil {
		return m.RejectReason
	}
	return ""
}

// MsgFulfilICATransactionRequestResponse defines the response structure for
// executing a MsgFulfilICATransactionRequest message.
type MsgFulfilICATransactionRequestResponse struct {
}

func (m *MsgFulfilICATransactionRequestResponse) Reset() {
	*m = MsgFulfilICATransactionRequestResponse{}
}
func (m *MsgFulfilICATransactionRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFulfilICATransactionRequestResponse) ProtoMessage()    {}
func (*MsgFulfilICATransactionRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{20}
}
func (m *MsgFulfilICATransactionRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFulfilICATransactionRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFulfilICATransactionRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFulfilICATransactionRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFulfilICATransactionRequestResponse.Merge(m, src)
}
func (m *MsgFulfilICATransactionRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFulfilICATransactionRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFulfilICATransactionRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFulfilICATransactionRequestResponse proto.InternalMessageInfo

type MsgNewZrSignSignatureRequest struct {
	Creator                  string              `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Address                  string              `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	KeyType                  uint64              `protobuf:"varint,3,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	WalletIndex              uint64              `protobuf:"varint,4,opt,name=wallet_index,json=walletIndex,proto3" json:"wallet_index,omitempty"`
	CacheId                  []byte              `protobuf:"bytes,5,opt,name=cache_id,json=cacheId,proto3" json:"cache_id,omitempty"`
	Data                     string              `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	VerifySigningData        []byte              `protobuf:"bytes,7,opt,name=verify_signing_data,json=verifySigningData,proto3" json:"verify_signing_data,omitempty"`
	VerifySigningDataVersion VerificationVersion `protobuf:"varint,8,opt,name=verify_signing_data_version,json=verifySigningDataVersion,proto3,enum=zrchain.treasury.VerificationVersion" json:"verify_signing_data_version,omitempty"`
	WalletType               WalletType          `protobuf:"varint,9,opt,name=wallet_type,json=walletType,proto3,enum=zrchain.treasury.WalletType" json:"wallet_type,omitempty"`
	Metadata                 *types.Any          `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
	NoBroadcast              bool                `protobuf:"varint,11,opt,name=no_broadcast,json=noBroadcast,proto3" json:"no_broadcast,omitempty"`
	Btl                      uint64              `protobuf:"varint,12,opt,name=btl,proto3" json:"btl,omitempty"`
	Tx                       bool                `protobuf:"varint,13,opt,name=tx,proto3" json:"tx,omitempty"`
}

func (m *MsgNewZrSignSignatureRequest) Reset()         { *m = MsgNewZrSignSignatureRequest{} }
func (m *MsgNewZrSignSignatureRequest) String() string { return proto.CompactTextString(m) }
func (*MsgNewZrSignSignatureRequest) ProtoMessage()    {}
func (*MsgNewZrSignSignatureRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{21}
}
func (m *MsgNewZrSignSignatureRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewZrSignSignatureRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewZrSignSignatureRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewZrSignSignatureRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewZrSignSignatureRequest.Merge(m, src)
}
func (m *MsgNewZrSignSignatureRequest) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewZrSignSignatureRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewZrSignSignatureRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewZrSignSignatureRequest proto.InternalMessageInfo

func (m *MsgNewZrSignSignatureRequest) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgNewZrSignSignatureRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *MsgNewZrSignSignatureRequest) GetKeyType() uint64 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

func (m *MsgNewZrSignSignatureRequest) GetWalletIndex() uint64 {
	if m != nil {
		return m.WalletIndex
	}
	return 0
}

func (m *MsgNewZrSignSignatureRequest) GetCacheId() []byte {
	if m != nil {
		return m.CacheId
	}
	return nil
}

func (m *MsgNewZrSignSignatureRequest) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *MsgNewZrSignSignatureRequest) GetVerifySigningData() []byte {
	if m != nil {
		return m.VerifySigningData
	}
	return nil
}

func (m *MsgNewZrSignSignatureRequest) GetVerifySigningDataVersion() VerificationVersion {
	if m != nil {
		return m.VerifySigningDataVersion
	}
	return VerificationVersion_UNKNOWN
}

func (m *MsgNewZrSignSignatureRequest) GetWalletType() WalletType {
	if m != nil {
		return m.WalletType
	}
	return WalletType_WALLET_TYPE_UNSPECIFIED
}

func (m *MsgNewZrSignSignatureRequest) GetMetadata() *types.Any {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *MsgNewZrSignSignatureRequest) GetNoBroadcast() bool {
	if m != nil {
		return m.NoBroadcast
	}
	return false
}

func (m *MsgNewZrSignSignatureRequest) GetBtl() uint64 {
	if m != nil {
		return m.Btl
	}
	return 0
}

func (m *MsgNewZrSignSignatureRequest) GetTx() bool {
	if m != nil {
		return m.Tx
	}
	return false
}

type MsgNewZrSignSignatureRequestResponse struct {
	ReqId uint64 `protobuf:"varint,1,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty"`
}

func (m *MsgNewZrSignSignatureRequestResponse) Reset()         { *m = MsgNewZrSignSignatureRequestResponse{} }
func (m *MsgNewZrSignSignatureRequestResponse) String() string { return proto.CompactTextString(m) }
func (*MsgNewZrSignSignatureRequestResponse) ProtoMessage()    {}
func (*MsgNewZrSignSignatureRequestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{22}
}
func (m *MsgNewZrSignSignatureRequestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgNewZrSignSignatureRequestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgNewZrSignSignatureRequestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgNewZrSignSignatureRequestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgNewZrSignSignatureRequestResponse.Merge(m, src)
}
func (m *MsgNewZrSignSignatureRequestResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgNewZrSignSignatureRequestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgNewZrSignSignatureRequestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgNewZrSignSignatureRequestResponse proto.InternalMessageInfo

func (m *MsgNewZrSignSignatureRequestResponse) GetReqId() uint64 {
	if m != nil {
		return m.ReqId
	}
	return 0
}

type MsgUpdateKeyPolicy struct {
	Creator      string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	KeyId        uint64 `protobuf:"varint,2,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	SignPolicyId uint64 `protobuf:"varint,3,opt,name=sign_policy_id,json=signPolicyId,proto3" json:"sign_policy_id,omitempty"`
}

func (m *MsgUpdateKeyPolicy) Reset()         { *m = MsgUpdateKeyPolicy{} }
func (m *MsgUpdateKeyPolicy) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateKeyPolicy) ProtoMessage()    {}
func (*MsgUpdateKeyPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{23}
}
func (m *MsgUpdateKeyPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateKeyPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateKeyPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateKeyPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateKeyPolicy.Merge(m, src)
}
func (m *MsgUpdateKeyPolicy) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateKeyPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateKeyPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateKeyPolicy proto.InternalMessageInfo

func (m *MsgUpdateKeyPolicy) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateKeyPolicy) GetKeyId() uint64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *MsgUpdateKeyPolicy) GetSignPolicyId() uint64 {
	if m != nil {
		return m.SignPolicyId
	}
	return 0
}

type MsgUpdateKeyPolicyResponse struct {
}

func (m *MsgUpdateKeyPolicyResponse) Reset()         { *m = MsgUpdateKeyPolicyResponse{} }
func (m *MsgUpdateKeyPolicyResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateKeyPolicyResponse) ProtoMessage()    {}
func (*MsgUpdateKeyPolicyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a647f4f7f3768f2, []int{24}
}
func (m *MsgUpdateKeyPolicyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateKeyPolicyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateKeyPolicyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateKeyPolicyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateKeyPolicyResponse.Merge(m, src)
}
func (m *MsgUpdateKeyPolicyResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateKeyPolicyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateKeyPolicyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateKeyPolicyResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("zrchain.treasury.VerificationVersion", VerificationVersion_name, VerificationVersion_value)
	proto.RegisterEnum("zrchain.treasury.SolanaNetworkType", SolanaNetworkType_name, SolanaNetworkType_value)
	proto.RegisterType((*MsgUpdateParams)(nil), "zrchain.treasury.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "zrchain.treasury.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgNewKeyRequest)(nil), "zrchain.treasury.MsgNewKeyRequest")
	proto.RegisterType((*MsgNewKeyRequestResponse)(nil), "zrchain.treasury.MsgNewKeyRequestResponse")
	proto.RegisterType((*MsgFulfilKeyRequest)(nil), "zrchain.treasury.MsgFulfilKeyRequest")
	proto.RegisterType((*MsgNewKey)(nil), "zrchain.treasury.MsgNewKey")
	proto.RegisterType((*MsgFulfilKeyRequestResponse)(nil), "zrchain.treasury.MsgFulfilKeyRequestResponse")
	proto.RegisterType((*MsgNewSignatureRequest)(nil), "zrchain.treasury.MsgNewSignatureRequest")
	proto.RegisterType((*MsgNewSignatureRequestResponse)(nil), "zrchain.treasury.MsgNewSignatureRequestResponse")
	proto.RegisterType((*MsgFulfilSignatureRequest)(nil), "zrchain.treasury.MsgFulfilSignatureRequest")
	proto.RegisterType((*MsgFulfilSignatureRequestResponse)(nil), "zrchain.treasury.MsgFulfilSignatureRequestResponse")
	proto.RegisterType((*MetadataEthereum)(nil), "zrchain.treasury.MetadataEthereum")
	proto.RegisterType((*MetadataSolana)(nil), "zrchain.treasury.MetadataSolana")
	proto.RegisterType((*MsgNewSignTransactionRequest)(nil), "zrchain.treasury.MsgNewSignTransactionRequest")
	proto.RegisterType((*MsgNewSignTransactionRequestResponse)(nil), "zrchain.treasury.MsgNewSignTransactionRequestResponse")
	proto.RegisterType((*MsgTransferFromKeyring)(nil), "zrchain.treasury.MsgTransferFromKeyring")
	proto.RegisterType((*MsgTransferFromKeyringResponse)(nil), "zrchain.treasury.MsgTransferFromKeyringResponse")
	proto.RegisterType((*MsgNewICATransactionRequest)(nil), "zrchain.treasury.MsgNewICATransactionRequest")
	proto.RegisterType((*MsgNewICATransactionRequestResponse)(nil), "zrchain.treasury.MsgNewICATransactionRequestResponse")
	proto.RegisterType((*MsgFulfilICATransactionRequest)(nil), "zrchain.treasury.MsgFulfilICATransactionRequest")
	proto.RegisterType((*MsgFulfilICATransactionRequestResponse)(nil), "zrchain.treasury.MsgFulfilICATransactionRequestResponse")
	proto.RegisterType((*MsgNewZrSignSignatureRequest)(nil), "zrchain.treasury.MsgNewZrSignSignatureRequest")
	proto.RegisterType((*MsgNewZrSignSignatureRequestResponse)(nil), "zrchain.treasury.MsgNewZrSignSignatureRequestResponse")
	proto.RegisterType((*MsgUpdateKeyPolicy)(nil), "zrchain.treasury.MsgUpdateKeyPolicy")
	proto.RegisterType((*MsgUpdateKeyPolicyResponse)(nil), "zrchain.treasury.MsgUpdateKeyPolicyResponse")
}

func init() { proto.RegisterFile("zrchain/treasury/tx.proto", fileDescriptor_2a647f4f7f3768f2) }

var fileDescriptor_2a647f4f7f3768f2 = []byte{
	// 1816 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4f, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0x65, 0x5b, 0xb2, 0x9e, 0x65, 0x45, 0x19, 0x3b, 0x09, 0xad, 0x38, 0x8e, 0x2d, 0x27,
	0x85, 0xeb, 0xd6, 0x52, 0xd6, 0xdb, 0x0d, 0xb6, 0xd9, 0xa6, 0x40, 0x9c, 0xd8, 0x88, 0xe0, 0x5a,
	0x31, 0x68, 0x25, 0x0b, 0x04, 0x05, 0x88, 0x31, 0x39, 0x96, 0x59, 0x4b, 0xa4, 0x32, 0x1c, 0xda,
	0x62, 0x4e, 0x8b, 0xf6, 0xd4, 0x9e, 0x7a, 0xdd, 0x43, 0x2f, 0x3d, 0x14, 0x3d, 0x06, 0x45, 0x3f,
	0x42, 0x0f, 0x7b, 0xdc, 0xf6, 0xd4, 0x53, 0x50, 0x24, 0x87, 0x7c, 0x83, 0x1e, 0x8b, 0x62, 0x66,
	0x48, 0xca, 0x26, 0x29, 0xd9, 0x0a, 0x72, 0xdb, 0x8b, 0xcd, 0x79, 0xef, 0x37, 0xf3, 0xfe, 0xbf,
	0x79, 0x23, 0x98, 0x7f, 0x4d, 0x8d, 0x23, 0x6c, 0xd9, 0x35, 0x46, 0x09, 0x76, 0x3d, 0xea, 0xd7,
	0x58, 0xaf, 0xda, 0xa5, 0x0e, 0x73, 0x50, 0x29, 0x60, 0x55, 0x43, 0x56, 0xf9, 0x2a, 0xee, 0x58,
	0xb6, 0x53, 0x13, 0x7f, 0x25, 0xa8, 0x7c, 0xc3, 0x70, 0xdc, 0x8e, 0xe3, 0xd6, 0x3a, 0x6e, 0xab,
	0x76, 0xf2, 0x19, 0xff, 0x17, 0x30, 0xe6, 0x25, 0x43, 0x17, 0xab, 0x9a, 0x5c, 0x04, 0xac, 0xb9,
	0x96, 0xd3, 0x72, 0x24, 0x9d, 0x7f, 0x85, 0x1b, 0x5a, 0x8e, 0xd3, 0x6a, 0x93, 0x9a, 0x58, 0x1d,
	0x78, 0x87, 0x35, 0x6c, 0xfb, 0x01, 0xab, 0x9c, 0x50, 0xf2, 0x98, 0x84, 0xbc, 0xc5, 0x04, 0xaf,
	0xd3, 0x35, 0x5c, 0xab, 0x65, 0x07, 0xfc, 0x5b, 0x09, 0x7e, 0x17, 0x53, 0xdc, 0x71, 0x07, 0xb2,
	0x4f, 0x71, 0xbb, 0x4d, 0x98, 0x64, 0x57, 0xde, 0x2a, 0x70, 0x65, 0xd7, 0x6d, 0x3d, 0xef, 0x9a,
	0x98, 0x91, 0x3d, 0xb1, 0x11, 0xdd, 0x87, 0x3c, 0xf6, 0xd8, 0x91, 0x43, 0x2d, 0xe6, 0xab, 0xca,
	0x92, 0xb2, 0x9a, 0xdf, 0x54, 0xff, 0xf5, 0xf7, 0xf5, 0xb9, 0xc0, 0xc6, 0x47, 0xa6, 0x49, 0x89,
	0xeb, 0xee, 0x33, 0x6a, 0xd9, 0x2d, 0xad, 0x0f, 0x45, 0x5f, 0x41, 0x56, 0x8a, 0x56, 0x33, 0x4b,
	0xca, 0xea, 0xf4, 0x86, 0x5a, 0x8d, 0x3b, 0xb8, 0x2a, 0x25, 0x6c, 0xe6, 0xbf, 0x7b, 0x7b, 0x7b,
	0xec, 0xaf, 0x1f, 0xde, 0xac, 0x29, 0x5a, 0xb0, 0xe5, 0xc1, 0x8b, 0xdf, 0x7e, 0x78, 0xb3, 0xd6,
	0x3f, 0xec, 0x0f, 0x1f, 0xde, 0xac, 0x3d, 0x6e, 0x59, 0xec, 0xc8, 0x3b, 0xa8, 0x1a, 0x4e, 0xa7,
	0xf6, 0x92, 0xd8, 0xd4, 0x31, 0x8e, 0xd7, 0xb7, 0x1d, 0xcf, 0x36, 0x31, 0xb3, 0x1c, 0xbb, 0x16,
	0x1a, 0x76, 0xf2, 0x45, 0xad, 0xd7, 0xb7, 0x2e, 0x66, 0x4c, 0x65, 0x1e, 0x6e, 0xc4, 0x48, 0x1a,
	0x71, 0xbb, 0x8e, 0xed, 0x92, 0xca, 0xff, 0x32, 0x50, 0xda, 0x75, 0x5b, 0x0d, 0x72, 0xba, 0x43,
	0x7c, 0x8d, 0xbc, 0xf2, 0x88, 0xcb, 0x90, 0x0a, 0x39, 0x83, 0x12, 0xcc, 0x1c, 0x2a, 0x4d, 0xd7,
	0xc2, 0x25, 0xba, 0x0b, 0xc5, 0x53, 0x87, 0x1e, 0xbb, 0x5d, 0x6c, 0x10, 0x1d, 0x9b, 0x26, 0x15,
	0x66, 0xe6, 0xb5, 0x99, 0x88, 0xca, 0x3d, 0x83, 0x96, 0xa1, 0x70, 0x4c, 0x7c, 0xee, 0x1b, 0x09,
	0x1a, 0x17, 0xa0, 0xe9, 0x80, 0x26, 0x20, 0xf3, 0x30, 0x75, 0x4c, 0x7c, 0x9d, 0xf9, 0x5d, 0xa2,
	0x4e, 0x48, 0x21, 0xc7, 0xc4, 0x6f, 0xfa, 0x5d, 0x82, 0x4a, 0x30, 0x7e, 0xc0, 0xda, 0xea, 0xe4,
	0x92, 0xb2, 0x3a, 0xa1, 0xf1, 0x4f, 0x34, 0x07, 0x93, 0x96, 0x6d, 0x92, 0x9e, 0x9a, 0x15, 0x34,
	0xb9, 0x40, 0x2b, 0x30, 0x43, 0x7a, 0x4c, 0xa7, 0x52, 0x6b, 0x42, 0xd5, 0x9c, 0x38, 0xa7, 0x40,
	0x7a, 0x4c, 0x0b, 0x69, 0x68, 0x09, 0xf8, 0x5a, 0x8f, 0x64, 0x4d, 0x89, 0x13, 0x80, 0xf4, 0xd8,
	0x4e, 0x20, 0xee, 0x0e, 0x14, 0x79, 0x2a, 0xe9, 0x5d, 0xa7, 0x6d, 0x19, 0xbe, 0x6e, 0x99, 0x6a,
	0x5e, 0x60, 0x0a, 0x9c, 0xba, 0x27, 0x88, 0x75, 0x13, 0x3d, 0x85, 0x2b, 0xaf, 0x89, 0x7d, 0xc0,
	0x0c, 0xbd, 0x43, 0x18, 0x36, 0x31, 0xc3, 0x2a, 0x88, 0x08, 0xdf, 0x4e, 0x46, 0xf8, 0x25, 0xb1,
	0x37, 0x9b, 0x8f, 0x77, 0x09, 0xe3, 0x30, 0xad, 0x28, 0xf7, 0xed, 0x06, 0xdb, 0x1e, 0x14, 0x78,
	0x94, 0x43, 0x8f, 0x56, 0xbe, 0x04, 0x35, 0xee, 0xff, 0x30, 0x38, 0x68, 0x01, 0x80, 0xeb, 0x4d,
	0xc9, 0x2b, 0xae, 0x95, 0x22, 0xb4, 0xe2, 0x5e, 0xd3, 0xc8, 0xab, 0xba, 0x59, 0xf9, 0x5b, 0x06,
	0x66, 0x77, 0xdd, 0xd6, 0xb6, 0xd7, 0x3e, 0xb4, 0xda, 0x97, 0x8a, 0xde, 0x2d, 0x80, 0xc0, 0x59,
	0xfc, 0xbc, 0x8c, 0x38, 0x2f, 0x1f, 0x50, 0xea, 0x26, 0x7a, 0x00, 0x59, 0x97, 0x61, 0xe6, 0xb9,
	0x22, 0x5e, 0xc5, 0x8d, 0x4a, 0xd2, 0xb2, 0xbe, 0x98, 0x7d, 0x81, 0xd4, 0x82, 0x1d, 0xa8, 0x06,
	0xe3, 0xc7, 0xc4, 0x17, 0x91, 0x9c, 0xde, 0xb8, 0x99, 0xdc, 0x18, 0xd9, 0xf8, 0x74, 0x4c, 0xe3,
	0x48, 0x74, 0x17, 0x66, 0x28, 0xf9, 0x0d, 0x31, 0x78, 0xfc, 0xb0, 0xeb, 0xd8, 0x22, 0xdc, 0xf9,
	0xa7, 0x63, 0x5a, 0x41, 0x92, 0x35, 0x41, 0x45, 0xf7, 0xe1, 0x46, 0x98, 0x49, 0x5d, 0x4c, 0x99,
	0xaf, 0xf3, 0xa0, 0x60, 0xe6, 0x51, 0x22, 0x72, 0xa1, 0xa0, 0x5d, 0x0b, 0xd8, 0x7b, 0x9c, 0xbb,
	0x1f, 0x32, 0xcf, 0x3b, 0x79, 0x73, 0x0a, 0xb2, 0x94, 0xb8, 0x5e, 0x9b, 0x55, 0xd6, 0x20, 0x1f,
	0xa9, 0xc2, 0xfd, 0xd1, 0xf5, 0x0e, 0xda, 0x96, 0xc1, 0xd3, 0x43, 0x38, 0xab, 0xa0, 0xe5, 0x25,
	0x65, 0x87, 0xf8, 0x95, 0x5b, 0x70, 0x33, 0xc5, 0xbf, 0x51, 0xe9, 0xfc, 0x23, 0x03, 0xd7, 0xe5,
	0x59, 0x91, 0xd8, 0x8b, 0x43, 0x70, 0x0d, 0xb2, 0x3c, 0xa4, 0x91, 0xfb, 0x27, 0x8f, 0x09, 0xcf,
	0xae, 0x55, 0x28, 0xf1, 0xdc, 0xd0, 0x0f, 0x1d, 0x2a, 0x2c, 0xb4, 0xec, 0x56, 0x50, 0x34, 0x45,
	0x4e, 0xdf, 0x76, 0xe8, 0xbe, 0xa4, 0x86, 0xc5, 0x31, 0xd1, 0x2f, 0x8e, 0x79, 0x98, 0x32, 0xb0,
	0x71, 0x44, 0xf8, 0xa1, 0x93, 0xc2, 0x86, 0x9c, 0x58, 0xd7, 0x4d, 0x54, 0x85, 0xd9, 0x13, 0x42,
	0xad, 0x43, 0x3f, 0x3c, 0x54, 0x17, 0x89, 0x2b, 0x3d, 0x77, 0x55, 0xb2, 0x82, 0x83, 0x9f, 0x60,
	0x86, 0x91, 0x09, 0x37, 0x53, 0xf0, 0xfa, 0x09, 0xa1, 0xae, 0xe5, 0xd8, 0xa2, 0xbe, 0x8a, 0x1b,
	0x77, 0x93, 0xd1, 0x7d, 0xc1, 0x37, 0x59, 0x86, 0xe8, 0x49, 0x2f, 0x24, 0x58, 0x53, 0x13, 0xc7,
	0x07, 0x9c, 0x58, 0x01, 0xfc, 0x12, 0x16, 0xd3, 0xbd, 0x78, 0xb6, 0x0c, 0x5c, 0xab, 0x15, 0x2b,
	0x03, 0xd7, 0x6a, 0xc9, 0x32, 0xf8, 0x53, 0x06, 0xe6, 0xa3, 0x30, 0x8d, 0x10, 0x89, 0x0b, 0x8a,
	0xe1, 0xab, 0x58, 0x31, 0xac, 0x24, 0xad, 0xe6, 0xc2, 0xd2, 0xab, 0x61, 0x48, 0xd6, 0x4e, 0x0c,
	0xc9, 0x5a, 0x74, 0x1b, 0xa6, 0x39, 0x92, 0x98, 0x32, 0x4e, 0x32, 0x9a, 0x20, 0x49, 0x22, 0x40,
	0x2b, 0xf1, 0xaa, 0xc9, 0xca, 0x96, 0x77, 0xb6, 0x66, 0x62, 0xfe, 0x5d, 0x81, 0xe5, 0x81, 0xee,
	0x89, 0x72, 0x79, 0x1d, 0x4a, 0x61, 0x7f, 0xda, 0x62, 0x47, 0x84, 0x12, 0xaf, 0x23, 0xf2, 0x8a,
	0x1b, 0xdc, 0x77, 0x7a, 0x4e, 0xac, 0xeb, 0x66, 0xe5, 0x19, 0x14, 0x43, 0xf8, 0xbe, 0xd3, 0xc6,
	0x36, 0x46, 0x0f, 0x21, 0x67, 0x13, 0xc6, 0x6f, 0x01, 0x81, 0x4d, 0xf7, 0x97, 0x80, 0x36, 0x24,
	0x8c, 0xb7, 0x5e, 0x2d, 0xdc, 0x53, 0xf9, 0x67, 0x06, 0x16, 0xfa, 0x59, 0xd0, 0xa4, 0xd8, 0x76,
	0xb1, 0xc1, 0xb3, 0xe9, 0xa3, 0x2b, 0xea, 0x21, 0x4c, 0xcb, 0x4b, 0x5e, 0xb6, 0x7d, 0x19, 0xc4,
	0x85, 0xa4, 0x52, 0x5f, 0x0b, 0x90, 0xd0, 0x06, 0x4e, 0xa3, 0x6f, 0xf4, 0x19, 0xcc, 0x79, 0x76,
	0x10, 0x0b, 0xd6, 0x57, 0x27, 0x08, 0xdf, 0x6c, 0xc8, 0x3b, 0xa3, 0x29, 0xba, 0x07, 0x53, 0xd1,
	0xd5, 0x30, 0x29, 0xfa, 0xe0, 0x5c, 0x55, 0x8e, 0x3b, 0xd5, 0x70, 0xdc, 0xa9, 0x3e, 0xb2, 0x7d,
	0x2d, 0x42, 0x85, 0xb5, 0x9c, 0x4d, 0xaf, 0xe5, 0xdc, 0xf9, 0x5a, 0x5e, 0x86, 0x82, 0xed, 0xe8,
	0x07, 0xd4, 0xc1, 0xa6, 0x81, 0x5d, 0x26, 0x2e, 0xb2, 0x29, 0x6d, 0xda, 0x76, 0x36, 0x43, 0x52,
	0x2c, 0xf0, 0x47, 0x70, 0x67, 0x98, 0x4b, 0xa3, 0xf2, 0x2a, 0x42, 0x26, 0x8a, 0x70, 0xc6, 0x32,
	0xd1, 0x3d, 0x98, 0x8b, 0xd2, 0x55, 0x4f, 0x94, 0x08, 0x72, 0x63, 0x39, 0x54, 0x37, 0x2b, 0x7f,
	0x51, 0x44, 0x27, 0x14, 0x32, 0x0e, 0x09, 0xdd, 0xa6, 0x4e, 0x67, 0x47, 0xe6, 0xf7, 0x90, 0xb8,
	0xa9, 0x90, 0x0b, 0x8a, 0x20, 0x98, 0x21, 0xc2, 0x25, 0x5a, 0x80, 0x3c, 0x25, 0x86, 0xd5, 0xb5,
	0x88, 0xcd, 0x82, 0x2e, 0xd8, 0x27, 0xa0, 0xeb, 0x90, 0xc5, 0x1d, 0xc7, 0xb3, 0x59, 0xd0, 0x03,
	0x83, 0x15, 0x9f, 0x11, 0x4c, 0x62, 0x3b, 0x1d, 0x79, 0x91, 0x68, 0x72, 0x11, 0x73, 0xc9, 0x92,
	0xe8, 0x35, 0x29, 0x7a, 0x46, 0x85, 0xf0, 0x5f, 0x45, 0x34, 0xfd, 0x06, 0x39, 0xad, 0x3f, 0x7e,
	0xf4, 0x29, 0xf2, 0x70, 0x05, 0x66, 0x2c, 0xbb, 0xeb, 0x31, 0xbd, 0x8b, 0xfd, 0xb6, 0x83, 0xcd,
	0xc0, 0xa0, 0x82, 0x20, 0xee, 0x49, 0x1a, 0x07, 0x19, 0x8e, 0x6d, 0x13, 0x21, 0x8a, 0x1f, 0x21,
	0x27, 0xa2, 0x42, 0x9f, 0x58, 0x37, 0xd1, 0x2f, 0xa0, 0x4c, 0x49, 0x1b, 0x33, 0xeb, 0x84, 0xe8,
	0xcc, 0xea, 0x10, 0xc7, 0x63, 0xe2, 0xbf, 0xcb, 0x70, 0xa7, 0x1b, 0x4c, 0x4b, 0x6a, 0x88, 0x68,
	0x4a, 0x40, 0x33, 0xe4, 0x27, 0x73, 0x2d, 0xe6, 0x9a, 0x16, 0xac, 0x0c, 0xb1, 0xfb, 0x13, 0x26,
	0xcb, 0x9f, 0x33, 0x22, 0x08, 0xb2, 0x21, 0x8d, 0xea, 0xe4, 0x1f, 0x4a, 0xd3, 0x5e, 0x85, 0x1f,
	0x0d, 0xf7, 0x51, 0x94, 0xb0, 0xdf, 0x4e, 0x84, 0x9d, 0xf3, 0xa5, 0x98, 0x11, 0x46, 0xb8, 0x01,
	0x55, 0xc8, 0x61, 0xf9, 0x8e, 0x09, 0x2b, 0x30, 0x58, 0x9e, 0x1b, 0xce, 0xc7, 0x65, 0xeb, 0x0f,
	0x87, 0xf3, 0x65, 0x28, 0x04, 0x7d, 0x55, 0x4e, 0xe4, 0xb2, 0x08, 0x83, 0x5e, 0x5b, 0x17, 0x73,
	0xf9, 0x90, 0x81, 0x04, 0xc1, 0x44, 0x34, 0x81, 0xe4, 0x35, 0xf1, 0x3d, 0x68, 0x48, 0xc9, 0x7d,
	0xe4, 0x90, 0x32, 0xf5, 0x49, 0x86, 0x94, 0xf8, 0xfd, 0x91, 0x1f, 0xf1, 0xfe, 0x38, 0x7b, 0x19,
	0xc0, 0xa5, 0x2e, 0x83, 0x78, 0x7f, 0x9f, 0x4e, 0xf4, 0xf7, 0xb0, 0x86, 0x0b, 0xfd, 0xfb, 0xa2,
	0x08, 0x19, 0xd6, 0x53, 0x67, 0x04, 0x34, 0xc3, 0x7a, 0xb1, 0x2c, 0x7a, 0x18, 0xde, 0x00, 0xe9,
	0xa9, 0x11, 0x15, 0xf5, 0x35, 0x3e, 0x1e, 0x9f, 0x19, 0xae, 0x26, 0xa9, 0x98, 0xac, 0x7c, 0x40,
	0xd1, 0xb3, 0x71, 0x87, 0xf8, 0xf2, 0x29, 0x34, 0x7a, 0x07, 0x4c, 0xbe, 0xaf, 0xc6, 0x93, 0xef,
	0xab, 0x98, 0xe6, 0x0b, 0x50, 0x4e, 0x8a, 0x0e, 0xf5, 0x5d, 0xfb, 0x19, 0xcc, 0xa6, 0x04, 0x13,
	0x4d, 0x43, 0xee, 0x79, 0x63, 0xa7, 0xf1, 0xec, 0xeb, 0x46, 0x69, 0x0c, 0x95, 0xa0, 0xb0, 0x59,
	0x6f, 0x3e, 0x7e, 0x56, 0x6f, 0xe8, 0x7b, 0xbf, 0x7a, 0xbe, 0x5f, 0x52, 0xd6, 0x9e, 0xc2, 0xd5,
	0xc4, 0x04, 0x82, 0x66, 0x20, 0xff, 0xbc, 0xf1, 0x64, 0x6b, 0xbb, 0xde, 0xd8, 0x7a, 0x52, 0x1a,
	0xe3, 0x47, 0xec, 0x3e, 0xaa, 0x37, 0x1a, 0x5b, 0xcd, 0x92, 0x82, 0x00, 0xb2, 0x4f, 0xb6, 0x5e,
	0xf0, 0xef, 0x0c, 0x67, 0x34, 0xb7, 0xf6, 0x9b, 0x7c, 0x31, 0xbe, 0xf1, 0x2d, 0xc0, 0xf8, 0xae,
	0xdb, 0x42, 0xbf, 0x86, 0xc2, 0xb9, 0x1f, 0x0d, 0x96, 0x53, 0xdf, 0x3d, 0x67, 0x21, 0xe5, 0x1f,
	0x5f, 0x08, 0x89, 0xa2, 0xa2, 0xc3, 0xcc, 0xf9, 0x67, 0x79, 0x65, 0xc8, 0xb3, 0x2a, 0xc0, 0x94,
	0xd7, 0x2e, 0xc6, 0x44, 0x02, 0x8e, 0xa0, 0x94, 0x78, 0x3c, 0xde, 0x4d, 0xdd, 0x1f, 0x87, 0x95,
	0xd7, 0x2f, 0x05, 0x8b, 0x24, 0xbd, 0x82, 0xd9, 0xb4, 0x67, 0xd2, 0xea, 0x20, 0x65, 0xe3, 0xc8,
	0xf2, 0xbd, 0xcb, 0x22, 0x23, 0x91, 0xaf, 0xe1, 0xfa, 0x80, 0x27, 0xc1, 0x4f, 0x86, 0xe8, 0x9e,
	0x10, 0xfc, 0xf9, 0x08, 0xe0, 0x48, 0xf6, 0xef, 0x14, 0x98, 0x1f, 0x3c, 0xca, 0x56, 0x87, 0xd9,
	0x92, 0xc4, 0x97, 0xef, 0x8f, 0x86, 0x3f, 0xeb, 0xf4, 0xb4, 0x89, 0x2c, 0xdd, 0xe9, 0x29, 0xc8,
	0x01, 0x4e, 0x1f, 0x32, 0x3d, 0xa1, 0x6f, 0x14, 0x50, 0x07, 0x8e, 0x4e, 0xeb, 0x83, 0xec, 0x48,
	0x85, 0x97, 0xbf, 0x18, 0x09, 0x1e, 0xa9, 0xf0, 0x7b, 0x05, 0x6e, 0x0e, 0x9b, 0x2d, 0xee, 0x0d,
	0x09, 0x68, 0xba, 0x22, 0x5f, 0x8e, 0xba, 0x23, 0x9e, 0x07, 0x03, 0x2e, 0xe6, 0x81, 0x79, 0x90,
	0x8e, 0x1f, 0x9c, 0x07, 0x17, 0x74, 0x77, 0x02, 0x57, 0xe2, 0x3d, 0xfc, 0xce, 0x90, 0x2e, 0x14,
	0xa1, 0xca, 0x3f, 0xbd, 0x0c, 0x2a, 0x14, 0x53, 0x9e, 0xfc, 0xe6, 0xc3, 0x9b, 0x35, 0x65, 0x73,
	0xff, 0xbb, 0x77, 0x8b, 0xca, 0xf7, 0xef, 0x16, 0x95, 0xff, 0xbc, 0x5b, 0x54, 0xfe, 0xf8, 0x7e,
	0x71, 0xec, 0xfb, 0xf7, 0x8b, 0x63, 0xff, 0x7e, 0xbf, 0x38, 0xf6, 0xf2, 0xe7, 0x1f, 0xf3, 0x53,
	0x26, 0xbf, 0x7c, 0xdd, 0x83, 0xac, 0xb8, 0x33, 0x3f, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x21, 0x4d, 0x38, 0x09, 0xc9, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines the operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// NewKeyRequest defines an operation for creating a key request.
	NewKeyRequest(ctx context.Context, in *MsgNewKeyRequest, opts ...grpc.CallOption) (*MsgNewKeyRequestResponse, error)
	// FulfilKeyRequest defines an operation for responding to a key request
	FulfilKeyRequest(ctx context.Context, in *MsgFulfilKeyRequest, opts ...grpc.CallOption) (*MsgFulfilKeyRequestResponse, error)
	// NewSignatureRequest defines an operation for creating a signature request
	NewSignatureRequest(ctx context.Context, in *MsgNewSignatureRequest, opts ...grpc.CallOption) (*MsgNewSignatureRequestResponse, error)
	// FulfilSignatureRequest defines an operation for returning a signature
	// response to a request
	FulfilSignatureRequest(ctx context.Context, in *MsgFulfilSignatureRequest, opts ...grpc.CallOption) (*MsgFulfilSignatureRequestResponse, error)
	// NewSignTransactionRequest defines an operation for creating a signature for
	// transaction request
	NewSignTransactionRequest(ctx context.Context, in *MsgNewSignTransactionRequest, opts ...grpc.CallOption) (*MsgNewSignTransactionRequestResponse, error)
	// TransferFromKeyring defines an operation for transferring tokens from a
	// keyring
	TransferFromKeyring(ctx context.Context, in *MsgTransferFromKeyring, opts ...grpc.CallOption) (*MsgTransferFromKeyringResponse, error)
	// NewICATransactionRequest defines an operation for creating an interchain
	// account transaction request
	NewICATransactionRequest(ctx context.Context, in *MsgNewICATransactionRequest, opts ...grpc.CallOption) (*MsgNewICATransactionRequestResponse, error)
	// FulfilICATransactionRequest defines an operation for responding to an
	// interchain account transaction request
	FulfilICATransactionRequest(ctx context.Context, in *MsgFulfilICATransactionRequest, opts ...grpc.CallOption) (*MsgFulfilICATransactionRequestResponse, error)
	NewZrSignSignatureRequest(ctx context.Context, in *MsgNewZrSignSignatureRequest, opts ...grpc.CallOption) (*MsgNewZrSignSignatureRequestResponse, error)
	UpdateKeyPolicy(ctx context.Context, in *MsgUpdateKeyPolicy, opts ...grpc.CallOption) (*MsgUpdateKeyPolicyResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewKeyRequest(ctx context.Context, in *MsgNewKeyRequest, opts ...grpc.CallOption) (*MsgNewKeyRequestResponse, error) {
	out := new(MsgNewKeyRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/NewKeyRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) FulfilKeyRequest(ctx context.Context, in *MsgFulfilKeyRequest, opts ...grpc.CallOption) (*MsgFulfilKeyRequestResponse, error) {
	out := new(MsgFulfilKeyRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/FulfilKeyRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewSignatureRequest(ctx context.Context, in *MsgNewSignatureRequest, opts ...grpc.CallOption) (*MsgNewSignatureRequestResponse, error) {
	out := new(MsgNewSignatureRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/NewSignatureRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) FulfilSignatureRequest(ctx context.Context, in *MsgFulfilSignatureRequest, opts ...grpc.CallOption) (*MsgFulfilSignatureRequestResponse, error) {
	out := new(MsgFulfilSignatureRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/FulfilSignatureRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewSignTransactionRequest(ctx context.Context, in *MsgNewSignTransactionRequest, opts ...grpc.CallOption) (*MsgNewSignTransactionRequestResponse, error) {
	out := new(MsgNewSignTransactionRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/NewSignTransactionRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) TransferFromKeyring(ctx context.Context, in *MsgTransferFromKeyring, opts ...grpc.CallOption) (*MsgTransferFromKeyringResponse, error) {
	out := new(MsgTransferFromKeyringResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/TransferFromKeyring", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewICATransactionRequest(ctx context.Context, in *MsgNewICATransactionRequest, opts ...grpc.CallOption) (*MsgNewICATransactionRequestResponse, error) {
	out := new(MsgNewICATransactionRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/NewICATransactionRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) FulfilICATransactionRequest(ctx context.Context, in *MsgFulfilICATransactionRequest, opts ...grpc.CallOption) (*MsgFulfilICATransactionRequestResponse, error) {
	out := new(MsgFulfilICATransactionRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/FulfilICATransactionRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewZrSignSignatureRequest(ctx context.Context, in *MsgNewZrSignSignatureRequest, opts ...grpc.CallOption) (*MsgNewZrSignSignatureRequestResponse, error) {
	out := new(MsgNewZrSignSignatureRequestResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/NewZrSignSignatureRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateKeyPolicy(ctx context.Context, in *MsgUpdateKeyPolicy, opts ...grpc.CallOption) (*MsgUpdateKeyPolicyResponse, error) {
	out := new(MsgUpdateKeyPolicyResponse)
	err := c.cc.Invoke(ctx, "/zrchain.treasury.Msg/UpdateKeyPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines the operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// NewKeyRequest defines an operation for creating a key request.
	NewKeyRequest(context.Context, *MsgNewKeyRequest) (*MsgNewKeyRequestResponse, error)
	// FulfilKeyRequest defines an operation for responding to a key request
	FulfilKeyRequest(context.Context, *MsgFulfilKeyRequest) (*MsgFulfilKeyRequestResponse, error)
	// NewSignatureRequest defines an operation for creating a signature request
	NewSignatureRequest(context.Context, *MsgNewSignatureRequest) (*MsgNewSignatureRequestResponse, error)
	// FulfilSignatureRequest defines an operation for returning a signature
	// response to a request
	FulfilSignatureRequest(context.Context, *MsgFulfilSignatureRequest) (*MsgFulfilSignatureRequestResponse, error)
	// NewSignTransactionRequest defines an operation for creating a signature for
	// transaction request
	NewSignTransactionRequest(context.Context, *MsgNewSignTransactionRequest) (*MsgNewSignTransactionRequestResponse, error)
	// TransferFromKeyring defines an operation for transferring tokens from a
	// keyring
	TransferFromKeyring(context.Context, *MsgTransferFromKeyring) (*MsgTransferFromKeyringResponse, error)
	// NewICATransactionRequest defines an operation for creating an interchain
	// account transaction request
	NewICATransactionRequest(context.Context, *MsgNewICATransactionRequest) (*MsgNewICATransactionRequestResponse, error)
	// FulfilICATransactionRequest defines an operation for responding to an
	// interchain account transaction request
	FulfilICATransactionRequest(context.Context, *MsgFulfilICATransactionRequest) (*MsgFulfilICATransactionRequestResponse, error)
	NewZrSignSignatureRequest(context.Context, *MsgNewZrSignSignatureRequest) (*MsgNewZrSignSignatureRequestResponse, error)
	UpdateKeyPolicy(context.Context, *MsgUpdateKeyPolicy) (*MsgUpdateKeyPolicyResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) NewKeyRequest(ctx context.Context, req *MsgNewKeyRequest) (*MsgNewKeyRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewKeyRequest not implemented")
}
func (*UnimplementedMsgServer) FulfilKeyRequest(ctx context.Context, req *MsgFulfilKeyRequest) (*MsgFulfilKeyRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FulfilKeyRequest not implemented")
}
func (*UnimplementedMsgServer) NewSignatureRequest(ctx context.Context, req *MsgNewSignatureRequest) (*MsgNewSignatureRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewSignatureRequest not implemented")
}
func (*UnimplementedMsgServer) FulfilSignatureRequest(ctx context.Context, req *MsgFulfilSignatureRequest) (*MsgFulfilSignatureRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FulfilSignatureRequest not implemented")
}
func (*UnimplementedMsgServer) NewSignTransactionRequest(ctx context.Context, req *MsgNewSignTransactionRequest) (*MsgNewSignTransactionRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewSignTransactionRequest not implemented")
}
func (*UnimplementedMsgServer) TransferFromKeyring(ctx context.Context, req *MsgTransferFromKeyring) (*MsgTransferFromKeyringResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferFromKeyring not implemented")
}
func (*UnimplementedMsgServer) NewICATransactionRequest(ctx context.Context, req *MsgNewICATransactionRequest) (*MsgNewICATransactionRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewICATransactionRequest not implemented")
}
func (*UnimplementedMsgServer) FulfilICATransactionRequest(ctx context.Context, req *MsgFulfilICATransactionRequest) (*MsgFulfilICATransactionRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FulfilICATransactionRequest not implemented")
}
func (*UnimplementedMsgServer) NewZrSignSignatureRequest(ctx context.Context, req *MsgNewZrSignSignatureRequest) (*MsgNewZrSignSignatureRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewZrSignSignatureRequest not implemented")
}
func (*UnimplementedMsgServer) UpdateKeyPolicy(ctx context.Context, req *MsgUpdateKeyPolicy) (*MsgUpdateKeyPolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKeyPolicy not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewKeyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewKeyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/NewKeyRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewKeyRequest(ctx, req.(*MsgNewKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_FulfilKeyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFulfilKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).FulfilKeyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/FulfilKeyRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).FulfilKeyRequest(ctx, req.(*MsgFulfilKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewSignatureRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewSignatureRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/NewSignatureRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewSignatureRequest(ctx, req.(*MsgNewSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_FulfilSignatureRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFulfilSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).FulfilSignatureRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/FulfilSignatureRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).FulfilSignatureRequest(ctx, req.(*MsgFulfilSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewSignTransactionRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewSignTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewSignTransactionRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/NewSignTransactionRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewSignTransactionRequest(ctx, req.(*MsgNewSignTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_TransferFromKeyring_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgTransferFromKeyring)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).TransferFromKeyring(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/TransferFromKeyring",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).TransferFromKeyring(ctx, req.(*MsgTransferFromKeyring))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewICATransactionRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewICATransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewICATransactionRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/NewICATransactionRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewICATransactionRequest(ctx, req.(*MsgNewICATransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_FulfilICATransactionRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFulfilICATransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).FulfilICATransactionRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/FulfilICATransactionRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).FulfilICATransactionRequest(ctx, req.(*MsgFulfilICATransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewZrSignSignatureRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewZrSignSignatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewZrSignSignatureRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/NewZrSignSignatureRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewZrSignSignatureRequest(ctx, req.(*MsgNewZrSignSignatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateKeyPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateKeyPolicy)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateKeyPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/zrchain.treasury.Msg/UpdateKeyPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateKeyPolicy(ctx, req.(*MsgUpdateKeyPolicy))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "zrchain.treasury.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "NewKeyRequest",
			Handler:    _Msg_NewKeyRequest_Handler,
		},
		{
			MethodName: "FulfilKeyRequest",
			Handler:    _Msg_FulfilKeyRequest_Handler,
		},
		{
			MethodName: "NewSignatureRequest",
			Handler:    _Msg_NewSignatureRequest_Handler,
		},
		{
			MethodName: "FulfilSignatureRequest",
			Handler:    _Msg_FulfilSignatureRequest_Handler,
		},
		{
			MethodName: "NewSignTransactionRequest",
			Handler:    _Msg_NewSignTransactionRequest_Handler,
		},
		{
			MethodName: "TransferFromKeyring",
			Handler:    _Msg_TransferFromKeyring_Handler,
		},
		{
			MethodName: "NewICATransactionRequest",
			Handler:    _Msg_NewICATransactionRequest_Handler,
		},
		{
			MethodName: "FulfilICATransactionRequest",
			Handler:    _Msg_FulfilICATransactionRequest_Handler,
		},
		{
			MethodName: "NewZrSignSignatureRequest",
			Handler:    _Msg_NewZrSignSignatureRequest_Handler,
		},
		{
			MethodName: "UpdateKeyPolicy",
			Handler:    _Msg_UpdateKeyPolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "zrchain/treasury/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgNewKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ZenbtcMetadata != nil {
		{
			size, err := m.ZenbtcMetadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SignPolicyId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SignPolicyId))
		i--
		dAtA[i] = 0x48
	}
	if m.ExtKeyType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExtKeyType))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ExtRequester) > 0 {
		i -= len(m.ExtRequester)
		copy(dAtA[i:], m.ExtRequester)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ExtRequester)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Index != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x30
	}
	if m.Btl != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Btl))
		i--
		dAtA[i] = 0x28
	}
	if len(m.KeyType) > 0 {
		i -= len(m.KeyType)
		copy(dAtA[i:], m.KeyType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.KeyringAddr) > 0 {
		i -= len(m.KeyringAddr)
		copy(dAtA[i:], m.KeyringAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyringAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.WorkspaceAddr) > 0 {
		i -= len(m.WorkspaceAddr)
		copy(dAtA[i:], m.WorkspaceAddr)
		i = encodeVarintTx(dAtA, i, uint64(len(m.WorkspaceAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgNewKeyRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewKeyRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewKeyRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyReqId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyReqId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilKeyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfilKeyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilKeyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.KeyringPartySignature) > 0 {
		i -= len(m.KeyringPartySignature)
		copy(dAtA[i:], m.KeyringPartySignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyringPartySignature)))
		i--
		dAtA[i] = 0x32
	}
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilKeyRequest_Key) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilKeyRequest_Key) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Key != nil {
		{
			size, err := m.Key.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MsgFulfilKeyRequest_RejectReason) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilKeyRequest_RejectReason) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.RejectReason)
	copy(dAtA[i:], m.RejectReason)
	i = encodeVarintTx(dAtA, i, uint64(len(m.RejectReason)))
	i--
	dAtA[i] = 0x2a
	return len(dAtA) - i, nil
}
func (m *MsgNewKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilKeyRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfilKeyRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilKeyRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgNewSignatureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewSignatureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewSignatureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VerifySigningDataVersion != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VerifySigningDataVersion))
		i--
		dAtA[i] = 0x38
	}
	if len(m.VerifySigningData) > 0 {
		i -= len(m.VerifySigningData)
		copy(dAtA[i:], m.VerifySigningData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VerifySigningData)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CacheId) > 0 {
		i -= len(m.CacheId)
		copy(dAtA[i:], m.CacheId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CacheId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Btl != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Btl))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DataForSigning) > 0 {
		i -= len(m.DataForSigning)
		copy(dAtA[i:], m.DataForSigning)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DataForSigning)))
		i--
		dAtA[i] = 0x1a
	}
	if m.KeyId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgNewSignatureRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewSignatureRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewSignatureRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SigReqId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SigReqId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilSignatureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfilSignatureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilSignatureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RejectReason) > 0 {
		i -= len(m.RejectReason)
		copy(dAtA[i:], m.RejectReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RejectReason)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SignedData) > 0 {
		i -= len(m.SignedData)
		copy(dAtA[i:], m.SignedData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SignedData)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyringPartySignature) > 0 {
		i -= len(m.KeyringPartySignature)
		copy(dAtA[i:], m.KeyringPartySignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyringPartySignature)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilSignatureRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfilSignatureRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilSignatureRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MetadataEthereum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataEthereum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataEthereum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChainId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ChainId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetadataSolana) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataSolana) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataSolana) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Network != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Network))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgNewSignTransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewSignTransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewSignTransactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoBroadcast {
		i--
		if m.NoBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.CacheId) > 0 {
		i -= len(m.CacheId)
		copy(dAtA[i:], m.CacheId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CacheId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Btl != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Btl))
		i--
		dAtA[i] = 0x30
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.UnsignedTransaction) > 0 {
		i -= len(m.UnsignedTransaction)
		copy(dAtA[i:], m.UnsignedTransaction)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UnsignedTransaction)))
		i--
		dAtA[i] = 0x22
	}
	if m.WalletType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WalletType))
		i--
		dAtA[i] = 0x18
	}
	if m.KeyId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgNewSignTransactionRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewSignTransactionRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewSignTransactionRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignatureRequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SignatureRequestId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferFromKeyring) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferFromKeyring) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferFromKeyring) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Amount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyring) > 0 {
		i -= len(m.Keyring)
		copy(dAtA[i:], m.Keyring)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Keyring)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgTransferFromKeyringResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgTransferFromKeyringResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgTransferFromKeyringResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgNewICATransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewICATransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewICATransactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Btl != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Btl))
		i--
		dAtA[i] = 0x30
	}
	if m.RelativeTimeoutTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RelativeTimeoutTimestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ConnectionId) > 0 {
		i -= len(m.ConnectionId)
		copy(dAtA[i:], m.ConnectionId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ConnectionId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InputPayload) > 0 {
		i -= len(m.InputPayload)
		copy(dAtA[i:], m.InputPayload)
		i = encodeVarintTx(dAtA, i, uint64(len(m.InputPayload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.KeyId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgNewICATransactionRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewICATransactionRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewICATransactionRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignatureRequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SignatureRequestId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilICATransactionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfilICATransactionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilICATransactionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RejectReason) > 0 {
		i -= len(m.RejectReason)
		copy(dAtA[i:], m.RejectReason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RejectReason)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SignedData) > 0 {
		i -= len(m.SignedData)
		copy(dAtA[i:], m.SignedData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SignedData)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.KeyringPartySignature) > 0 {
		i -= len(m.KeyringPartySignature)
		copy(dAtA[i:], m.KeyringPartySignature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyringPartySignature)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.RequestId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFulfilICATransactionRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFulfilICATransactionRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFulfilICATransactionRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgNewZrSignSignatureRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewZrSignSignatureRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewZrSignSignatureRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tx {
		i--
		if m.Tx {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.Btl != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Btl))
		i--
		dAtA[i] = 0x60
	}
	if m.NoBroadcast {
		i--
		if m.NoBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.WalletType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WalletType))
		i--
		dAtA[i] = 0x48
	}
	if m.VerifySigningDataVersion != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.VerifySigningDataVersion))
		i--
		dAtA[i] = 0x40
	}
	if len(m.VerifySigningData) > 0 {
		i -= len(m.VerifySigningData)
		copy(dAtA[i:], m.VerifySigningData)
		i = encodeVarintTx(dAtA, i, uint64(len(m.VerifySigningData)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CacheId) > 0 {
		i -= len(m.CacheId)
		copy(dAtA[i:], m.CacheId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CacheId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.WalletIndex != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.WalletIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.KeyType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgNewZrSignSignatureRequestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgNewZrSignSignatureRequestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgNewZrSignSignatureRequestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ReqId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateKeyPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateKeyPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateKeyPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignPolicyId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SignPolicyId))
		i--
		dAtA[i] = 0x18
	}
	if m.KeyId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.KeyId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateKeyPolicyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateKeyPolicyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateKeyPolicyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgNewKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.WorkspaceAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.KeyringAddr)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.KeyType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Btl != 0 {
		n += 1 + sovTx(uint64(m.Btl))
	}
	if m.Index != 0 {
		n += 1 + sovTx(uint64(m.Index))
	}
	l = len(m.ExtRequester)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExtKeyType != 0 {
		n += 1 + sovTx(uint64(m.ExtKeyType))
	}
	if m.SignPolicyId != 0 {
		n += 1 + sovTx(uint64(m.SignPolicyId))
	}
	if m.ZenbtcMetadata != nil {
		l = m.ZenbtcMetadata.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgNewKeyRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyReqId != 0 {
		n += 1 + sovTx(uint64(m.KeyReqId))
	}
	return n
}

func (m *MsgFulfilKeyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovTx(uint64(m.RequestId))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	if m.Result != nil {
		n += m.Result.Size()
	}
	l = len(m.KeyringPartySignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgFulfilKeyRequest_Key) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Key != nil {
		l = m.Key.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}
func (m *MsgFulfilKeyRequest_RejectReason) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RejectReason)
	n += 1 + l + sovTx(uint64(l))
	return n
}
func (m *MsgNewKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgFulfilKeyRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgNewSignatureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovTx(uint64(m.KeyId))
	}
	l = len(m.DataForSigning)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Btl != 0 {
		n += 1 + sovTx(uint64(m.Btl))
	}
	l = len(m.CacheId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VerifySigningData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VerifySigningDataVersion != 0 {
		n += 1 + sovTx(uint64(m.VerifySigningDataVersion))
	}
	return n
}

func (m *MsgNewSignatureRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SigReqId != 0 {
		n += 1 + sovTx(uint64(m.SigReqId))
	}
	return n
}

func (m *MsgFulfilSignatureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovTx(uint64(m.RequestId))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	l = len(m.KeyringPartySignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SignedData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RejectReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgFulfilSignatureRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MetadataEthereum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovTx(uint64(m.ChainId))
	}
	return n
}

func (m *MetadataSolana) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Network != 0 {
		n += 1 + sovTx(uint64(m.Network))
	}
	return n
}

func (m *MsgNewSignTransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovTx(uint64(m.KeyId))
	}
	if m.WalletType != 0 {
		n += 1 + sovTx(uint64(m.WalletType))
	}
	l = len(m.UnsignedTransaction)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Btl != 0 {
		n += 1 + sovTx(uint64(m.Btl))
	}
	l = len(m.CacheId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NoBroadcast {
		n += 2
	}
	return n
}

func (m *MsgNewSignTransactionRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	if m.SignatureRequestId != 0 {
		n += 1 + sovTx(uint64(m.SignatureRequestId))
	}
	return n
}

func (m *MsgTransferFromKeyring) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Keyring)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovTx(uint64(m.Amount))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgTransferFromKeyringResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgNewICATransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovTx(uint64(m.KeyId))
	}
	l = len(m.InputPayload)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ConnectionId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RelativeTimeoutTimestamp != 0 {
		n += 1 + sovTx(uint64(m.RelativeTimeoutTimestamp))
	}
	if m.Btl != 0 {
		n += 1 + sovTx(uint64(m.Btl))
	}
	return n
}

func (m *MsgNewICATransactionRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTx(uint64(m.Id))
	}
	if m.SignatureRequestId != 0 {
		n += 1 + sovTx(uint64(m.SignatureRequestId))
	}
	return n
}

func (m *MsgFulfilICATransactionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RequestId != 0 {
		n += 1 + sovTx(uint64(m.RequestId))
	}
	if m.Status != 0 {
		n += 1 + sovTx(uint64(m.Status))
	}
	l = len(m.KeyringPartySignature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SignedData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RejectReason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgFulfilICATransactionRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgNewZrSignSignatureRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyType != 0 {
		n += 1 + sovTx(uint64(m.KeyType))
	}
	if m.WalletIndex != 0 {
		n += 1 + sovTx(uint64(m.WalletIndex))
	}
	l = len(m.CacheId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.VerifySigningData)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.VerifySigningDataVersion != 0 {
		n += 1 + sovTx(uint64(m.VerifySigningDataVersion))
	}
	if m.WalletType != 0 {
		n += 1 + sovTx(uint64(m.WalletType))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NoBroadcast {
		n += 2
	}
	if m.Btl != 0 {
		n += 1 + sovTx(uint64(m.Btl))
	}
	if m.Tx {
		n += 2
	}
	return n
}

func (m *MsgNewZrSignSignatureRequestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqId != 0 {
		n += 1 + sovTx(uint64(m.ReqId))
	}
	return n
}

func (m *MsgUpdateKeyPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.KeyId != 0 {
		n += 1 + sovTx(uint64(m.KeyId))
	}
	if m.SignPolicyId != 0 {
		n += 1 + sovTx(uint64(m.SignPolicyId))
	}
	return n
}

func (m *MsgUpdateKeyPolicyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkspaceAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkspaceAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Btl", wireType)
			}
			m.Btl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Btl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtRequester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtRequester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtKeyType", wireType)
			}
			m.ExtKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExtKeyType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPolicyId", wireType)
			}
			m.SignPolicyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignPolicyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZenbtcMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZenbtcMetadata == nil {
				m.ZenbtcMetadata = &ZenBTCMetdata{}
			}
			if err := m.ZenbtcMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewKeyRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewKeyRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewKeyRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyReqId", wireType)
			}
			m.KeyReqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyReqId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfilKeyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfilKeyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfilKeyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= KeyRequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MsgNewKey{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &MsgFulfilKeyRequest_Key{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = &MsgFulfilKeyRequest_RejectReason{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringPartySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringPartySignature = append(m.KeyringPartySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyringPartySignature == nil {
				m.KeyringPartySignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfilKeyRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfilKeyRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfilKeyRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewSignatureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewSignatureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewSignatureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataForSigning", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataForSigning = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Btl", wireType)
			}
			m.Btl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Btl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheId = append(m.CacheId[:0], dAtA[iNdEx:postIndex]...)
			if m.CacheId == nil {
				m.CacheId = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySigningData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifySigningData = append(m.VerifySigningData[:0], dAtA[iNdEx:postIndex]...)
			if m.VerifySigningData == nil {
				m.VerifySigningData = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySigningDataVersion", wireType)
			}
			m.VerifySigningDataVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifySigningDataVersion |= VerificationVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewSignatureRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewSignatureRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewSignatureRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigReqId", wireType)
			}
			m.SigReqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SigReqId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfilSignatureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfilSignatureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfilSignatureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SignRequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringPartySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringPartySignature = append(m.KeyringPartySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyringPartySignature == nil {
				m.KeyringPartySignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedData = append(m.SignedData[:0], dAtA[iNdEx:postIndex]...)
			if m.SignedData == nil {
				m.SignedData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RejectReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfilSignatureRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfilSignatureRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfilSignatureRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataEthereum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataEthereum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataEthereum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataSolana) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataSolana: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataSolana: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			m.Network = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Network |= SolanaNetworkType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewSignTransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewSignTransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewSignTransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletType", wireType)
			}
			m.WalletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletType |= WalletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedTransaction", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnsignedTransaction = append(m.UnsignedTransaction[:0], dAtA[iNdEx:postIndex]...)
			if m.UnsignedTransaction == nil {
				m.UnsignedTransaction = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &types.Any{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Btl", wireType)
			}
			m.Btl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Btl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheId = append(m.CacheId[:0], dAtA[iNdEx:postIndex]...)
			if m.CacheId == nil {
				m.CacheId = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoBroadcast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewSignTransactionRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewSignTransactionRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewSignTransactionRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureRequestId", wireType)
			}
			m.SignatureRequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureRequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferFromKeyring) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferFromKeyring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferFromKeyring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyring", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyring = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgTransferFromKeyringResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgTransferFromKeyringResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgTransferFromKeyringResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewICATransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewICATransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewICATransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputPayload", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputPayload = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelativeTimeoutTimestamp", wireType)
			}
			m.RelativeTimeoutTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelativeTimeoutTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Btl", wireType)
			}
			m.Btl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Btl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewICATransactionRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewICATransactionRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewICATransactionRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureRequestId", wireType)
			}
			m.SignatureRequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureRequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfilICATransactionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfilICATransactionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfilICATransactionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			m.RequestId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SignRequestStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyringPartySignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyringPartySignature = append(m.KeyringPartySignature[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyringPartySignature == nil {
				m.KeyringPartySignature = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedData = append(m.SignedData[:0], dAtA[iNdEx:postIndex]...)
			if m.SignedData == nil {
				m.SignedData = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RejectReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFulfilICATransactionRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFulfilICATransactionRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFulfilICATransactionRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewZrSignSignatureRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewZrSignSignatureRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewZrSignSignatureRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletIndex", wireType)
			}
			m.WalletIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CacheId = append(m.CacheId[:0], dAtA[iNdEx:postIndex]...)
			if m.CacheId == nil {
				m.CacheId = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySigningData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifySigningData = append(m.VerifySigningData[:0], dAtA[iNdEx:postIndex]...)
			if m.VerifySigningData == nil {
				m.VerifySigningData = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifySigningDataVersion", wireType)
			}
			m.VerifySigningDataVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifySigningDataVersion |= VerificationVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletType", wireType)
			}
			m.WalletType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WalletType |= WalletType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &types.Any{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoBroadcast = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Btl", wireType)
			}
			m.Btl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Btl |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tx = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgNewZrSignSignatureRequestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgNewZrSignSignatureRequestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgNewZrSignSignatureRequestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			m.ReqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateKeyPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateKeyPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateKeyPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignPolicyId", wireType)
			}
			m.SignPolicyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignPolicyId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateKeyPolicyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateKeyPolicyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateKeyPolicyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
